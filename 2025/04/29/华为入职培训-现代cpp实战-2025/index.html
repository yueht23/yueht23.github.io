<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yueht23.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false,"animation":true,"content_length":400,"show_result":true,"show_result_on_focus":true,"auto_focus":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="1. C++的特点与演化为什么要用C++ 贴近硬件   零抽象开销，如果不适用抽象则没有额外抽象  C与C++ 功能上C++是C的超集，但是C代码不一定是合法的C++代码 C++更加严格和安全，例如const正确性 现代C++的惯用法和C大相径庭  C++的演进 C++98：开天辟地，第一套ISO标准 C++03：小幅修订，主要修复C++98的标准文本问题，无语言特性变化。   C++11：革命性">
<meta property="og:type" content="article">
<meta property="og:title" content="华为入职培训-现代cpp实战-2025">
<meta property="og:url" content="https://yueht23.github.io/2025/04/29/%E5%8D%8E%E4%B8%BA%E5%85%A5%E8%81%8C%E5%9F%B9%E8%AE%AD-%E7%8E%B0%E4%BB%A3cpp%E5%AE%9E%E6%88%98-2025/index.html">
<meta property="og:site_name" content="Yueht&#39;s Blog">
<meta property="og:description" content="1. C++的特点与演化为什么要用C++ 贴近硬件   零抽象开销，如果不适用抽象则没有额外抽象  C与C++ 功能上C++是C的超集，但是C代码不一定是合法的C++代码 C++更加严格和安全，例如const正确性 现代C++的惯用法和C大相径庭  C++的演进 C++98：开天辟地，第一套ISO标准 C++03：小幅修订，主要修复C++98的标准文本问题，无语言特性变化。   C++11：革命性">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://yueht23.github.io/images/1746961095204-image.png">
<meta property="og:image" content="https://yueht23.github.io/images/1746962209368-image.png">
<meta property="og:image" content="https://yueht23.github.io/images/1746962538602-image.png">
<meta property="og:image" content="https://yueht23.github.io/images/1746962827885-image.png">
<meta property="og:image" content="https://yueht23.github.io/images/1746962906840-image.png">
<meta property="og:image" content="https://yueht23.github.io/images/1747049713743-image.png">
<meta property="og:image" content="https://yueht23.github.io/images/1747049838519-image.png">
<meta property="og:image" content="https://yueht23.github.io/images/1747049854419-image.png">
<meta property="og:image" content="https://yueht23.github.io/images/1747481889476-image.png">
<meta property="og:image" content="https://yueht23.github.io/images/1747482482431-image.png">
<meta property="article:published_time" content="2025-04-29T11:18:09.000Z">
<meta property="article:modified_time" content="2025-05-28T15:26:59.285Z">
<meta property="article:author" content="Yueht">
<meta property="article:tag" content="cpp">
<meta property="article:tag" content="华为">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://yueht23.github.io/images/1746961095204-image.png">

<link rel="canonical" href="https://yueht23.github.io/2025/04/29/%E5%8D%8E%E4%B8%BA%E5%85%A5%E8%81%8C%E5%9F%B9%E8%AE%AD-%E7%8E%B0%E4%BB%A3cpp%E5%AE%9E%E6%88%98-2025/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>华为入职培训-现代cpp实战-2025 | Yueht's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">
<!-- hexo injector head_end end --></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Yueht's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://yueht23.github.io/2025/04/29/%E5%8D%8E%E4%B8%BA%E5%85%A5%E8%81%8C%E5%9F%B9%E8%AE%AD-%E7%8E%B0%E4%BB%A3cpp%E5%AE%9E%E6%88%98-2025/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yueht">
      <meta itemprop="description" content="个人博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yueht's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          华为入职培训-现代cpp实战-2025
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-04-29 19:18:09" itemprop="dateCreated datePublished" datetime="2025-04-29T19:18:09+08:00">2025-04-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-05-28 23:26:59" itemprop="dateModified" datetime="2025-05-28T23:26:59+08:00">2025-05-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%BD%AF%E4%BB%B6%E9%9B%8F%E9%B9%B0%E8%AE%A1%E5%88%92/" itemprop="url" rel="index"><span itemprop="name">软件雏鹰计划</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="1-C-的特点与演化"><a href="#1-C-的特点与演化" class="headerlink" title="1. C++的特点与演化"></a>1. C++的特点与演化</h1><h2 id="为什么要用C"><a href="#为什么要用C" class="headerlink" title="为什么要用C++"></a>为什么要用C++</h2><ul>
<li>贴近硬件  </li>
<li>零抽象开销，如果不适用抽象则没有额外抽象</li>
</ul>
<h2 id="C与C"><a href="#C与C" class="headerlink" title="C与C++"></a>C与C++</h2><ul>
<li>功能上C++是C的超集，但是C代码不一定是合法的C++代码</li>
<li>C++更加严格和安全，例如const正确性</li>
<li>现代C++的惯用法和C大相径庭</li>
</ul>
<h2 id="C-的演进"><a href="#C-的演进" class="headerlink" title="C++的演进"></a>C++的演进</h2><ul>
<li><strong>C++98</strong>：开天辟地，第一套ISO标准</li>
<li><strong>C++03</strong>：小幅修订，主要修复C++98的标准文本问题，无语言特性变化。  </li>
<li><strong>C++11</strong>：革命性升级，引入自动类型推导、右值引用、智能指针、Lambda表达式等现代特性。  </li>
<li><strong>C++14</strong>：完善C++11，增强泛型编程（泛型Lambda）、放宽<code>constexpr</code>限制等小改进。  </li>
<li><strong>C++17</strong>：聚焦简化代码，引入结构化绑定、<code>std::variant</code>、并行STL等实用特性。  </li>
<li><strong>C++20</strong>：迈向新时代，加入模块（Modules）、概念（Concepts）、协程（Coroutines）等重大特性。  </li>
<li><strong>C++23</strong>：增量改进，扩展标准库（<code>std::mdspan</code>、格式化库），优化已有功能（<code>if consteval</code>）。</li>
</ul>
<p><strong>我们主要关注C++17</strong></p>
<h2 id="c-委员会的工作方式"><a href="#c-委员会的工作方式" class="headerlink" title="c++委员会的工作方式"></a>c++委员会的工作方式</h2><ul>
<li>基于共识consensuse，至少80%的成员同意，才能通过提案</li>
<li>不是民主，少数服从多数</li>
<li>不是独裁，不是c++之父(Bjarne Stroustrup)说了算</li>
</ul>
<h1 id="2-资源管理和对象的基本规则"><a href="#2-资源管理和对象的基本规则" class="headerlink" title="2. 资源管理和对象的基本规则"></a>2. 资源管理和对象的基本规则</h1><h2 id="2-资源管理和对象的基本规则-1"><a href="#2-资源管理和对象的基本规则-1" class="headerlink" title="2. 资源管理和对象的基本规则"></a>2. 资源管理和对象的基本规则</h2><h3 id="堆与栈"><a href="#堆与栈" class="headerlink" title="堆与栈"></a>堆与栈</h3><p>内存中的 <strong>堆（Heap）</strong> 和 <strong>栈（Stack）</strong> 是程序运行时存储数据的两个重要区域，它们的特点和用途完全不同。用生活中的例子来类比：</p>
<h4 id="1-栈（Stack）——像“快餐店取餐盘”"><a href="#1-栈（Stack）——像“快餐店取餐盘”" class="headerlink" title="1. 栈（Stack）——像“快餐店取餐盘”"></a><strong>1. 栈（Stack）——像“快餐店取餐盘”</strong></h4><ul>
<li><strong>特点</strong>：<ul>
<li><strong>自动管理</strong>：系统自动分配和释放内存（比如函数调用时创建，函数结束自动清除）。</li>
<li><strong>速度快</strong>：内存分配是连续的，类似叠盘子（后进先出）。</li>
<li><strong>空间小</strong>：通常有固定大小（比如几MB），存储局部变量、函数参数等。</li>
</ul>
</li>
<li><strong>例子</strong>：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>; <span class="comment">// x 存储在栈上，函数结束后自动释放</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>缺点</strong>：不能灵活存储大量数据或长期保存数据。</li>
</ul>
<h4 id="2-堆（Heap）——像“自助仓库”"><a href="#2-堆（Heap）——像“自助仓库”" class="headerlink" title="2. 堆（Heap）——像“自助仓库”"></a><strong>2. 堆（Heap）——像“自助仓库”</strong></h4><ul>
<li><strong>特点</strong>：<ul>
<li><strong>手动管理</strong>：需要程序员主动申请（如 <code>malloc</code>、<code>new</code>）和释放（如 <code>free</code>、<code>delete</code>）。</li>
<li><strong>速度慢</strong>：内存分配不连续，需要动态查找可用空间。</li>
<li><strong>空间大</strong>：可用空间通常远大于栈，适合存放大数据或长期存在的数据。</li>
</ul>
</li>
<li><strong>例子</strong>：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p = <span class="built_in">malloc</span>(<span class="number">100</span> * <span class="keyword">sizeof</span>(<span class="type">int</span>)); <span class="comment">// 在堆上申请100个int的空间</span></span><br><span class="line"><span class="built_in">free</span>(p); <span class="comment">// 用完必须手动释放，否则会内存泄漏！</span></span><br></pre></td></tr></table></figure></li>
<li><strong>缺点</strong>：忘记释放会导致内存泄漏，管理不当可能产生碎片。</li>
</ul>
<h4 id="关键区别总结"><a href="#关键区别总结" class="headerlink" title="关键区别总结"></a><strong>关键区别总结</strong></h4><table>
<thead>
<tr>
<th>特性</th>
<th>栈（Stack）</th>
<th>堆（Heap）</th>
</tr>
</thead>
<tbody><tr>
<td><strong>管理方式</strong></td>
<td>自动分配&#x2F;释放</td>
<td>手动申请&#x2F;释放</td>
</tr>
<tr>
<td><strong>速度</strong></td>
<td>快（连续内存）</td>
<td>慢（需动态分配）</td>
</tr>
<tr>
<td><strong>大小</strong></td>
<td>较小（默认几MB）</td>
<td>较大（取决于系统内存）</td>
</tr>
<tr>
<td><strong>用途</strong></td>
<td>局部变量、函数调用</td>
<td>动态数据（如对象、数组）</td>
</tr>
<tr>
<td><strong>风险</strong></td>
<td>栈溢出（递归太深）</td>
<td>内存泄漏、碎片化</td>
</tr>
</tbody></table>
<h4 id="通俗比喻"><a href="#通俗比喻" class="headerlink" title="通俗比喻"></a><strong>通俗比喻</strong></h4><ul>
<li><strong>栈</strong>：像快餐店的取餐盘——随取随用，吃完立刻收走，但容量有限。</li>
<li><strong>堆</strong>：像租仓库——自己申请空间，随时存放杂物，但忘记退租会白花钱（内存泄漏）。</li>
</ul>
<h4 id="名称来源"><a href="#名称来源" class="headerlink" title="名称来源"></a>名称来源</h4><ul>
<li>栈（Stack）：名字来自“堆叠”，强调自动、顺序的特性（像叠盘子）。</li>
<li>堆（Heap）：名字来自“杂乱堆积”，强调动态、不连续的特性（像杂物堆），<strong>与优先队列无关</strong></li>
</ul>
<h3 id="RAII-Resource-Acquisition-Is-Initialization"><a href="#RAII-Resource-Acquisition-Is-Initialization" class="headerlink" title="RAII&#x2F;Resource Acquisition Is Initialization"></a>RAII&#x2F;Resource Acquisition Is Initialization</h3><p>RAII：资源获取即初始化，资源释放即销毁，即在构造函数中申请资源，在析构函数中释放资源，主要用于管理堆上的资源。<br>通俗解释：</p>
<ul>
<li>获取即管理：在构造函数（对象创建时）申请资源（如内存、文件、锁等）。</li>
<li>离开作用域自动释放：当对象离开作用域（如函数结束、代码块退出）时，析构函数自动调用，释放资源。</li>
</ul>
<hr>
<p>为什么用 RAII？</p>
<ul>
<li>防泄漏：资源自动释放，避免忘记 fclose&#x2F;free。</li>
<li>防异常崩溃：即使代码抛出异常，析构函数仍会调用。</li>
<li>代码简洁：无需手动管理资源生命周期。</li>
</ul>
<h3 id="对象的拷贝和移动"><a href="#对象的拷贝和移动" class="headerlink" title="对象的拷贝和移动"></a>对象的拷贝和移动</h3><p>C++会默认提供对象的拷贝构造和移动构造函数，但是其默认行为可能不是你想要的，需要注意其可能产生问题：</p>
<ul>
<li><ol>
<li>默认拷贝构造函数的问题</li>
</ol>
<ul>
<li>默认拷贝构造函数会逐个复制类的成员变量（浅拷贝），但如果类管理动态资源（如堆内存、文件句柄、锁等），会导致：</li>
<li>重复释放：两个对象指向同一块内存，析构时会被释放两次（崩溃）。</li>
<li>数据共享：修改一个对象会影响另一个对象（非预期行为）。</li>
</ul>
</li>
<li><ol start="2">
<li>默认移动构造函数的问题</li>
</ol>
<ul>
<li>默认移动构造函数会逐个移动类的成员变量（对指针等简单类型直接复制值），但如果类管理资源：</li>
<li>资源泄漏：移动后，原对象仍持有资源指针（可能导致析构时意外释放）。</li>
<li>悬空指针：移动后的原对象处于无效状态，但可能被误用。</li>
</ul>
</li>
</ul>
<h3 id="对象的特殊成员函数"><a href="#对象的特殊成员函数" class="headerlink" title="对象的特殊成员函数"></a>对象的特殊成员函数</h3><h3 id="C-对象的特殊成员函数总结表"><a href="#C-对象的特殊成员函数总结表" class="headerlink" title="C++ 对象的特殊成员函数总结表"></a><strong>C++ 对象的特殊成员函数总结表</strong></h3><p>以下是 C++ 中类（<code>class</code>&#x2F;<code>struct</code>）的 <strong>特殊成员函数（Special Member Functions）</strong>，它们在特定条件下由编译器自动生成，但也可以手动定义或禁用。  </p>
<table>
<thead>
<tr>
<th>特殊成员函数</th>
<th>自动生成条件（默认）</th>
<th>用途说明</th>
<th>常见自定义场景</th>
</tr>
</thead>
<tbody><tr>
<td><strong>默认构造函数</strong><br><code>ClassName()</code></td>
<td>如果<strong>没有定义任何构造函数</strong></td>
<td>初始化对象（无参构造）</td>
<td>需要自定义初始化逻辑（如资源分配）</td>
</tr>
<tr>
<td><strong>析构函数</strong><br><code>~ClassName()</code></td>
<td>总是自动生成</td>
<td>对象销毁时自动调用，用于释放资源</td>
<td>管理动态内存、文件、锁等资源时需手动定义</td>
</tr>
<tr>
<td><strong>拷贝构造函数</strong><br><code>ClassName(const ClassName&amp;)</code></td>
<td>如果<strong>没有定义移动操作和拷贝赋值</strong></td>
<td>用同类型对象初始化新对象（深拷贝&#x2F;浅拷贝）</td>
<td>管理资源时需要<strong>深拷贝</strong>（如 <code>std::string</code>）</td>
</tr>
<tr>
<td><strong>拷贝赋值运算符</strong><br><code>ClassName&amp; operator=(const ClassName&amp;)</code></td>
<td>如果<strong>没有定义移动操作和拷贝构造</strong></td>
<td>用同类型对象赋值给已存在对象</td>
<td>同拷贝构造函数，需处理自我赋值和资源释放</td>
</tr>
<tr>
<td><strong>移动构造函数</strong><br><code>ClassName(ClassName&amp;&amp;)</code></td>
<td>如果<strong>没有定义拷贝操作、移动赋值和析构函数</strong></td>
<td>用右值（临时对象）初始化新对象（高效转移资源）</td>
<td>管理资源时需<strong>转移所有权</strong>（如 <code>std::unique_ptr</code>）</td>
</tr>
<tr>
<td><strong>移动赋值运算符</strong><br><code>ClassName&amp; operator=(ClassName&amp;&amp;)</code></td>
<td>如果<strong>没有定义拷贝操作、移动构造和析构函数</strong></td>
<td>用右值（临时对象）赋值给已存在对象</td>
<td>同移动构造函数，需处理自我赋值</td>
</tr>
</tbody></table>
<p> <strong>示例代码</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Resource</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Resource</span>() = <span class="keyword">default</span>;                          <span class="comment">// 默认构造函数</span></span><br><span class="line">    ~<span class="built_in">Resource</span>() &#123; <span class="comment">/* 释放资源 */</span> &#125;                 <span class="comment">// 析构函数</span></span><br><span class="line">    <span class="built_in">Resource</span>(<span class="type">const</span> Resource&amp;) &#123; <span class="comment">/* 深拷贝逻辑 */</span> &#125;  <span class="comment">// 拷贝构造</span></span><br><span class="line">    Resource&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Resource&amp;) &#123; <span class="comment">/* 拷贝赋值逻辑 */</span> <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">    <span class="built_in">Resource</span>(Resource&amp;&amp;) <span class="keyword">noexcept</span> &#123; <span class="comment">/* 移动资源 */</span> &#125; <span class="comment">// 移动构造</span></span><br><span class="line">    Resource&amp; <span class="keyword">operator</span>=(Resource&amp;&amp;) <span class="keyword">noexcept</span> &#123; <span class="comment">/* 移动赋值逻辑 */</span> <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="一句话总结"><a href="#一句话总结" class="headerlink" title="一句话总结"></a><strong>一句话总结</strong></h3><ul>
<li><strong>默认生成的函数可能不安全</strong>（尤其是管理资源时）。</li>
<li><strong>规则口诀</strong>：  <ul>
<li>定义拷贝 → 无移动；定义移动 → 无拷贝；定义析构 → 无移动（但保留拷贝）。  </li>
<li>用 <code>= default</code> 或 <code>= delete</code> 显式控制行为。</li>
</ul>
</li>
</ul>
<h3 id="三法则"><a href="#三法则" class="headerlink" title="三法则"></a>三法则</h3><p>如果一个类需要手动定义以下 任意一个 特殊成员函数，那么通常需要同时定义 全部三个：</p>
<ul>
<li>析构函数（释放资源）</li>
<li>拷贝构造函数（深拷贝资源）</li>
<li>拷贝赋值运算符（处理赋值时的资源释放和拷贝）</li>
</ul>
<h1 id="3-移动语义与右值引用"><a href="#3-移动语义与右值引用" class="headerlink" title="3. 移动语义与右值引用"></a>3. 移动语义与右值引用</h1><h2 id="3-移动语义与右值引用-1"><a href="#3-移动语义与右值引用-1" class="headerlink" title="3. 移动语义与右值引用"></a>3. 移动语义与右值引用</h2><h3 id="C-的值类别-Value-Categories"><a href="#C-的值类别-Value-Categories" class="headerlink" title="C++ 的值类别 (Value Categories)"></a>C++ 的值类别 (Value Categories)</h3><p>在 C++ 中，每个表达式都有一个值类别，它决定了表达式如何与内存交互以及可以被如何使用。C++11 引入了新的值类别系统，取代了传统的左值&#x2F;右值分类。</p>
<p>C++ 中的值类别分为两大类，共五种：</p>
<h4 id="1-左值-lvalue"><a href="#1-左值-lvalue" class="headerlink" title="1. 左值 (lvalue)"></a>1. 左值 (lvalue)</h4><ul>
<li>可以取地址的表达式</li>
<li>有持久性（生命周期超出表达式）</li>
<li>可以出现在赋值运算符的左侧</li>
<li>示例：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">10</span>;  <span class="comment">// x 是左值</span></span><br><span class="line"><span class="type">int</span>&amp; ref = x; <span class="comment">// ref 是左值引用</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="2-纯右值-prvalue-pure-rvalue"><a href="#2-纯右值-prvalue-pure-rvalue" class="headerlink" title="2. 纯右值 (prvalue, pure rvalue)"></a>2. 纯右值 (prvalue, pure rvalue)</h4><ul>
<li>临时对象或字面量</li>
<li>没有持久性（通常在表达式结束时被销毁）</li>
<li>不能出现在赋值运算符的左侧</li>
<li>不能取地址</li>
<li>示例：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">42</span>          <span class="comment">// 字面量是纯右值</span></span><br><span class="line">x + <span class="number">5</span>       <span class="comment">// 表达式结果是纯右值</span></span><br><span class="line">std::<span class="built_in">string</span>(<span class="string">&quot;hello&quot;</span>) <span class="comment">// 临时对象是纯右值</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="3-将亡值-xvalue-expiring-value"><a href="#3-将亡值-xvalue-expiring-value" class="headerlink" title="3. 将亡值 (xvalue, expiring value)"></a>3. 将亡值 (xvalue, expiring value)</h4><ul>
<li>即将被移动的对象</li>
<li>可以被资源”窃取”</li>
<li>示例：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="built_in">move</span>(x) <span class="comment">// std::move 返回将亡值</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="复合类别"><a href="#复合类别" class="headerlink" title="复合类别"></a>复合类别</h4><h5 id="广义左值-glvalue-generalized-lvalue"><a href="#广义左值-glvalue-generalized-lvalue" class="headerlink" title="广义左值 (glvalue, generalized lvalue)"></a>广义左值 (glvalue, generalized lvalue)</h5><ul>
<li>包括左值和将亡值</li>
<li>有标识（可以确定对象身份）</li>
</ul>
<h5 id="右值-rvalue"><a href="#右值-rvalue" class="headerlink" title="右值 (rvalue)"></a>右值 (rvalue)</h5><ul>
<li>包括纯右值和将亡值</li>
<li>可以被移动</li>
</ul>
<p>关系图</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">        expression</span><br><span class="line">        /        \</span><br><span class="line">     glvalue    rvalue</span><br><span class="line">    /      \    /    \</span><br><span class="line">lvalue     xvalue    prvalue</span><br></pre></td></tr></table></figure>
<p><img src="/../images/1746961095204-image.png" alt="alt text"></p>
<h4 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h4><ol>
<li><p><strong>引用绑定规则</strong>：</p>
<ul>
<li>左值引用 (<code>T&amp;</code>) 只能绑定到左值</li>
<li>常量左值引用 (<code>const T&amp;</code>) 可以绑定到所有值类别</li>
<li>右值引用 (<code>T&amp;&amp;</code>) 只能绑定到右值</li>
</ul>
</li>
<li><p><strong>移动语义</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(std::string&amp;&amp; str)</span></span>; <span class="comment">// 只接受右值</span></span><br><span class="line"></span><br><span class="line">std::string s = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="built_in">process</span>(std::<span class="built_in">move</span>(s)); <span class="comment">// 将左值转为右值</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>完美转发</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">wrapper</span><span class="params">(T&amp;&amp; arg)</span> </span>&#123; <span class="comment">// 通用引用</span></span><br><span class="line">    <span class="built_in">process</span>(std::forward&lt;T&gt;(arg)); <span class="comment">// 保持值类别</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>理解值类别对于编写高效的现代 C++ 代码至关重要，特别是在涉及移动语义和完美转发时。</p>
<h3 id="移动的实现和意义"><a href="#移动的实现和意义" class="headerlink" title="移动的实现和意义"></a>移动的实现和意义</h3><ul>
<li>允许资源的传递</li>
<li>允许返回大对象和容器<ul>
<li>一般同时使用异常来表示错误<br>其意义在于：</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string str = <span class="built_in">string</span>(<span class="string">&quot;hello&quot;</span>) + name + <span class="string">&quot;!&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>如果没有移动语义的话，上述代码会生成临时对象，然后进行字符串拼接，最后再销毁临时对象。</p>
<h3 id="移动和noexcept"><a href="#移动和noexcept" class="headerlink" title="移动和noexcept"></a>移动和noexcept</h3><p>下列成员函数不允许抛出异常，否则编译器会报错。</p>
<ul>
<li>析构</li>
<li><strong>移动构造函数</strong></li>
<li><strong>移动赋值运算符</strong></li>
<li>交换函数</li>
</ul>
<h3 id="对象的生命期"><a href="#对象的生命期" class="headerlink" title="对象的生命期"></a>对象的生命期</h3><p><img src="/../images/1746962209368-image.png" alt="alt text"></p>
<h3 id="转发引用"><a href="#转发引用" class="headerlink" title="转发引用"></a>转发引用</h3><p>转发引用是C++11引入的一种特殊引用类型，也称为”万能引用”(Universal Reference)。它能够根据传入的参数类型自动推导为左值引用或右值引用。<br>转发引用主要用于完美转发(perfect forwarding)，即保持参数原始值类别(左值&#x2F;右值)传递到下层函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">wrapper</span><span class="params">(T&amp;&amp; arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用std::forward保持arg的原始值类别</span></span><br><span class="line">    <span class="built_in">some_function</span>(std::forward&lt;T&gt;(arg));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="五法则"><a href="#五法则" class="headerlink" title="五法则"></a>五法则</h3><p>C++的五法则是对三法则（Rule of Three）的扩展，适用于现代C++（C++11及以后版本）。它指出如果一个类需要显式定义以下任何一个特殊成员函数，那么它通常需要显式定义所有这五个函数：</p>
<ol>
<li>析构函数（Destructor）</li>
<li>拷贝构造函数（Copy constructor）</li>
<li>拷贝赋值运算符（Copy assignment operator）</li>
<li>移动构造函数（Move constructor）</li>
<li>移动赋值运算符（Move assignment operator）</li>
</ol>
<h4 id="五法则的背景"><a href="#五法则的背景" class="headerlink" title="五法则的背景"></a>五法则的背景</h4><p>在C++11引入移动语义之前，只有三法则（析构函数、拷贝构造函数、拷贝赋值运算符）。随着移动语义的加入，管理资源的类现在也需要考虑移动操作。</p>
<h4 id="为什么需要五法则"><a href="#为什么需要五法则" class="headerlink" title="为什么需要五法则"></a>为什么需要五法则</h4><p>当一个类管理资源（如动态内存、文件句柄等）时，编译器生成的默认特殊成员函数可能无法正确管理这些资源。如果你定义了其中任何一个函数，通常意味着你需要自定义资源管理，因此需要定义所有五个函数以确保资源在所有情况下都被正确处理。</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ResourceHolder</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 1. 构造函数</span></span><br><span class="line">    <span class="built_in">ResourceHolder</span>(<span class="type">size_t</span> size) : <span class="built_in">data</span>(<span class="keyword">new</span> <span class="type">int</span>[size]), <span class="built_in">size</span>(size) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 析构函数</span></span><br><span class="line">    ~<span class="built_in">ResourceHolder</span>() &#123; <span class="keyword">delete</span>[] data; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 拷贝构造函数</span></span><br><span class="line">    <span class="built_in">ResourceHolder</span>(<span class="type">const</span> ResourceHolder&amp; other) </span><br><span class="line">        : <span class="built_in">data</span>(<span class="keyword">new</span> <span class="type">int</span>[other.size]), <span class="built_in">size</span>(other.size) &#123;</span><br><span class="line">        std::<span class="built_in">copy</span>(other.data, other.data + other.size, data);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4. 拷贝赋值运算符</span></span><br><span class="line">    ResourceHolder&amp; <span class="keyword">operator</span>=(<span class="type">const</span> ResourceHolder&amp; other) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other) &#123;</span><br><span class="line">            <span class="keyword">delete</span>[] data;</span><br><span class="line">            data = <span class="keyword">new</span> <span class="type">int</span>[other.size];</span><br><span class="line">            size = other.size;</span><br><span class="line">            std::<span class="built_in">copy</span>(other.data, other.data + other.size, data);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 5. 移动构造函数</span></span><br><span class="line">    <span class="built_in">ResourceHolder</span>(ResourceHolder&amp;&amp; other) <span class="keyword">noexcept</span> </span><br><span class="line">        : <span class="built_in">data</span>(other.data), <span class="built_in">size</span>(other.size) &#123;</span><br><span class="line">        other.data = <span class="literal">nullptr</span>;</span><br><span class="line">        other.size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 6. 移动赋值运算符</span></span><br><span class="line">    ResourceHolder&amp; <span class="keyword">operator</span>=(ResourceHolder&amp;&amp; other) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other) &#123;</span><br><span class="line">            <span class="keyword">delete</span>[] data;</span><br><span class="line">            data = other.data;</span><br><span class="line">            size = other.size;</span><br><span class="line">            other.data = <span class="literal">nullptr</span>;</span><br><span class="line">            other.size = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span>* data;</span><br><span class="line">    <span class="type">size_t</span> size;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="例外情况"><a href="#例外情况" class="headerlink" title="例外情况"></a>例外情况</h4><p>在某些情况下，你可能不需要全部五个函数：</p>
<ul>
<li>如果类不需要移动语义，三法则仍然适用</li>
<li>如果类是不可拷贝的（如单例模式），你可能只需要析构函数和删除拷贝操作</li>
</ul>
<h4 id="现代C-的替代方案"><a href="#现代C-的替代方案" class="headerlink" title="现代C++的替代方案"></a>现代C++的替代方案</h4><p>使用RAII（资源获取即初始化）原则和智能指针（如<code>std::unique_ptr</code>、<code>std::shared_ptr</code>）可以避免手动实现五法则，因为智能指针已经正确处理了这些操作。</p>
<h2 id="小节自测"><a href="#小节自测" class="headerlink" title="小节自测"></a>小节自测</h2><p><img src="/../images/1746962538602-image.png" alt="alt text"><br>在C++中，左值（lvalue）是指那些可以出现在赋值语句左侧的表达式，它们通常代表一个具有明确内存位置的对象。右值（rvalue）则是临时对象或字面量，不能出现在赋值语句的左侧。<br>让我们逐一分析选项：</p>
<ul>
<li><p><strong>A. ++x</strong><br><code>++x</code> 是前置递增操作，它先增加 <code>x</code> 的值，然后返回 <code>x</code> 本身（作为左值）。因此，<code>++x</code> 是一个左值。</p>
</li>
<li><p><strong>B. x++</strong><br><code>x++</code> 是后置递增操作，它先返回 <code>x</code> 的当前值（作为临时对象），然后再增加 <code>x</code> 的值。因此，<code>x++</code> 是一个右值，而不是左值。</p>
</li>
<li><p><strong>C. “hello world”</strong><br>字符串字面量 <code>&quot;hello world&quot;</code> 是一个左值，因为它是一个具有确定内存位置的字符数组（尽管不可修改）。</p>
</li>
<li><p><strong>D. 函数名字</strong><br>函数名字是一个左值，因为它代表一个具体的函数实体，具有明确的内存地址。</p>
</li>
</ul>
<p>因此，<strong>B. x++</strong> 是唯一不是左值的选项。</p>
<p><img src="/../images/1746962827885-image.png" alt="alt text"><br>在C++中，<code>&amp;&amp;</code> 表示右值引用（rvalue reference），它是C++11引入的重要特性，主要用于实现移动语义和完美转发。我们逐一分析选项：</p>
<ul>
<li><p><strong>A. 右值引用通常使用类型名称加 <code>&amp;&amp;</code> 的方式表示。</strong><br>这是正确的。例如，<code>int&amp;&amp;</code> 表示一个右值引用，绑定到临时对象或可移动的对象。</p>
</li>
<li><p><strong>B. <code>T&amp;&amp;</code> 这样的类型代表一个右值引用。</strong><br>这<strong>不完全正确</strong>，因为在模板或 <code>auto&amp;&amp;</code> 推导时，<code>T&amp;&amp;</code> 可能是右值引用，但也可能是<strong>转发引用（universal reference）</strong>，具体取决于上下文。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(T&amp;&amp; arg)</span></span>;  <span class="comment">// arg 可能是右值引用或左值引用（转发引用）</span></span><br></pre></td></tr></table></figure>
<p>只有在明确类型（如 <code>int&amp;&amp;</code>）时，<code>&amp;&amp;</code> 才一定是右值引用。</p>
</li>
<li><p><strong>C. 函数直接返回一个对象可以匹配相应的右值引用。</strong><br>这是正确的。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::string <span class="title">getString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>; &#125;</span><br><span class="line">std::string&amp;&amp; s = <span class="built_in">getString</span>();  <span class="comment">// 正确：getString() 返回临时对象（右值）</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>D. 函数要返回对象，通常不应该使用 <code>T&amp;&amp;</code> 这样的返回值。</strong><br>这是正确的。返回 <code>T&amp;&amp;</code> 通常用于特殊场景（如 <code>std::move</code> 或 <code>std::forward</code>），一般函数直接返回对象时，应返回值（<code>T</code>）或引用（<code>T&amp;</code>&#x2F;<code>const T&amp;</code>），而非 <code>T&amp;&amp;</code>。<br><strong>B</strong> 的描述不严谨，因为 <code>T&amp;&amp;</code> 不一定是右值引用（可能是转发引用）。因此，<strong>B 是不正确的选项</strong>。</p>
</li>
</ul>
<p><img src="/../images/1746962906840-image.png" alt="alt text"><br>B 的说法是错误的，因为定义其中一个特殊成员函数并不会强制要求定义其他函数，也不会导致编译错误。五法则是一个编程规范，而非语言强制规则。</p>
<h1 id="4-智能指针"><a href="#4-智能指针" class="headerlink" title="4. 智能指针"></a>4. 智能指针</h1><h2 id="4-智能指针-1"><a href="#4-智能指针-1" class="headerlink" title="4. 智能指针"></a>4. 智能指针</h2><ul>
<li>auto_ptr和unique_ptr</li>
<li>shared_ptr和weak_ptr</li>
<li>make_shared和make_unique 两个帮助函数</li>
</ul>
<p>智能指针是C++中的一种对象，它像普通指针一样工作，但能自动管理内存，防止内存泄漏。简单来说，它们是”聪明”的指针，能自己清理内存。</p>
<h3 id="主要类型"><a href="#主要类型" class="headerlink" title="主要类型"></a>主要类型</h3><ol>
<li><p><strong>unique_ptr</strong> - 唯一指针</p>
<ul>
<li>同一时间只能有一个unique_ptr指向某个对象</li>
<li>当指针被销毁时，它指向的对象也会自动删除</li>
<li>不能复制，但可以移动</li>
</ul>
</li>
<li><p><strong>shared_ptr</strong> - 共享指针</p>
<ul>
<li>多个shared_ptr可以指向同一个对象</li>
<li>内部有引用计数，记录有多少指针指向该对象</li>
<li>当最后一个指针销毁时，对象才会被删除</li>
</ul>
</li>
<li><p><strong>weak_ptr</strong> - 弱指针</p>
<ul>
<li>配合shared_ptr使用，不增加引用计数</li>
<li>用于解决shared_ptr的循环引用问题</li>
</ul>
</li>
</ol>
<h3 id="为什么用智能指针？"><a href="#为什么用智能指针？" class="headerlink" title="为什么用智能指针？"></a>为什么用智能指针？</h3><ul>
<li>自动释放内存，避免忘记delete</li>
<li>防止内存泄漏</li>
<li>更安全的代码，减少悬空指针问题</li>
<li>让内存管理更简单</li>
</ul>
<h3 id="简单例子"><a href="#简单例子" class="headerlink" title="简单例子"></a>简单例子</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// unique_ptr示例</span></span><br><span class="line"><span class="function">std::unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">10</span>))</span></span>; <span class="comment">// 创建</span></span><br><span class="line">*p1 = <span class="number">20</span>; <span class="comment">// 使用</span></span><br><span class="line"><span class="comment">// 不需要手动delete，离开作用域自动释放</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// shared_ptr示例</span></span><br><span class="line">std::shared_ptr&lt;<span class="type">int</span>&gt; p2 = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">30</span>);</span><br><span class="line"><span class="keyword">auto</span> p3 = p2; <span class="comment">// 现在p2和p3共享同一个对象</span></span><br></pre></td></tr></table></figure>

<p>智能指针让C++内存管理变得更简单、更安全！</p>
<h3 id="使用建议"><a href="#使用建议" class="headerlink" title="使用建议"></a>使用建议</h3><p><img src="/../images/1747049713743-image.png" alt="alt text"></p>
<h2 id="小节自测-1"><a href="#小节自测-1" class="headerlink" title="小节自测"></a>小节自测</h2><p><img src="/../images/1747049838519-image.png" alt="alt text"><br><img src="/../images/1747049854419-image.png" alt="alt text"><br>B. 错误：赋值时不需要显式使用 std::move，因为函数返回的 unique_ptr 已经是右值，会自动移动。显式使用 std::move 是多余的（尽管语法上不会报错）。</p>
<h1 id="5-容器和类容器"><a href="#5-容器和类容器" class="headerlink" title="5. 容器和类容器"></a>5. 容器和类容器</h1><h2 id="5-1-string；序列容器"><a href="#5-1-string；序列容器" class="headerlink" title="5.1 string；序列容器"></a>5.1 string；序列容器</h2><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>string类是C++标准库中的字符串类，用于处理字符串。它提供了很多功能，如字符串拼接、查找、替换、大小写转换、比较、截取、复制等等。<strong>String不是容器</strong>。</p>
<ul>
<li>支持字符串的拼接操作，如+，+&#x3D;</li>
<li>支持字符串的查找<code>find()</code>,<code>rfind()</code></li>
<li>size()的复杂度是O(1)而不是O(n)</li>
<li>在堆上分配空间</li>
</ul>
<h3 id="array"><a href="#array" class="headerlink" title="array"></a>array</h3><p>C数组的更好的替代品，C++11引入了array模板，用于处理数组。</p>
<ul>
<li>和C数组一样，在栈上分配空间，性能方面没有差异</li>
<li>需要在编译时指定数组的大小，不能在运行时动态改变大小</li>
</ul>
<h3 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h3><p>vector是一个动态数组，它提供了一些额外的功能，如插入、删除、查找、排序等。</p>
<h3 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h3><p>双端队列，和python的deque一样</p>
<ul>
<li>初始化：&#96;deque<int> dq;</li>
</ul>
<h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><p>list是一个双向链表，它提供一些额外的功能，如插入、删除、查找、排序等。</p>
<h3 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h3><p>queue是一个先进先出（FIFO）的容器，它提供了一些额外的功能，如插入、删除、查找、排序等。</p>
<h3 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h3><p>stack是一个先进后出（LIFO）的容器，它提供了一些额外的功能，如插入、删除、查找、排序等。</p>
<h2 id="5-2-关联容器和无序关联容器"><a href="#5-2-关联容器和无序关联容器" class="headerlink" title="5.2 关联容器和无序关联容器"></a>5.2 关联容器和无序关联容器</h2><p>C++ 标准库提供了以下几种关联容器和无序关联容器：</p>
<h3 id="关联容器-有序容器"><a href="#关联容器-有序容器" class="headerlink" title="关联容器 (有序容器)"></a>关联容器 (有序容器)</h3><p>这些容器基于红黑树实现，元素按键的排序顺序存储</p>
<ol>
<li><p><strong>set</strong> - 唯一键的集合，按照键排序</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::set&lt;Key&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>multiset</strong> - 键集合，允许重复键，按照键排序</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::multiset&lt;Key&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>map</strong> - 键值对集合，键唯一，按照键排序</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::map&lt;Key, T&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>multimap</strong> - 键值对集合，允许重复键，按照键排序</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::multimap&lt;Key, T&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="无序关联容器-哈希容器"><a href="#无序关联容器-哈希容器" class="headerlink" title="无序关联容器 (哈希容器)"></a>无序关联容器 (哈希容器)</h3><p>这些容器基于哈希表实现，元素不按特定顺序存储</p>
<ol>
<li><p><strong>unordered_set</strong> - 唯一键的集合，基于哈希</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::unordered_set&lt;Key&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>unordered_multiset</strong> - 键集合，允许重复键，基于哈希</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::unordered_multiset&lt;Key&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>unordered_map</strong> - 键值对集合，键唯一，基于哈希</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::unordered_map&lt;Key, T&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>unordered_multimap</strong> - 键值对集合，允许重复键，基于哈希</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::unordered_multimap&lt;Key, T&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
<table>
<thead>
<tr>
<th>特性</th>
<th>关联容器</th>
<th>无序关联容器</th>
</tr>
</thead>
<tbody><tr>
<td>实现方式</td>
<td>红黑树</td>
<td>哈希表</td>
</tr>
<tr>
<td>元素顺序</td>
<td>按键排序</td>
<td>无特定顺序</td>
</tr>
<tr>
<td>查找复杂度</td>
<td>O(log n)</td>
<td>平均O(1)，最坏O(n)</td>
</tr>
<tr>
<td>需要</td>
<td>比较运算符(&lt;)</td>
<td>哈希函数和相等运算符</td>
</tr>
<tr>
<td>内存使用</td>
<td>通常较少</td>
<td>通常较多</td>
</tr>
</tbody></table>
<p>选择哪种容器取决于具体需求：如果需要有序访问，使用关联容器；如果需要更快的查找速度且不关心顺序，使用无序关联容器。</p>
<h2 id="小节自测-2"><a href="#小节自测-2" class="headerlink" title="小节自测"></a>小节自测</h2><p><img src="/../images/1747481889476-image.png" alt="alt text"><br>这道题目考察的是STL（Standard Template Library）中各种设施的特性，特别是关于容器和函数对象的性能比较。让我们逐一分析每个选项：<br><strong>A. 容器的拷贝代价比较大，但支持现代C++的移动语义后可以避免拷贝的代价。</strong>  </p>
<ul>
<li>这是正确的。STL容器的拷贝操作通常涉及深拷贝，代价较高。但现代C++引入了移动语义（如移动构造函数和移动赋值运算符），可以通过转移资源所有权来避免拷贝，提高性能。</li>
</ul>
<p><strong>B. 如果预先知道vector的最大大小，可以使用reserve来避免不必要的重分配带来的性能代价。</strong>  </p>
<ul>
<li>这是正确的。<code>vector</code>在动态扩容时会重新分配内存并拷贝元素，这会带来性能开销。使用<code>reserve</code>可以预先分配足够的内存，避免多次重分配。</li>
</ul>
<p><strong>C. 函数对象的调用性能比函数指针差，因为函数对象的调用有对象构造和析构的负担。</strong>  </p>
<ul>
<li>这是错误的。函数对象（仿函数）通常是轻量级的，其调用性能通常优于函数指针，因为函数对象的调用是静态解析（编译时确定），而函数指针是动态解析（运行时确定）。此外，现代编译器可以优化掉函数对象的构造和析构开销。</li>
</ul>
<p><strong>D. 函数对象的调用性能比函数指针好，因为函数对象调用时是静态解析，函数指针调用时是动态解析。</strong>  </p>
<ul>
<li>这是正确的。函数对象的调用在编译时就能确定，因此性能更好；而函数指针需要在运行时解析，性能稍差。</li>
</ul>
<p>题目问的是“哪个是错误的”，因此正确答案是 <strong>C</strong>。</p>
<h1 id="6-迭代器和循环"><a href="#6-迭代器和循环" class="headerlink" title="6. 迭代器和循环"></a>6. 迭代器和循环</h1><h2 id="6-迭代器和循环-1"><a href="#6-迭代器和循环-1" class="headerlink" title="6. 迭代器和循环"></a>6. 迭代器和循环</h2><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><ul>
<li>是一个概念，而不是类型</li>
<li>从一个断点触发，下一步，下一步，下一步，直到结束</li>
<li>用来遍历容器中的元素<ul>
<li>遍历一个字符串中的字符</li>
<li>遍历一个map中的键值对</li>
<li>遍历一个目录里面的所有文件</li>
<li>….</li>
</ul>
</li>
</ul>
<p><img src="/../images/1747482482431-image.png" alt="alt text"></p>
<p>从您的图中可以看出迭代器概念的层级关系：</p>
<ul>
<li>最基础的是InputIterator（支持用*读取）</li>
<li>ForwardIterator继承自InputIterator</li>
<li>BidirectionalIterator继承自ForwardIterator</li>
<li>RandomAccessIterator继承自BidirectionalIterator</li>
<li>OutputIterator是独立的（支持用*输出）</li>
</ul>
<p>迭代器是C++中用于访问容器元素的一种抽象机制，它提供了统一的访问容器元素的方式。以下是您图中提到的各种迭代器概念及其关系：</p>
<ol>
<li><p><strong>InputIterator（输入迭代器）</strong></p>
<ul>
<li>最基本的迭代器类型</li>
<li>只能单向向前移动（++）</li>
<li>只能读取元素（用*读取）</li>
<li>只能单遍遍历（不能多次遍历同一序列）</li>
<li>示例：<code>istream_iterator</code></li>
</ul>
</li>
<li><p><strong>OutputIterator（输出迭代器）</strong></p>
<ul>
<li>只能单向向前移动（++）</li>
<li>只能写入元素（用*输出）</li>
<li>只能单遍遍历</li>
<li>示例：<code>ostream_iterator</code></li>
</ul>
</li>
</ol>
<h2 id="更高级的迭代器概念"><a href="#更高级的迭代器概念" class="headerlink" title="更高级的迭代器概念"></a>更高级的迭代器概念</h2><ol start="3">
<li><p><strong>ForwardIterator（前向迭代器）</strong></p>
<ul>
<li>继承自InputIterator</li>
<li>可以多次遍历同一序列</li>
<li>支持读写操作（如果可变）</li>
<li>示例：<code>std::forward_list</code>的迭代器</li>
</ul>
</li>
<li><p><strong>BidirectionalIterator（双向迭代器）</strong></p>
<ul>
<li>继承自ForwardIterator</li>
<li>可以向前（++）和向后（–）移动</li>
<li>示例：<code>std::list</code>的迭代器</li>
</ul>
</li>
<li><p><strong>RandomAccessIterator（随机访问迭代器）</strong></p>
<ul>
<li>继承自BidirectionalIterator</li>
<li>支持随机访问（[]操作符）</li>
<li>支持算术运算（+,-,+&#x3D;,-&#x3D;）</li>
<li>支持迭代器比较（&lt;,&gt;,&lt;&#x3D;,&gt;&#x3D;）</li>
<li>示例：<code>std::vector</code>和<code>std::array</code>的迭代器</li>
</ul>
</li>
</ol>
<p>理解这些迭代器概念对于有效使用STL算法非常重要，因为不同的算法对迭代器有不同的要求。例如：</p>
<ul>
<li><code>std::sort</code>需要RandomAccessIterator</li>
<li><code>std::reverse</code>需要BidirectionalIterator</li>
<li><code>std::find</code>只需要InputIterator</li>
</ul>
<h1 id="7-对象返回和异常"><a href="#7-对象返回和异常" class="headerlink" title="7. 对象返回和异常"></a>7. 对象返回和异常</h1><h2 id="7-1-返回值优化和对象返回"><a href="#7-1-返回值优化和对象返回" class="headerlink" title="7.1 返回值优化和对象返回"></a>7.1 返回值优化和对象返回</h2><p>C++中的返回值优化(RVO)和对象返回</p>
<p>返回值优化(Return Value Optimization, RVO)是C++编译器的一项重要优化技术，它可以避免在函数返回对象时产生不必要的拷贝或移动操作，从而提高程序性能。</p>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><h4 id="什么是返回值优化"><a href="#什么是返回值优化" class="headerlink" title="什么是返回值优化"></a>什么是返回值优化</h4><p>返回值优化是指编译器在某些情况下可以省略函数返回对象时的拷贝或移动构造操作，直接在调用者的栈帧上构造返回对象。</p>
<h3 id="为什么需要返回值优化"><a href="#为什么需要返回值优化" class="headerlink" title="为什么需要返回值优化"></a>为什么需要返回值优化</h3><p>在没有优化的情况下，函数返回对象通常涉及以下步骤：</p>
<ol>
<li>在函数内部构造局部对象</li>
<li>通过拷贝或移动构造函数创建返回的临时对象</li>
<li>销毁函数内的局部对象</li>
<li>将临时对象拷贝或移动到调用处的目标对象</li>
</ol>
<p>RVO可以省略中间步骤，直接在目标位置构造对象。</p>
<h3 id="返回值优化的类型"><a href="#返回值优化的类型" class="headerlink" title="返回值优化的类型"></a>返回值优化的类型</h3><h4 id="1-具名返回值优化-NRVO-Named-Return-Value-Optimization"><a href="#1-具名返回值优化-NRVO-Named-Return-Value-Optimization" class="headerlink" title="1. 具名返回值优化(NRVO, Named Return Value Optimization)"></a>1. 具名返回值优化(NRVO, Named Return Value Optimization)</h4><p>当函数返回一个具名的局部对象时，编译器可能应用的优化。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Widget <span class="title">makeWidget</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Widget w;  <span class="comment">// 具名对象</span></span><br><span class="line">    <span class="comment">// 对w进行操作</span></span><br><span class="line">    <span class="keyword">return</span> w;  <span class="comment">// NRVO可能发生在这里</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-未具名返回值优化-URVO-Unnamed-Return-Value-Optimization"><a href="#2-未具名返回值优化-URVO-Unnamed-Return-Value-Optimization" class="headerlink" title="2. 未具名返回值优化(URVO, Unnamed Return Value Optimization)"></a>2. 未具名返回值优化(URVO, Unnamed Return Value Optimization)</h4><p>当函数返回一个临时对象时，编译器可能应用的优化。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Widget <span class="title">makeWidget</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Widget</span>();  <span class="comment">// 临时对象，URVO可能发生</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="返回值优化的工作原理"><a href="#返回值优化的工作原理" class="headerlink" title="返回值优化的工作原理"></a>返回值优化的工作原理</h3><p>编译器通常会：</p>
<ol>
<li>在调用者的栈帧中预留返回对象的内存空间</li>
<li>将这块内存的地址传递给被调函数</li>
<li>被调函数直接在这块内存上构造对象</li>
</ol>
<p>这样避免了额外的拷贝或移动操作。</p>
<h3 id="如何确保获得返回值优化"><a href="#如何确保获得返回值优化" class="headerlink" title="如何确保获得返回值优化"></a>如何确保获得返回值优化</h3><p>为了最大化获得RVO的机会：</p>
<ol>
<li><p>返回局部对象时使用最简单的形式</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 好的形式 - 易于优化</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">MyClass</span>(arg1, arg2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不好的形式 - 可能阻碍优化</span></span><br><span class="line"><span class="function">MyClass <span class="title">result</span><span class="params">(arg1, arg2)</span></span>;</span><br><span class="line"><span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure>
</li>
<li><p>避免对返回的对象进行复杂的控制流操作</p>
</li>
<li><p>保持返回类型与返回表达式类型一致</p>
</li>
</ol>
<h3 id="返回值优化与移动语义的关系"><a href="#返回值优化与移动语义的关系" class="headerlink" title="返回值优化与移动语义的关系"></a>返回值优化与移动语义的关系</h3><p>C++11引入移动语义后，即使RVO未发生，编译器也会尝试使用移动构造函数而非拷贝构造函数：</p>
<ol>
<li>如果RVO发生：无任何拷贝或移动</li>
<li>如果RVO未发生但移动构造函数可用：使用移动构造</li>
<li>如果RVO未发生且移动构造函数不可用：使用拷贝构造</li>
</ol>
<h3 id="实际示例"><a href="#实际示例" class="headerlink" title="实际示例"></a>实际示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Constructor\n&quot;</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Test</span>(<span class="type">const</span> Test &amp;) &#123; std::cout &lt;&lt; <span class="string">&quot;Copy Constructor\n&quot;</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Test</span>(Test &amp;&amp;) &#123; std::cout &lt;&lt; <span class="string">&quot;Move Constructor\n&quot;</span>; &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Test</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Destructor\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Test <span class="title">createTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Test t;</span><br><span class="line">    <span class="keyword">return</span> t;  <span class="comment">// NRVO可能发生</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Test <span class="title">createTest2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Test</span>();  <span class="comment">// URVO可能发生</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Test <span class="title">createTest3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 编译器预先不知道返回的是哪一个对象</span></span><br><span class="line">    <span class="comment">// 会优先调用移动构造函数</span></span><br><span class="line">    <span class="comment">// 如果没有移动构造函数会触发拷贝构造函数</span></span><br><span class="line">    Test t1;</span><br><span class="line">    Test t2;</span><br><span class="line">    <span class="keyword">auto</span> rand = std::<span class="built_in">rand</span>();</span><br><span class="line">    <span class="keyword">if</span> (rand % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> t1;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> t2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Case 1:\n&quot;</span>;</span><br><span class="line">    <span class="keyword">auto</span> t1 = <span class="built_in">createTest</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\nCase 2:\n&quot;</span>;</span><br><span class="line">    <span class="keyword">auto</span> t2 = <span class="built_in">createTest2</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\nCase 3:\n&quot;</span>;</span><br><span class="line">    <span class="keyword">auto</span> t3 = <span class="built_in">createTest3</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在现代编译器上，上述代码很可能只输出构造函数和析构函数，没有拷贝或移动操作。</p>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol>
<li>RVO是编译器的优化而非语言要求，但现代主流编译器都会实现</li>
<li>调试模式下RVO可能被禁用</li>
<li>某些复杂控制流可能阻碍RVO</li>
<li>C++17开始，某些情况下的拷贝消除成为语言要求而非优化</li>
</ol>
<p>返回值优化是C++性能优化的重要组成部分，理解它有助于编写更高效的代码。</p>
<h2 id="7-2-异常的得失和相关建议"><a href="#7-2-异常的得失和相关建议" class="headerlink" title="7.2 异常的得失和相关建议"></a>7.2 异常的得失和相关建议</h2><h1 id="C-异常的得失与相关建议"><a href="#C-异常的得失与相关建议" class="headerlink" title="C++异常的得失与相关建议"></a>C++异常的得失与相关建议</h1><h2 id="异常机制的优点"><a href="#异常机制的优点" class="headerlink" title="异常机制的优点"></a>异常机制的优点</h2><ol>
<li><strong>错误处理分离</strong>：将错误处理代码从正常业务逻辑中分离，提高代码可读性</li>
<li><strong>强制处理</strong>：异常不能被忽略（除非使用catch(…)），而错误码可以被忽略</li>
<li><strong>跨函数传播</strong>：异常可以自动跨多层函数调用传播，直到被捕获</li>
<li><strong>类型丰富</strong>：可以抛出任意类型的对象，携带丰富的错误信息</li>
<li><strong>构造函数错误处理</strong>：构造函数无法返回错误码，异常是报告构造失败的合理方式</li>
</ol>
<h2 id="异常机制的缺点"><a href="#异常机制的缺点" class="headerlink" title="异常机制的缺点"></a>异常机制的缺点</h2><ol>
<li><strong>性能开销</strong>：异常处理机制（尤其是栈展开）可能带来运行时开销</li>
<li><strong>代码复杂度</strong>：异常安全编程需要遵循特定规则（如RAII）</li>
<li><strong>不可预测性</strong>：控制流可能突然跳转，难以追踪执行路径</li>
<li><strong>资源管理挑战</strong>：可能导致资源泄漏，如果没有正确使用RAII</li>
<li><strong>跨模块&#x2F;语言边界问题</strong>：在DLL边界或与其他语言交互时可能有问题</li>
</ol>
<h2 id="实用建议"><a href="#实用建议" class="headerlink" title="实用建议"></a>实用建议</h2><ol>
<li><p><strong>合理使用场景</strong>：</p>
<ul>
<li>适合用于真正的异常情况（不可恢复错误、资源不足等）</li>
<li>不适合用于常规控制流或频繁发生的可预期错误</li>
</ul>
</li>
<li><p><strong>异常安全保证</strong>：</p>
<ul>
<li>基本保证：异常发生时程序保持有效状态</li>
<li>强保证：操作要么完全成功，要么完全回滚（事务语义）</li>
<li>不抛保证：承诺不抛出异常</li>
</ul>
</li>
</ol>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>C++异常是一个强大的工具，但需要谨慎使用。在现代C++中，结合RAII、智能指针和其他资源管理技术，可以有效地利用异常机制，同时避免其陷阱。关键是根据项目需求和团队约定，制定一致的异常使用策略。</p>
<h1 id="8-语言易用性改进"><a href="#8-语言易用性改进" class="headerlink" title="8. 语言易用性改进"></a>8. 语言易用性改进</h1><h2 id="8-1-自动类型推导和类模板参数推导"><a href="#8-1-自动类型推导和类模板参数推导" class="headerlink" title="8.1 自动类型推导和类模板参数推导"></a>8.1 自动类型推导和类模板参数推导</h2><h3 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h3><p>auto不仅仅是语法糖</p>
<h3 id="decltype"><a href="#decltype" class="headerlink" title="decltype"></a>decltype</h3><p><code>decltype</code>是C++11引入的一个关键字，用于查询表达式的类型。它的全称是”declared type”（声明类型）。</p>
<h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><p><code>decltype</code>的基本语法是：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">decltype</span>(expression) var;</span><br></pre></td></tr></table></figure>
<p>这里<code>var</code>的类型将由<code>expression</code>的类型决定。</p>
<h4 id="主要特点"><a href="#主要特点" class="headerlink" title="主要特点"></a>主要特点</h4><ol>
<li><p><strong>保留类型信息</strong>：<code>decltype</code>会保留表达式的完整类型信息，包括const限定符和引用。</p>
</li>
<li><p><strong>不计算表达式</strong>：<code>decltype</code>只分析表达式的类型，不会实际计算表达式。</p>
</li>
<li><p><strong>两种形式</strong>：</p>
<ul>
<li><code>decltype(entity)</code>：当参数是一个无括号的变量名时，返回该变量的声明类型</li>
<li><code>decltype(expression)</code>：当参数是其他表达式时，返回表达式计算结果的类型</li>
</ul>
</li>
</ol>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; rx = x;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例1：decltype(entity)</span></span><br><span class="line"><span class="keyword">decltype</span>(rx) y = x;  <span class="comment">// y的类型是const int&amp;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例2：decltype(expression)</span></span><br><span class="line"><span class="keyword">decltype</span>(x + <span class="number">5</span>) z;    <span class="comment">// z的类型是int</span></span><br><span class="line"><span class="keyword">decltype</span>((x)) w = x;   <span class="comment">// w的类型是int&amp;，因为(x)是一个左值表达式</span></span><br></pre></td></tr></table></figure>

<h4 id="与auto的区别"><a href="#与auto的区别" class="headerlink" title="与auto的区别"></a>与auto的区别</h4><ul>
<li><code>auto</code>会忽略顶层const和引用</li>
<li><code>decltype</code>会保留所有的类型信息</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> ci = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> a = ci;        <span class="comment">// a是int</span></span><br><span class="line"><span class="keyword">decltype</span>(ci) b = ci; <span class="comment">// b是const int</span></span><br></pre></td></tr></table></figure>

<h4 id="常见用途"><a href="#常见用途" class="headerlink" title="常见用途"></a>常见用途</h4><ol>
<li><p><strong>模板编程</strong>：在模板中根据参数推导返回类型</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">add</span><span class="params">(T t, U u)</span> -&gt; <span class="title">decltype</span><span class="params">(t + u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t + u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>lambda表达式</strong>：获取lambda的类型</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> lambda = [](<span class="type">int</span> x) &#123; <span class="keyword">return</span> x * <span class="number">2</span>; &#125;;</span><br><span class="line"><span class="keyword">decltype</span>(lambda) copy = lambda;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>SFINAE</strong>：在模板元编程中用于类型检查</p>
</li>
</ol>
<h4 id="C-14扩展"><a href="#C-14扩展" class="headerlink" title="C++14扩展"></a>C++14扩展</h4><p>C++14引入了<code>decltype(auto)</code>，它使用<code>decltype</code>的规则来推导<code>auto</code>的类型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">getRef</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) a = <span class="built_in">getRef</span>();  <span class="comment">// a是int&amp;</span></span><br></pre></td></tr></table></figure>
<p><code>decltype</code>是C++类型系统中非常重要的一个工具，特别是在模板元编程和泛型编程中非常有用。</p>
<h2 id="8-2-类的特殊非静态成员函数和相关易用性改进"><a href="#8-2-类的特殊非静态成员函数和相关易用性改进" class="headerlink" title="8.2 类的特殊非静态成员函数和相关易用性改进"></a>8.2 类的特殊非静态成员函数和相关易用性改进</h2><h2 id="8-3-初始化相关易用性改进"><a href="#8-3-初始化相关易用性改进" class="headerlink" title="8.3 初始化相关易用性改进"></a>8.3 初始化相关易用性改进</h2><p>C++的初始化机制经历了从C++98到C++11及之后版本的持续改进。下面我们可以从不同的版本和维度来谈谈C++在初始化方面的主要改进：</p>
<h3 id="1-统一的花括号初始化（列表初始化-brace-initialization）"><a href="#1-统一的花括号初始化（列表初始化-brace-initialization）" class="headerlink" title="1. 统一的花括号初始化（列表初始化 &#x2F; brace initialization）"></a>1. <strong>统一的花括号初始化（列表初始化 &#x2F; brace initialization）</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x&#123;<span class="number">5</span>&#125;;</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; v&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">MyClass obj&#123;arg1, arg2&#125;;</span><br></pre></td></tr></table></figure>

<p>优点：</p>
<ul>
<li><p><strong>统一语法</strong>：适用于内置类型、容器、类对象等。</p>
</li>
<li><p><strong>防止窄化（narrowing）转换</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x1 = <span class="number">3.14</span>;   <span class="comment">// OK，x1 = 3</span></span><br><span class="line"><span class="type">int</span> x2&#123;<span class="number">3.14</span>&#125;;    <span class="comment">// 编译错误！更安全</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-默认成员初始化（default-member-initializers）"><a href="#2-默认成员初始化（default-member-initializers）" class="headerlink" title="2. 默认成员初始化（default member initializers）"></a>2. <strong>默认成员初始化（default member initializers）</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="type">int</span> x = <span class="number">10</span>;         <span class="comment">// 成员默认初始化</span></span><br><span class="line">  std::string name&#123;<span class="string">&quot;default&quot;</span>&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这样可以减少构造函数中的初始化负担。</p>
<h3 id="3-构造函数委托"><a href="#3-构造函数委托" class="headerlink" title="3. 构造函数委托"></a>3. <strong>构造函数委托</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">A</span>() : <span class="built_in">A</span>(<span class="number">0</span>) &#123;&#125;       <span class="comment">// 委托给另一个构造函数</span></span><br><span class="line">  <span class="built_in">A</span>(<span class="type">int</span> val) : <span class="built_in">x</span>(val) &#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> x;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>改善构造函数代码复用性。</p>
<h3 id="4-统一初始化语法与-std-initializer-list-构造"><a href="#4-统一初始化语法与-std-initializer-list-构造" class="headerlink" title="4. 统一初始化语法与**std::initializer_list**构造"></a>4. <strong>统一初始化语法与</strong>**<code>std::initializer_list</code>**<strong>构造</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">MyClass</span>(std::initializer_list&lt;<span class="type">int</span>&gt; list) &#123; ... &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MyClass obj&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;  <span class="comment">// 自动调用 initializer_list 构造函数</span></span><br></pre></td></tr></table></figure>

<p>这种方式为容器和类提供了更强大和直观的初始化能力。</p>
<h2 id="8-4-其他易用性改进"><a href="#8-4-其他易用性改进" class="headerlink" title="8.4 其他易用性改进"></a>8.4 其他易用性改进</h2><p>在 C++ 中，<strong>用户定义字面量（User-defined Literal）</strong> 是一种允许程序员为字面量（如整数、浮点数、字符串等）添加自定义语义的机制。通过用户定义字面量，可以让代码更具可读性和表达力。</p>
<h3 id="一、用户定义字面量（User-defined-Literal）"><a href="#一、用户定义字面量（User-defined-Literal）" class="headerlink" title="一、用户定义字面量（User-defined Literal）"></a>一、用户定义字面量（User-defined Literal）</h3><p>用户定义字面量使用特殊的函数形式来定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">返回类型 <span class="keyword">operator</span><span class="string">&quot;&quot;</span> 标识符(参数)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>标识符</code> 是你为字面量定义的名称（不能是保留名称）。</li>
<li>参数的类型依赖于字面量的类型，例如整数是 <code>unsigned long long</code>，字符串是 <code>const char*</code> 等。</li>
<li>必须加上 <code>operator&quot;&quot;</code>。</li>
</ul>
<hr>
<h3 id="二、示例"><a href="#二、示例" class="headerlink" title="二、示例"></a>二、示例</h3><h4 id="1-距离单位（如米、千米）"><a href="#1-距离单位（如米、千米）" class="headerlink" title="1. 距离单位（如米、千米）"></a>1. 距离单位（如米、千米）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="type">double</span> <span class="keyword">operator</span><span class="string">&quot;&quot;</span> _km(<span class="type">long</span> <span class="type">double</span> x) &#123;</span><br><span class="line">    <span class="keyword">return</span> x * <span class="number">1000</span>;  <span class="comment">// 转换为米</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="type">double</span> <span class="keyword">operator</span><span class="string">&quot;&quot;</span> _m(<span class="type">long</span> <span class="type">double</span> x) &#123;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">double</span> distance = <span class="number">1.5</span>_km + <span class="number">30.0</span>_m;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Distance in meters: &quot;</span> &lt;&lt; distance &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Distance in meters: 1530</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="2-二进制字面量"><a href="#2-二进制字面量" class="headerlink" title="2. 二进制字面量"></a>2. 二进制字面量</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="keyword">operator</span><span class="string">&quot;&quot;</span> _bin(<span class="type">const</span> <span class="type">char</span>* str) &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> value = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (*str) &#123;</span><br><span class="line">        value = value * <span class="number">2</span> + (*str++ - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Binary 1011 is: &quot;</span> &lt;&lt; <span class="number">1011</span>_bin &lt;&lt; std::endl;  <span class="comment">// 输出 11</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="三、可接受的参数类型"><a href="#三、可接受的参数类型" class="headerlink" title="三、可接受的参数类型"></a>三、可接受的参数类型</h3><p>用户定义字面量的参数类型（固定规则）包括：</p>
<table>
<thead>
<tr>
<th>字面量类型</th>
<th>参数类型</th>
</tr>
</thead>
<tbody><tr>
<td>整数字面量</td>
<td><code>unsigned long long</code></td>
</tr>
<tr>
<td>浮点字面量</td>
<td><code>long double</code></td>
</tr>
<tr>
<td>字符字面量</td>
<td><code>char</code></td>
</tr>
<tr>
<td>字符串</td>
<td><code>const char*</code>, <code>std::size_t</code></td>
</tr>
<tr>
<td>字符数组</td>
<td><code>const char*, std::size_t</code></td>
</tr>
</tbody></table>
<hr>
<h3 id="四、用途和好处"><a href="#四、用途和好处" class="headerlink" title="四、用途和好处"></a>四、用途和好处</h3><ul>
<li>增强语义，例如 <code>10_km</code> 比 <code>10000</code> 更清晰。</li>
<li>避免单位混淆错误。</li>
<li>常用于自定义单位、时间、字符串解析等场景。</li>
</ul>
<hr>
<h3 id="五、注意事项"><a href="#五、注意事项" class="headerlink" title="五、注意事项"></a>五、注意事项</h3><ul>
<li>字面量后缀名不能以下划线开头（比如 <code>_x</code> 是合法的，<code>__x</code> 不合法，因为以双下划线或下划线加大写字母开头是保留的）。</li>
<li>必须使用 <code>operator&quot;&quot;</code> 形式。</li>
</ul>
<hr>
<p>如果你想深入了解某种特定用途（比如用于时间、温度、加密等），也可以给出具体场景，我可以进一步示例说明。</p>
<h1 id="9-部分其他新特性"><a href="#9-部分其他新特性" class="headerlink" title="9. 部分其他新特性"></a>9. 部分其他新特性</h1><h2 id="9-1-using-类型别名；定宽整数类型；enum-class；byte；UTF-字符类型"><a href="#9-1-using-类型别名；定宽整数类型；enum-class；byte；UTF-字符类型" class="headerlink" title="9.1 using 类型别名；定宽整数类型；enum class；byte；UTF 字符类型"></a>9.1 using 类型别名；定宽整数类型；enum class；byte；UTF 字符类型</h2><h3 id="using-类型别名"><a href="#using-类型别名" class="headerlink" title="using 类型别名"></a>using 类型别名</h3><p>当然可以！我们用简单易懂的方式来介绍 C++ 中的 <code>using</code> 类型别名。</p>
<hr>
<h4 id="什么是类型别名？"><a href="#什么是类型别名？" class="headerlink" title="什么是类型别名？"></a>什么是类型别名？</h4><p>类型别名就是给一个已有的类型起一个新的名字，让代码更简洁、好懂。</p>
<hr>
<h4 id="用法1：传统写法（typedef）"><a href="#用法1：传统写法（typedef）" class="headerlink" title="用法1：传统写法（typedef）"></a>用法1：传统写法（typedef）</h4><p>以前，我们用 <code>typedef</code> 来给类型起别名，比如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> uint;</span><br></pre></td></tr></table></figure>

<p>现在你可以用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> uint = <span class="type">unsigned</span> <span class="type">int</span>;</span><br></pre></td></tr></table></figure>

<p>这两个意思完全一样，都是把 <code>unsigned int</code> 起个新名字叫 <code>uint</code>。</p>
<hr>
<h4 id="为什么用-using-更好？"><a href="#为什么用-using-更好？" class="headerlink" title="为什么用 using 更好？"></a>为什么用 <code>using</code> 更好？</h4><ol>
<li><strong>语法更清晰</strong>：<code>using 新名字 = 原来的类型;</code></li>
<li><strong>支持模板别名</strong>（<code>typedef</code> 不支持）</li>
</ol>
<hr>
<h4 id="用法2：模板类型别名"><a href="#用法2：模板类型别名" class="headerlink" title="用法2：模板类型别名"></a>用法2：模板类型别名</h4><p>比如我们有个模板类型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> Vec = std::vector&lt;T&gt;;</span><br></pre></td></tr></table></figure>

<p>这个意思是：以后你写 <code>Vec&lt;int&gt;</code>，就等于写 <code>std::vector&lt;int&gt;</code>，是不是更短、更清楚？</p>
<hr>
<h4 id="举个例子总结："><a href="#举个例子总结：" class="headerlink" title="举个例子总结："></a>举个例子总结：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 给 string 起个新名字</span></span><br><span class="line"><span class="keyword">using</span> Str = std::string;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给 vector&lt;int&gt; 起个新名字</span></span><br><span class="line"><span class="keyword">using</span> IntVec = std::vector&lt;<span class="type">int</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给模板 vector&lt;T&gt; 起别名</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> Vec = std::vector&lt;T&gt;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Str name = <span class="string">&quot;Tom&quot;</span>;          <span class="comment">// 等于 std::string name = &quot;Tom&quot;;</span></span><br><span class="line">    IntVec numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;; <span class="comment">// 等于 std::vector&lt;int&gt; numbers</span></span><br><span class="line">    Vec&lt;<span class="type">double</span>&gt; scores = &#123;<span class="number">3.5</span>, <span class="number">4.0</span>&#125;; <span class="comment">// 等于 std::vector&lt;double&gt; scores</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="总结一下："><a href="#总结一下：" class="headerlink" title="总结一下："></a>总结一下：</h4><ul>
<li><code>using 新名字 = 原类型;</code> 就是给类型起别名的方法。</li>
<li>它比 <code>typedef</code> 更现代、更强大，尤其是支持模板别名。</li>
<li>可以让代码更短、更易读。</li>
</ul>
<p>需要我再举更多例子或者讲得更细一点吗？</p>
<h2 id="9-2-tuple、tie-和结构化绑定；时间、随机数、正则表达式"><a href="#9-2-tuple、tie-和结构化绑定；时间、随机数、正则表达式" class="headerlink" title="9.2 tuple、tie 和结构化绑定；时间、随机数、正则表达式"></a>9.2 tuple、tie 和结构化绑定；时间、随机数、正则表达式</h2><h3 id="1-tuple（元组）：像一个小型的“多元素容器”"><a href="#1-tuple（元组）：像一个小型的“多元素容器”" class="headerlink" title="1. tuple（元组）：像一个小型的“多元素容器”"></a>1. <code>tuple</code>（元组）：像一个小型的“多元素容器”</h3><h4 id="什么是-tuple？"><a href="#什么是-tuple？" class="headerlink" title="什么是 tuple？"></a>什么是 <code>tuple</code>？</h4><p><code>tuple</code> 就像一个“装多个不同类型数据的小盒子”。</p>
<p>比如你想一起存一个名字（字符串）、年龄（int）和身高（float）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tuple&gt;</span></span></span><br><span class="line">std::tuple&lt;std::string, <span class="type">int</span>, <span class="type">float</span>&gt; person = &#123;<span class="string">&quot;Tom&quot;</span>, <span class="number">25</span>, <span class="number">1.75f</span>&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="怎么取出里面的值？"><a href="#怎么取出里面的值？" class="headerlink" title="怎么取出里面的值？"></a>怎么取出里面的值？</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::string name = std::<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(person);  <span class="comment">// &quot;Tom&quot;</span></span><br><span class="line"><span class="type">int</span> age = std::<span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(person);           <span class="comment">// 25</span></span><br><span class="line"><span class="type">float</span> height = std::<span class="built_in">get</span>&lt;<span class="number">2</span>&gt;(person);      <span class="comment">// 1.75</span></span><br></pre></td></tr></table></figure>


<h3 id="2-tie：绑定变量，用来解包元组"><a href="#2-tie：绑定变量，用来解包元组" class="headerlink" title="2. tie：绑定变量，用来解包元组"></a>2. <code>tie</code>：绑定变量，用来<strong>解包元组</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tuple&gt;</span></span></span><br><span class="line">std::tuple&lt;<span class="type">int</span>, <span class="type">int</span>&gt; result = &#123;<span class="number">10</span>, <span class="number">20</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a, b;</span><br><span class="line">std::<span class="built_in">tie</span>(a, b) = result;</span><br><span class="line"><span class="comment">// 现在 a = 10, b = 20</span></span><br></pre></td></tr></table></figure>

<p>你也可以忽略其中一部分：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="built_in">tie</span>(a, std::ignore) = result;  <span class="comment">// 只取第一个，忽略第二个</span></span><br></pre></td></tr></table></figure>


<h3 id="3-结构化绑定（C-17）：更简单地解包"><a href="#3-结构化绑定（C-17）：更简单地解包" class="headerlink" title="3. 结构化绑定（C++17）：更简单地解包"></a>3. 结构化绑定（C++17）：更简单地解包</h3><p>从 C++17 开始，不用 <code>tie</code>，可以直接这样写：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> [name, age, height] = person;</span><br><span class="line"><span class="comment">// 自动拆开 tuple 的内容，对应赋值给变量</span></span><br></pre></td></tr></table></figure>



<h3 id="4-时间（）"><a href="#4-时间（）" class="headerlink" title="4. 时间（&lt;chrono&gt;）"></a>4. 时间（<code>&lt;chrono&gt;</code>）</h3><h4 id="获取当前时间："><a href="#获取当前时间：" class="headerlink" title="获取当前时间："></a>获取当前时间：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> now = std::chrono::system_clock::<span class="built_in">now</span>();  <span class="comment">// 当前时间</span></span><br></pre></td></tr></table></figure>

<h4 id="计时器例子："><a href="#计时器例子：" class="headerlink" title="计时器例子："></a>计时器例子：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> start = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line"><span class="comment">// 做一些事情...</span></span><br><span class="line"><span class="keyword">auto</span> end = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> duration = std::chrono::<span class="built_in">duration_cast</span>&lt;std::chrono::milliseconds&gt;(end - start);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;耗时：&quot;</span> &lt;&lt; duration.<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot; 毫秒&quot;</span> &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>


<h3 id="5-随机数（）"><a href="#5-随机数（）" class="headerlink" title="5. 随机数（&lt;random&gt;）"></a>5. 随机数（<code>&lt;random&gt;</code>）</h3><h4 id="生成一个-1-到-100-的随机整数："><a href="#生成一个-1-到-100-的随机整数：" class="headerlink" title="生成一个 1 到 100 的随机整数："></a>生成一个 1 到 100 的随机整数：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;random&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::random_device rd;                      <span class="comment">// 随机种子</span></span><br><span class="line"><span class="function">std::mt19937 <span class="title">gen</span><span class="params">(rd())</span></span>;                     <span class="comment">// 随机数生成器</span></span><br><span class="line">std::uniform_int_distribution&lt;&gt; <span class="built_in">dist</span>(<span class="number">1</span>, <span class="number">100</span>);  <span class="comment">// 均匀分布</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> randomNumber = <span class="built_in">dist</span>(gen);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;随机数：&quot;</span> &lt;&lt; randomNumber &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>


<h3 id="6-正则表达式（）"><a href="#6-正则表达式（）" class="headerlink" title="6. 正则表达式（&lt;regex&gt;）"></a>6. 正则表达式（<code>&lt;regex&gt;</code>）</h3><h4 id="检查一个字符串是不是-email："><a href="#检查一个字符串是不是-email：" class="headerlink" title="检查一个字符串是不是 email："></a>检查一个字符串是不是 email：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;regex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::string email = <span class="string">&quot;abc@example.com&quot;</span>;</span><br><span class="line"><span class="function">std::regex <span class="title">pattern</span><span class="params">(<span class="string">R&quot;(\w+@\w+\.\w+)&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (std::<span class="built_in">regex_match</span>(email, pattern)) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;是合法的 email&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;不是合法的 email&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="查找字符串中的数字："><a href="#查找字符串中的数字：" class="headerlink" title="查找字符串中的数字："></a>查找字符串中的数字：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">std::string text = <span class="string">&quot;abc123xyz456&quot;</span>;</span><br><span class="line"><span class="function">std::regex <span class="title">pattern</span><span class="params">(<span class="string">R&quot;(\d+)&quot;</span>)</span></span>;</span><br><span class="line">std::smatch match;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (std::<span class="built_in">regex_search</span>(text, match, pattern)) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;找到数字：&quot;</span> &lt;&lt; match.<span class="built_in">str</span>() &lt;&lt; std::endl;</span><br><span class="line">    text = match.<span class="built_in">suffix</span>();  <span class="comment">// 剩下的部分继续查找</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="10-any、optional、variant-和错误处理"><a href="#10-any、optional、variant-和错误处理" class="headerlink" title="10. any、optional、variant 和错误处理"></a>10. any、optional、variant 和错误处理</h1><h2 id="10-1-any-和-optional"><a href="#10-1-any-和-optional" class="headerlink" title="10.1 any 和 optional"></a>10.1 any 和 optional</h2><h2 id="10-2-variant；any、optional、variant-的接口比较"><a href="#10-2-variant；any、optional、variant-的接口比较" class="headerlink" title="10.2 variant；any、optional、variant 的接口比较"></a>10.2 variant；any、optional、variant 的接口比较</h2><h2 id="10-3-标准库的错误处理"><a href="#10-3-标准库的错误处理" class="headerlink" title="10.3 标准库的错误处理"></a>10.3 标准库的错误处理</h2><h2 id="小节自测-3"><a href="#小节自测-3" class="headerlink" title="小节自测"></a><em>小节自测</em></h2>
    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/cpp/" rel="tag"># cpp</a>
              <a href="/tags/%E5%8D%8E%E4%B8%BA/" rel="tag"># 华为</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2025/04/29/%E5%8D%8E%E4%B8%BA%E5%85%A5%E8%81%8C%E5%9F%B9%E8%AE%AD-%E5%BC%80%E5%8F%91%E8%80%85%E6%B5%8B%E8%AF%95/" rel="prev" title="华为入职培训-开发者测试">
      <i class="fa fa-chevron-left"></i> 华为入职培训-开发者测试
    </a></div>
      <div class="post-nav-item">
    <a href="/2025/05/20/%E5%8D%8E%E4%B8%BA%E5%85%A5%E8%81%8C%E5%9F%B9%E8%AE%AD-Clean%20Code%E4%B8%8E%E9%87%8D%E6%9E%84%E5%AE%89%E5%85%A8%E5%AE%9E%E8%B7%B5/" rel="next" title="华为入职培训-Clean Code与重构安全实践">
      华为入职培训-Clean Code与重构安全实践 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-C-%E7%9A%84%E7%89%B9%E7%82%B9%E4%B8%8E%E6%BC%94%E5%8C%96"><span class="nav-number">1.</span> <span class="nav-text">1. C++的特点与演化</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8C"><span class="nav-number">1.1.</span> <span class="nav-text">为什么要用C++</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C%E4%B8%8EC"><span class="nav-number">1.2.</span> <span class="nav-text">C与C++</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-%E7%9A%84%E6%BC%94%E8%BF%9B"><span class="nav-number">1.3.</span> <span class="nav-text">C++的演进</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#c-%E5%A7%94%E5%91%98%E4%BC%9A%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%96%B9%E5%BC%8F"><span class="nav-number">1.4.</span> <span class="nav-text">c++委员会的工作方式</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%A7%84%E5%88%99"><span class="nav-number">2.</span> <span class="nav-text">2. 资源管理和对象的基本规则</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%A7%84%E5%88%99-1"><span class="nav-number">2.1.</span> <span class="nav-text">2. 资源管理和对象的基本规则</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A0%86%E4%B8%8E%E6%A0%88"><span class="nav-number">2.1.1.</span> <span class="nav-text">堆与栈</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E6%A0%88%EF%BC%88Stack%EF%BC%89%E2%80%94%E2%80%94%E5%83%8F%E2%80%9C%E5%BF%AB%E9%A4%90%E5%BA%97%E5%8F%96%E9%A4%90%E7%9B%98%E2%80%9D"><span class="nav-number">2.1.1.1.</span> <span class="nav-text">1. 栈（Stack）——像“快餐店取餐盘”</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E5%A0%86%EF%BC%88Heap%EF%BC%89%E2%80%94%E2%80%94%E5%83%8F%E2%80%9C%E8%87%AA%E5%8A%A9%E4%BB%93%E5%BA%93%E2%80%9D"><span class="nav-number">2.1.1.2.</span> <span class="nav-text">2. 堆（Heap）——像“自助仓库”</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B3%E9%94%AE%E5%8C%BA%E5%88%AB%E6%80%BB%E7%BB%93"><span class="nav-number">2.1.1.3.</span> <span class="nav-text">关键区别总结</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%9A%E4%BF%97%E6%AF%94%E5%96%BB"><span class="nav-number">2.1.1.4.</span> <span class="nav-text">通俗比喻</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%8D%E7%A7%B0%E6%9D%A5%E6%BA%90"><span class="nav-number">2.1.1.5.</span> <span class="nav-text">名称来源</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RAII-Resource-Acquisition-Is-Initialization"><span class="nav-number">2.1.2.</span> <span class="nav-text">RAII&#x2F;Resource Acquisition Is Initialization</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%8B%B7%E8%B4%9D%E5%92%8C%E7%A7%BB%E5%8A%A8"><span class="nav-number">2.1.3.</span> <span class="nav-text">对象的拷贝和移动</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%89%B9%E6%AE%8A%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="nav-number">2.1.4.</span> <span class="nav-text">对象的特殊成员函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C-%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%89%B9%E6%AE%8A%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E6%80%BB%E7%BB%93%E8%A1%A8"><span class="nav-number">2.1.5.</span> <span class="nav-text">C++ 对象的特殊成员函数总结表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E5%8F%A5%E8%AF%9D%E6%80%BB%E7%BB%93"><span class="nav-number">2.1.6.</span> <span class="nav-text">一句话总结</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%89%E6%B3%95%E5%88%99"><span class="nav-number">2.1.7.</span> <span class="nav-text">三法则</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89%E4%B8%8E%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8"><span class="nav-number">3.</span> <span class="nav-text">3. 移动语义与右值引用</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89%E4%B8%8E%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8-1"><span class="nav-number">3.1.</span> <span class="nav-text">3. 移动语义与右值引用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#C-%E7%9A%84%E5%80%BC%E7%B1%BB%E5%88%AB-Value-Categories"><span class="nav-number">3.1.1.</span> <span class="nav-text">C++ 的值类别 (Value Categories)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E5%B7%A6%E5%80%BC-lvalue"><span class="nav-number">3.1.1.1.</span> <span class="nav-text">1. 左值 (lvalue)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E7%BA%AF%E5%8F%B3%E5%80%BC-prvalue-pure-rvalue"><span class="nav-number">3.1.1.2.</span> <span class="nav-text">2. 纯右值 (prvalue, pure rvalue)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E5%B0%86%E4%BA%A1%E5%80%BC-xvalue-expiring-value"><span class="nav-number">3.1.1.3.</span> <span class="nav-text">3. 将亡值 (xvalue, expiring value)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%8D%E5%90%88%E7%B1%BB%E5%88%AB"><span class="nav-number">3.1.1.4.</span> <span class="nav-text">复合类别</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B9%BF%E4%B9%89%E5%B7%A6%E5%80%BC-glvalue-generalized-lvalue"><span class="nav-number">3.1.1.4.1.</span> <span class="nav-text">广义左值 (glvalue, generalized lvalue)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8F%B3%E5%80%BC-rvalue"><span class="nav-number">3.1.1.4.2.</span> <span class="nav-text">右值 (rvalue)</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8"><span class="nav-number">3.1.1.5.</span> <span class="nav-text">实际应用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A7%BB%E5%8A%A8%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%92%8C%E6%84%8F%E4%B9%89"><span class="nav-number">3.1.2.</span> <span class="nav-text">移动的实现和意义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A7%BB%E5%8A%A8%E5%92%8Cnoexcept"><span class="nav-number">3.1.3.</span> <span class="nav-text">移动和noexcept</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%94%9F%E5%91%BD%E6%9C%9F"><span class="nav-number">3.1.4.</span> <span class="nav-text">对象的生命期</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BD%AC%E5%8F%91%E5%BC%95%E7%94%A8"><span class="nav-number">3.1.5.</span> <span class="nav-text">转发引用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%94%E6%B3%95%E5%88%99"><span class="nav-number">3.1.6.</span> <span class="nav-text">五法则</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%94%E6%B3%95%E5%88%99%E7%9A%84%E8%83%8C%E6%99%AF"><span class="nav-number">3.1.6.1.</span> <span class="nav-text">五法则的背景</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E4%BA%94%E6%B3%95%E5%88%99"><span class="nav-number">3.1.6.2.</span> <span class="nav-text">为什么需要五法则</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B"><span class="nav-number">3.1.6.3.</span> <span class="nav-text">示例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BE%8B%E5%A4%96%E6%83%85%E5%86%B5"><span class="nav-number">3.1.6.4.</span> <span class="nav-text">例外情况</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%8E%B0%E4%BB%A3C-%E7%9A%84%E6%9B%BF%E4%BB%A3%E6%96%B9%E6%A1%88"><span class="nav-number">3.1.6.5.</span> <span class="nav-text">现代C++的替代方案</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%8F%E8%8A%82%E8%87%AA%E6%B5%8B"><span class="nav-number">3.2.</span> <span class="nav-text">小节自测</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="nav-number">4.</span> <span class="nav-text">4. 智能指针</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88-1"><span class="nav-number">4.1.</span> <span class="nav-text">4. 智能指针</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BB%E8%A6%81%E7%B1%BB%E5%9E%8B"><span class="nav-number">4.1.1.</span> <span class="nav-text">主要类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%EF%BC%9F"><span class="nav-number">4.1.2.</span> <span class="nav-text">为什么用智能指针？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%80%E5%8D%95%E4%BE%8B%E5%AD%90"><span class="nav-number">4.1.3.</span> <span class="nav-text">简单例子</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%BB%BA%E8%AE%AE"><span class="nav-number">4.1.4.</span> <span class="nav-text">使用建议</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%8F%E8%8A%82%E8%87%AA%E6%B5%8B-1"><span class="nav-number">4.2.</span> <span class="nav-text">小节自测</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5-%E5%AE%B9%E5%99%A8%E5%92%8C%E7%B1%BB%E5%AE%B9%E5%99%A8"><span class="nav-number">5.</span> <span class="nav-text">5. 容器和类容器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#5-1-string%EF%BC%9B%E5%BA%8F%E5%88%97%E5%AE%B9%E5%99%A8"><span class="nav-number">5.1.</span> <span class="nav-text">5.1 string；序列容器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#String"><span class="nav-number">5.1.1.</span> <span class="nav-text">String</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#array"><span class="nav-number">5.1.2.</span> <span class="nav-text">array</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Vector"><span class="nav-number">5.1.3.</span> <span class="nav-text">Vector</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#deque"><span class="nav-number">5.1.4.</span> <span class="nav-text">deque</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#list"><span class="nav-number">5.1.5.</span> <span class="nav-text">list</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#queue"><span class="nav-number">5.1.6.</span> <span class="nav-text">queue</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#stack"><span class="nav-number">5.1.7.</span> <span class="nav-text">stack</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-2-%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8%E5%92%8C%E6%97%A0%E5%BA%8F%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8"><span class="nav-number">5.2.</span> <span class="nav-text">5.2 关联容器和无序关联容器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8-%E6%9C%89%E5%BA%8F%E5%AE%B9%E5%99%A8"><span class="nav-number">5.2.1.</span> <span class="nav-text">关联容器 (有序容器)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%A0%E5%BA%8F%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8-%E5%93%88%E5%B8%8C%E5%AE%B9%E5%99%A8"><span class="nav-number">5.2.2.</span> <span class="nav-text">无序关联容器 (哈希容器)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%8F%E8%8A%82%E8%87%AA%E6%B5%8B-2"><span class="nav-number">5.3.</span> <span class="nav-text">小节自测</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6-%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E5%BE%AA%E7%8E%AF"><span class="nav-number">6.</span> <span class="nav-text">6. 迭代器和循环</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#6-%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E5%BE%AA%E7%8E%AF-1"><span class="nav-number">6.1.</span> <span class="nav-text">6. 迭代器和循环</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="nav-number">6.1.1.</span> <span class="nav-text">迭代器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9B%B4%E9%AB%98%E7%BA%A7%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A6%82%E5%BF%B5"><span class="nav-number">6.2.</span> <span class="nav-text">更高级的迭代器概念</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#7-%E5%AF%B9%E8%B1%A1%E8%BF%94%E5%9B%9E%E5%92%8C%E5%BC%82%E5%B8%B8"><span class="nav-number">7.</span> <span class="nav-text">7. 对象返回和异常</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#7-1-%E8%BF%94%E5%9B%9E%E5%80%BC%E4%BC%98%E5%8C%96%E5%92%8C%E5%AF%B9%E8%B1%A1%E8%BF%94%E5%9B%9E"><span class="nav-number">7.1.</span> <span class="nav-text">7.1 返回值优化和对象返回</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-number">7.1.1.</span> <span class="nav-text">基本概念</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%BF%94%E5%9B%9E%E5%80%BC%E4%BC%98%E5%8C%96"><span class="nav-number">7.1.1.1.</span> <span class="nav-text">什么是返回值优化</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E8%BF%94%E5%9B%9E%E5%80%BC%E4%BC%98%E5%8C%96"><span class="nav-number">7.1.2.</span> <span class="nav-text">为什么需要返回值优化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BC%E4%BC%98%E5%8C%96%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="nav-number">7.1.3.</span> <span class="nav-text">返回值优化的类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E5%85%B7%E5%90%8D%E8%BF%94%E5%9B%9E%E5%80%BC%E4%BC%98%E5%8C%96-NRVO-Named-Return-Value-Optimization"><span class="nav-number">7.1.3.1.</span> <span class="nav-text">1. 具名返回值优化(NRVO, Named Return Value Optimization)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E6%9C%AA%E5%85%B7%E5%90%8D%E8%BF%94%E5%9B%9E%E5%80%BC%E4%BC%98%E5%8C%96-URVO-Unnamed-Return-Value-Optimization"><span class="nav-number">7.1.3.2.</span> <span class="nav-text">2. 未具名返回值优化(URVO, Unnamed Return Value Optimization)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BC%E4%BC%98%E5%8C%96%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="nav-number">7.1.4.</span> <span class="nav-text">返回值优化的工作原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E7%A1%AE%E4%BF%9D%E8%8E%B7%E5%BE%97%E8%BF%94%E5%9B%9E%E5%80%BC%E4%BC%98%E5%8C%96"><span class="nav-number">7.1.5.</span> <span class="nav-text">如何确保获得返回值优化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BC%E4%BC%98%E5%8C%96%E4%B8%8E%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-number">7.1.6.</span> <span class="nav-text">返回值优化与移动语义的关系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E9%99%85%E7%A4%BA%E4%BE%8B"><span class="nav-number">7.1.7.</span> <span class="nav-text">实际示例</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">7.2.</span> <span class="nav-text">注意事项</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-2-%E5%BC%82%E5%B8%B8%E7%9A%84%E5%BE%97%E5%A4%B1%E5%92%8C%E7%9B%B8%E5%85%B3%E5%BB%BA%E8%AE%AE"><span class="nav-number">7.3.</span> <span class="nav-text">7.2 异常的得失和相关建议</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#C-%E5%BC%82%E5%B8%B8%E7%9A%84%E5%BE%97%E5%A4%B1%E4%B8%8E%E7%9B%B8%E5%85%B3%E5%BB%BA%E8%AE%AE"><span class="nav-number">8.</span> <span class="nav-text">C++异常的得失与相关建议</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E6%9C%BA%E5%88%B6%E7%9A%84%E4%BC%98%E7%82%B9"><span class="nav-number">8.1.</span> <span class="nav-text">异常机制的优点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E6%9C%BA%E5%88%B6%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="nav-number">8.2.</span> <span class="nav-text">异常机制的缺点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E7%94%A8%E5%BB%BA%E8%AE%AE"><span class="nav-number">8.3.</span> <span class="nav-text">实用建议</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%93%E8%AE%BA"><span class="nav-number">8.4.</span> <span class="nav-text">结论</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#8-%E8%AF%AD%E8%A8%80%E6%98%93%E7%94%A8%E6%80%A7%E6%94%B9%E8%BF%9B"><span class="nav-number">9.</span> <span class="nav-text">8. 语言易用性改进</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#8-1-%E8%87%AA%E5%8A%A8%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC%E5%92%8C%E7%B1%BB%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0%E6%8E%A8%E5%AF%BC"><span class="nav-number">9.1.</span> <span class="nav-text">8.1 自动类型推导和类模板参数推导</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#auto"><span class="nav-number">9.1.1.</span> <span class="nav-text">auto</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#decltype"><span class="nav-number">9.1.2.</span> <span class="nav-text">decltype</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="nav-number">9.1.2.1.</span> <span class="nav-text">基本用法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BB%E8%A6%81%E7%89%B9%E7%82%B9"><span class="nav-number">9.1.2.2.</span> <span class="nav-text">主要特点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-1"><span class="nav-number">9.1.2.3.</span> <span class="nav-text">示例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%8Eauto%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">9.1.2.4.</span> <span class="nav-text">与auto的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E7%94%A8%E9%80%94"><span class="nav-number">9.1.2.5.</span> <span class="nav-text">常见用途</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#C-14%E6%89%A9%E5%B1%95"><span class="nav-number">9.1.2.6.</span> <span class="nav-text">C++14扩展</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-2-%E7%B1%BB%E7%9A%84%E7%89%B9%E6%AE%8A%E9%9D%9E%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E5%92%8C%E7%9B%B8%E5%85%B3%E6%98%93%E7%94%A8%E6%80%A7%E6%94%B9%E8%BF%9B"><span class="nav-number">9.2.</span> <span class="nav-text">8.2 类的特殊非静态成员函数和相关易用性改进</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-3-%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9B%B8%E5%85%B3%E6%98%93%E7%94%A8%E6%80%A7%E6%94%B9%E8%BF%9B"><span class="nav-number">9.3.</span> <span class="nav-text">8.3 初始化相关易用性改进</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E7%BB%9F%E4%B8%80%E7%9A%84%E8%8A%B1%E6%8B%AC%E5%8F%B7%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%88%E5%88%97%E8%A1%A8%E5%88%9D%E5%A7%8B%E5%8C%96-brace-initialization%EF%BC%89"><span class="nav-number">9.3.1.</span> <span class="nav-text">1. 统一的花括号初始化（列表初始化 &#x2F; brace initialization）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E9%BB%98%E8%AE%A4%E6%88%90%E5%91%98%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%88default-member-initializers%EF%BC%89"><span class="nav-number">9.3.2.</span> <span class="nav-text">2. 默认成员初始化（default member initializers）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%A7%94%E6%89%98"><span class="nav-number">9.3.3.</span> <span class="nav-text">3. 构造函数委托</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E7%BB%9F%E4%B8%80%E5%88%9D%E5%A7%8B%E5%8C%96%E8%AF%AD%E6%B3%95%E4%B8%8E-std-initializer-list-%E6%9E%84%E9%80%A0"><span class="nav-number">9.3.4.</span> <span class="nav-text">4. 统一初始化语法与**std::initializer_list**构造</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-4-%E5%85%B6%E4%BB%96%E6%98%93%E7%94%A8%E6%80%A7%E6%94%B9%E8%BF%9B"><span class="nav-number">9.4.</span> <span class="nav-text">8.4 其他易用性改进</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E7%94%A8%E6%88%B7%E5%AE%9A%E4%B9%89%E5%AD%97%E9%9D%A2%E9%87%8F%EF%BC%88User-defined-Literal%EF%BC%89"><span class="nav-number">9.4.1.</span> <span class="nav-text">一、用户定义字面量（User-defined Literal）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E7%A4%BA%E4%BE%8B"><span class="nav-number">9.4.2.</span> <span class="nav-text">二、示例</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E8%B7%9D%E7%A6%BB%E5%8D%95%E4%BD%8D%EF%BC%88%E5%A6%82%E7%B1%B3%E3%80%81%E5%8D%83%E7%B1%B3%EF%BC%89"><span class="nav-number">9.4.2.1.</span> <span class="nav-text">1. 距离单位（如米、千米）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AD%97%E9%9D%A2%E9%87%8F"><span class="nav-number">9.4.2.2.</span> <span class="nav-text">2. 二进制字面量</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E5%8F%AF%E6%8E%A5%E5%8F%97%E7%9A%84%E5%8F%82%E6%95%B0%E7%B1%BB%E5%9E%8B"><span class="nav-number">9.4.3.</span> <span class="nav-text">三、可接受的参数类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9B%E3%80%81%E7%94%A8%E9%80%94%E5%92%8C%E5%A5%BD%E5%A4%84"><span class="nav-number">9.4.4.</span> <span class="nav-text">四、用途和好处</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%94%E3%80%81%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">9.4.5.</span> <span class="nav-text">五、注意事项</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#9-%E9%83%A8%E5%88%86%E5%85%B6%E4%BB%96%E6%96%B0%E7%89%B9%E6%80%A7"><span class="nav-number">10.</span> <span class="nav-text">9. 部分其他新特性</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#9-1-using-%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D%EF%BC%9B%E5%AE%9A%E5%AE%BD%E6%95%B4%E6%95%B0%E7%B1%BB%E5%9E%8B%EF%BC%9Benum-class%EF%BC%9Bbyte%EF%BC%9BUTF-%E5%AD%97%E7%AC%A6%E7%B1%BB%E5%9E%8B"><span class="nav-number">10.1.</span> <span class="nav-text">9.1 using 类型别名；定宽整数类型；enum class；byte；UTF 字符类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#using-%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D"><span class="nav-number">10.1.1.</span> <span class="nav-text">using 类型别名</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D%EF%BC%9F"><span class="nav-number">10.1.1.1.</span> <span class="nav-text">什么是类型别名？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%A8%E6%B3%951%EF%BC%9A%E4%BC%A0%E7%BB%9F%E5%86%99%E6%B3%95%EF%BC%88typedef%EF%BC%89"><span class="nav-number">10.1.1.2.</span> <span class="nav-text">用法1：传统写法（typedef）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8-using-%E6%9B%B4%E5%A5%BD%EF%BC%9F"><span class="nav-number">10.1.1.3.</span> <span class="nav-text">为什么用 using 更好？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%A8%E6%B3%952%EF%BC%9A%E6%A8%A1%E6%9D%BF%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D"><span class="nav-number">10.1.1.4.</span> <span class="nav-text">用法2：模板类型别名</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BE%E4%B8%AA%E4%BE%8B%E5%AD%90%E6%80%BB%E7%BB%93%EF%BC%9A"><span class="nav-number">10.1.1.5.</span> <span class="nav-text">举个例子总结：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%80%BB%E7%BB%93%E4%B8%80%E4%B8%8B%EF%BC%9A"><span class="nav-number">10.1.1.6.</span> <span class="nav-text">总结一下：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-2-tuple%E3%80%81tie-%E5%92%8C%E7%BB%93%E6%9E%84%E5%8C%96%E7%BB%91%E5%AE%9A%EF%BC%9B%E6%97%B6%E9%97%B4%E3%80%81%E9%9A%8F%E6%9C%BA%E6%95%B0%E3%80%81%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">10.2.</span> <span class="nav-text">9.2 tuple、tie 和结构化绑定；时间、随机数、正则表达式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-tuple%EF%BC%88%E5%85%83%E7%BB%84%EF%BC%89%EF%BC%9A%E5%83%8F%E4%B8%80%E4%B8%AA%E5%B0%8F%E5%9E%8B%E7%9A%84%E2%80%9C%E5%A4%9A%E5%85%83%E7%B4%A0%E5%AE%B9%E5%99%A8%E2%80%9D"><span class="nav-number">10.2.1.</span> <span class="nav-text">1. tuple（元组）：像一个小型的“多元素容器”</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-tuple%EF%BC%9F"><span class="nav-number">10.2.1.1.</span> <span class="nav-text">什么是 tuple？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%80%8E%E4%B9%88%E5%8F%96%E5%87%BA%E9%87%8C%E9%9D%A2%E7%9A%84%E5%80%BC%EF%BC%9F"><span class="nav-number">10.2.1.2.</span> <span class="nav-text">怎么取出里面的值？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-tie%EF%BC%9A%E7%BB%91%E5%AE%9A%E5%8F%98%E9%87%8F%EF%BC%8C%E7%94%A8%E6%9D%A5%E8%A7%A3%E5%8C%85%E5%85%83%E7%BB%84"><span class="nav-number">10.2.2.</span> <span class="nav-text">2. tie：绑定变量，用来解包元组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E7%BB%93%E6%9E%84%E5%8C%96%E7%BB%91%E5%AE%9A%EF%BC%88C-17%EF%BC%89%EF%BC%9A%E6%9B%B4%E7%AE%80%E5%8D%95%E5%9C%B0%E8%A7%A3%E5%8C%85"><span class="nav-number">10.2.3.</span> <span class="nav-text">3. 结构化绑定（C++17）：更简单地解包</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E6%97%B6%E9%97%B4%EF%BC%88%EF%BC%89"><span class="nav-number">10.2.4.</span> <span class="nav-text">4. 时间（&lt;chrono&gt;）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E6%97%B6%E9%97%B4%EF%BC%9A"><span class="nav-number">10.2.4.1.</span> <span class="nav-text">获取当前时间：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%A1%E6%97%B6%E5%99%A8%E4%BE%8B%E5%AD%90%EF%BC%9A"><span class="nav-number">10.2.4.2.</span> <span class="nav-text">计时器例子：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E9%9A%8F%E6%9C%BA%E6%95%B0%EF%BC%88%EF%BC%89"><span class="nav-number">10.2.5.</span> <span class="nav-text">5. 随机数（&lt;random&gt;）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%9F%E6%88%90%E4%B8%80%E4%B8%AA-1-%E5%88%B0-100-%E7%9A%84%E9%9A%8F%E6%9C%BA%E6%95%B4%E6%95%B0%EF%BC%9A"><span class="nav-number">10.2.5.1.</span> <span class="nav-text">生成一个 1 到 100 的随机整数：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%88%EF%BC%89"><span class="nav-number">10.2.6.</span> <span class="nav-text">6. 正则表达式（&lt;regex&gt;）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A3%80%E6%9F%A5%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%98%AF%E4%B8%8D%E6%98%AF-email%EF%BC%9A"><span class="nav-number">10.2.6.1.</span> <span class="nav-text">检查一个字符串是不是 email：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9F%A5%E6%89%BE%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E6%95%B0%E5%AD%97%EF%BC%9A"><span class="nav-number">10.2.6.2.</span> <span class="nav-text">查找字符串中的数字：</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#10-any%E3%80%81optional%E3%80%81variant-%E5%92%8C%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86"><span class="nav-number">11.</span> <span class="nav-text">10. any、optional、variant 和错误处理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#10-1-any-%E5%92%8C-optional"><span class="nav-number">11.1.</span> <span class="nav-text">10.1 any 和 optional</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-2-variant%EF%BC%9Bany%E3%80%81optional%E3%80%81variant-%E7%9A%84%E6%8E%A5%E5%8F%A3%E6%AF%94%E8%BE%83"><span class="nav-number">11.2.</span> <span class="nav-text">10.2 variant；any、optional、variant 的接口比较</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-3-%E6%A0%87%E5%87%86%E5%BA%93%E7%9A%84%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86"><span class="nav-number">11.3.</span> <span class="nav-text">10.3 标准库的错误处理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%8F%E8%8A%82%E8%87%AA%E6%B5%8B-3"><span class="nav-number">11.4.</span> <span class="nav-text">小节自测</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Yueht</p>
  <div class="site-description" itemprop="description">个人博客</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">11</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yueht</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>











<script>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : 'default',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>


  

  

  

</body>
</html>
