<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yueht23.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false,"animation":true,"content_length":400,"show_result":true,"show_result_on_focus":true,"auto_focus":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="1. C++的特点与演化为什么要用C++ 贴近硬件   零抽象开销，如果不适用抽象则没有额外抽象  C与C++ 功能上C++是C的超集，但是C代码不一定是合法的C++代码 C++更加严格和安全，例如const正确性 现代C++的惯用法和C大相径庭  C++的演进 C++98：开天辟地，第一套ISO标准 C++03：小幅修订，主要修复C++98的标准文本问题，无语言特性变化。   C++11：革命性">
<meta property="og:type" content="article">
<meta property="og:title" content="华为入职培训-现代cpp实战-2025">
<meta property="og:url" content="https://yueht23.github.io/2025/04/29/%E5%8D%8E%E4%B8%BA%E5%85%A5%E8%81%8C%E5%9F%B9%E8%AE%AD-%E7%8E%B0%E4%BB%A3cpp%E5%AE%9E%E6%88%98-2025/index.html">
<meta property="og:site_name" content="Yueht&#39;s Blog">
<meta property="og:description" content="1. C++的特点与演化为什么要用C++ 贴近硬件   零抽象开销，如果不适用抽象则没有额外抽象  C与C++ 功能上C++是C的超集，但是C代码不一定是合法的C++代码 C++更加严格和安全，例如const正确性 现代C++的惯用法和C大相径庭  C++的演进 C++98：开天辟地，第一套ISO标准 C++03：小幅修订，主要修复C++98的标准文本问题，无语言特性变化。   C++11：革命性">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://yueht23.github.io/images/1746961095204-image.png">
<meta property="og:image" content="https://yueht23.github.io/images/1746962209368-image.png">
<meta property="og:image" content="https://yueht23.github.io/images/1746962538602-image.png">
<meta property="og:image" content="https://yueht23.github.io/images/1746962827885-image.png">
<meta property="og:image" content="https://yueht23.github.io/images/1746962906840-image.png">
<meta property="og:image" content="https://yueht23.github.io/images/1747049713743-image.png">
<meta property="og:image" content="https://yueht23.github.io/images/1747049838519-image.png">
<meta property="og:image" content="https://yueht23.github.io/images/1747049854419-image.png">
<meta property="article:published_time" content="2025-04-29T11:18:09.000Z">
<meta property="article:modified_time" content="2025-05-12T11:56:23.077Z">
<meta property="article:author" content="Yueht">
<meta property="article:tag" content="cpp">
<meta property="article:tag" content="华为">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://yueht23.github.io/images/1746961095204-image.png">

<link rel="canonical" href="https://yueht23.github.io/2025/04/29/%E5%8D%8E%E4%B8%BA%E5%85%A5%E8%81%8C%E5%9F%B9%E8%AE%AD-%E7%8E%B0%E4%BB%A3cpp%E5%AE%9E%E6%88%98-2025/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>华为入职培训-现代cpp实战-2025 | Yueht's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">
<!-- hexo injector head_end end --></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Yueht's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://yueht23.github.io/2025/04/29/%E5%8D%8E%E4%B8%BA%E5%85%A5%E8%81%8C%E5%9F%B9%E8%AE%AD-%E7%8E%B0%E4%BB%A3cpp%E5%AE%9E%E6%88%98-2025/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yueht">
      <meta itemprop="description" content="个人博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yueht's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          华为入职培训-现代cpp实战-2025
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-04-29 19:18:09" itemprop="dateCreated datePublished" datetime="2025-04-29T19:18:09+08:00">2025-04-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-05-12 19:56:23" itemprop="dateModified" datetime="2025-05-12T19:56:23+08:00">2025-05-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%BD%AF%E4%BB%B6%E9%9B%8F%E9%B9%B0%E8%AE%A1%E5%88%92/" itemprop="url" rel="index"><span itemprop="name">软件雏鹰计划</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="1-C-的特点与演化"><a href="#1-C-的特点与演化" class="headerlink" title="1. C++的特点与演化"></a>1. C++的特点与演化</h1><h2 id="为什么要用C"><a href="#为什么要用C" class="headerlink" title="为什么要用C++"></a>为什么要用C++</h2><ul>
<li>贴近硬件  </li>
<li>零抽象开销，如果不适用抽象则没有额外抽象</li>
</ul>
<h2 id="C与C"><a href="#C与C" class="headerlink" title="C与C++"></a>C与C++</h2><ul>
<li>功能上C++是C的超集，但是C代码不一定是合法的C++代码</li>
<li>C++更加严格和安全，例如const正确性</li>
<li>现代C++的惯用法和C大相径庭</li>
</ul>
<h2 id="C-的演进"><a href="#C-的演进" class="headerlink" title="C++的演进"></a>C++的演进</h2><ul>
<li><strong>C++98</strong>：开天辟地，第一套ISO标准</li>
<li><strong>C++03</strong>：小幅修订，主要修复C++98的标准文本问题，无语言特性变化。  </li>
<li><strong>C++11</strong>：革命性升级，引入自动类型推导、右值引用、智能指针、Lambda表达式等现代特性。  </li>
<li><strong>C++14</strong>：完善C++11，增强泛型编程（泛型Lambda）、放宽<code>constexpr</code>限制等小改进。  </li>
<li><strong>C++17</strong>：聚焦简化代码，引入结构化绑定、<code>std::variant</code>、并行STL等实用特性。  </li>
<li><strong>C++20</strong>：迈向新时代，加入模块（Modules）、概念（Concepts）、协程（Coroutines）等重大特性。  </li>
<li><strong>C++23</strong>：增量改进，扩展标准库（<code>std::mdspan</code>、格式化库），优化已有功能（<code>if consteval</code>）。</li>
</ul>
<p><strong>我们主要关注C++17</strong></p>
<h2 id="c-委员会的工作方式"><a href="#c-委员会的工作方式" class="headerlink" title="c++委员会的工作方式"></a>c++委员会的工作方式</h2><ul>
<li>基于共识consensuse，至少80%的成员同意，才能通过提案</li>
<li>不是民主，少数服从多数</li>
<li>不是独裁，不是c++之父(Bjarne Stroustrup)说了算</li>
</ul>
<h1 id="2-资源管理和对象的基本规则"><a href="#2-资源管理和对象的基本规则" class="headerlink" title="2. 资源管理和对象的基本规则"></a>2. 资源管理和对象的基本规则</h1><h2 id="2-资源管理和对象的基本规则-1"><a href="#2-资源管理和对象的基本规则-1" class="headerlink" title="2. 资源管理和对象的基本规则"></a>2. 资源管理和对象的基本规则</h2><h3 id="堆与栈"><a href="#堆与栈" class="headerlink" title="堆与栈"></a>堆与栈</h3><p>内存中的 <strong>堆（Heap）</strong> 和 <strong>栈（Stack）</strong> 是程序运行时存储数据的两个重要区域，它们的特点和用途完全不同。用生活中的例子来类比：</p>
<h4 id="1-栈（Stack）——像“快餐店取餐盘”"><a href="#1-栈（Stack）——像“快餐店取餐盘”" class="headerlink" title="1. 栈（Stack）——像“快餐店取餐盘”"></a><strong>1. 栈（Stack）——像“快餐店取餐盘”</strong></h4><ul>
<li><strong>特点</strong>：<ul>
<li><strong>自动管理</strong>：系统自动分配和释放内存（比如函数调用时创建，函数结束自动清除）。</li>
<li><strong>速度快</strong>：内存分配是连续的，类似叠盘子（后进先出）。</li>
<li><strong>空间小</strong>：通常有固定大小（比如几MB），存储局部变量、函数参数等。</li>
</ul>
</li>
<li><strong>例子</strong>：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>; <span class="comment">// x 存储在栈上，函数结束后自动释放</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>缺点</strong>：不能灵活存储大量数据或长期保存数据。</li>
</ul>
<h4 id="2-堆（Heap）——像“自助仓库”"><a href="#2-堆（Heap）——像“自助仓库”" class="headerlink" title="2. 堆（Heap）——像“自助仓库”"></a><strong>2. 堆（Heap）——像“自助仓库”</strong></h4><ul>
<li><strong>特点</strong>：<ul>
<li><strong>手动管理</strong>：需要程序员主动申请（如 <code>malloc</code>、<code>new</code>）和释放（如 <code>free</code>、<code>delete</code>）。</li>
<li><strong>速度慢</strong>：内存分配不连续，需要动态查找可用空间。</li>
<li><strong>空间大</strong>：可用空间通常远大于栈，适合存放大数据或长期存在的数据。</li>
</ul>
</li>
<li><strong>例子</strong>：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p = <span class="built_in">malloc</span>(<span class="number">100</span> * <span class="keyword">sizeof</span>(<span class="type">int</span>)); <span class="comment">// 在堆上申请100个int的空间</span></span><br><span class="line"><span class="built_in">free</span>(p); <span class="comment">// 用完必须手动释放，否则会内存泄漏！</span></span><br></pre></td></tr></table></figure></li>
<li><strong>缺点</strong>：忘记释放会导致内存泄漏，管理不当可能产生碎片。</li>
</ul>
<h4 id="关键区别总结"><a href="#关键区别总结" class="headerlink" title="关键区别总结"></a><strong>关键区别总结</strong></h4><table>
<thead>
<tr>
<th>特性</th>
<th>栈（Stack）</th>
<th>堆（Heap）</th>
</tr>
</thead>
<tbody><tr>
<td><strong>管理方式</strong></td>
<td>自动分配&#x2F;释放</td>
<td>手动申请&#x2F;释放</td>
</tr>
<tr>
<td><strong>速度</strong></td>
<td>快（连续内存）</td>
<td>慢（需动态分配）</td>
</tr>
<tr>
<td><strong>大小</strong></td>
<td>较小（默认几MB）</td>
<td>较大（取决于系统内存）</td>
</tr>
<tr>
<td><strong>用途</strong></td>
<td>局部变量、函数调用</td>
<td>动态数据（如对象、数组）</td>
</tr>
<tr>
<td><strong>风险</strong></td>
<td>栈溢出（递归太深）</td>
<td>内存泄漏、碎片化</td>
</tr>
</tbody></table>
<h4 id="通俗比喻"><a href="#通俗比喻" class="headerlink" title="通俗比喻"></a><strong>通俗比喻</strong></h4><ul>
<li><strong>栈</strong>：像快餐店的取餐盘——随取随用，吃完立刻收走，但容量有限。</li>
<li><strong>堆</strong>：像租仓库——自己申请空间，随时存放杂物，但忘记退租会白花钱（内存泄漏）。</li>
</ul>
<h4 id="名称来源"><a href="#名称来源" class="headerlink" title="名称来源"></a>名称来源</h4><ul>
<li>栈（Stack）：名字来自“堆叠”，强调自动、顺序的特性（像叠盘子）。</li>
<li>堆（Heap）：名字来自“杂乱堆积”，强调动态、不连续的特性（像杂物堆），<strong>与优先队列无关</strong></li>
</ul>
<h3 id="RAII-Resource-Acquisition-Is-Initialization"><a href="#RAII-Resource-Acquisition-Is-Initialization" class="headerlink" title="RAII&#x2F;Resource Acquisition Is Initialization"></a>RAII&#x2F;Resource Acquisition Is Initialization</h3><p>RAII：资源获取即初始化，资源释放即销毁，即在构造函数中申请资源，在析构函数中释放资源，主要用于管理堆上的资源。<br>通俗解释：</p>
<ul>
<li>获取即管理：在构造函数（对象创建时）申请资源（如内存、文件、锁等）。</li>
<li>离开作用域自动释放：当对象离开作用域（如函数结束、代码块退出）时，析构函数自动调用，释放资源。</li>
</ul>
<hr>
<p>为什么用 RAII？</p>
<ul>
<li>防泄漏：资源自动释放，避免忘记 fclose&#x2F;free。</li>
<li>防异常崩溃：即使代码抛出异常，析构函数仍会调用。</li>
<li>代码简洁：无需手动管理资源生命周期。</li>
</ul>
<h3 id="对象的拷贝和移动"><a href="#对象的拷贝和移动" class="headerlink" title="对象的拷贝和移动"></a>对象的拷贝和移动</h3><p>C++会默认提供对象的拷贝构造和移动构造函数，但是其默认行为可能不是你想要的，需要注意其可能产生问题：</p>
<ul>
<li><ol>
<li>默认拷贝构造函数的问题</li>
</ol>
<ul>
<li>默认拷贝构造函数会逐个复制类的成员变量（浅拷贝），但如果类管理动态资源（如堆内存、文件句柄、锁等），会导致：</li>
<li>重复释放：两个对象指向同一块内存，析构时会被释放两次（崩溃）。</li>
<li>数据共享：修改一个对象会影响另一个对象（非预期行为）。</li>
</ul>
</li>
<li><ol start="2">
<li>默认移动构造函数的问题</li>
</ol>
<ul>
<li>默认移动构造函数会逐个移动类的成员变量（对指针等简单类型直接复制值），但如果类管理资源：</li>
<li>资源泄漏：移动后，原对象仍持有资源指针（可能导致析构时意外释放）。</li>
<li>悬空指针：移动后的原对象处于无效状态，但可能被误用。</li>
</ul>
</li>
</ul>
<h3 id="对象的特殊成员函数"><a href="#对象的特殊成员函数" class="headerlink" title="对象的特殊成员函数"></a>对象的特殊成员函数</h3><h3 id="C-对象的特殊成员函数总结表"><a href="#C-对象的特殊成员函数总结表" class="headerlink" title="C++ 对象的特殊成员函数总结表"></a><strong>C++ 对象的特殊成员函数总结表</strong></h3><p>以下是 C++ 中类（<code>class</code>&#x2F;<code>struct</code>）的 <strong>特殊成员函数（Special Member Functions）</strong>，它们在特定条件下由编译器自动生成，但也可以手动定义或禁用。  </p>
<table>
<thead>
<tr>
<th>特殊成员函数</th>
<th>自动生成条件（默认）</th>
<th>用途说明</th>
<th>常见自定义场景</th>
</tr>
</thead>
<tbody><tr>
<td><strong>默认构造函数</strong><br><code>ClassName()</code></td>
<td>如果<strong>没有定义任何构造函数</strong></td>
<td>初始化对象（无参构造）</td>
<td>需要自定义初始化逻辑（如资源分配）</td>
</tr>
<tr>
<td><strong>析构函数</strong><br><code>~ClassName()</code></td>
<td>总是自动生成</td>
<td>对象销毁时自动调用，用于释放资源</td>
<td>管理动态内存、文件、锁等资源时需手动定义</td>
</tr>
<tr>
<td><strong>拷贝构造函数</strong><br><code>ClassName(const ClassName&amp;)</code></td>
<td>如果<strong>没有定义移动操作和拷贝赋值</strong></td>
<td>用同类型对象初始化新对象（深拷贝&#x2F;浅拷贝）</td>
<td>管理资源时需要<strong>深拷贝</strong>（如 <code>std::string</code>）</td>
</tr>
<tr>
<td><strong>拷贝赋值运算符</strong><br><code>ClassName&amp; operator=(const ClassName&amp;)</code></td>
<td>如果<strong>没有定义移动操作和拷贝构造</strong></td>
<td>用同类型对象赋值给已存在对象</td>
<td>同拷贝构造函数，需处理自我赋值和资源释放</td>
</tr>
<tr>
<td><strong>移动构造函数</strong><br><code>ClassName(ClassName&amp;&amp;)</code></td>
<td>如果<strong>没有定义拷贝操作、移动赋值和析构函数</strong></td>
<td>用右值（临时对象）初始化新对象（高效转移资源）</td>
<td>管理资源时需<strong>转移所有权</strong>（如 <code>std::unique_ptr</code>）</td>
</tr>
<tr>
<td><strong>移动赋值运算符</strong><br><code>ClassName&amp; operator=(ClassName&amp;&amp;)</code></td>
<td>如果<strong>没有定义拷贝操作、移动构造和析构函数</strong></td>
<td>用右值（临时对象）赋值给已存在对象</td>
<td>同移动构造函数，需处理自我赋值</td>
</tr>
</tbody></table>
<p> <strong>示例代码</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Resource</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Resource</span>() = <span class="keyword">default</span>;                          <span class="comment">// 默认构造函数</span></span><br><span class="line">    ~<span class="built_in">Resource</span>() &#123; <span class="comment">/* 释放资源 */</span> &#125;                 <span class="comment">// 析构函数</span></span><br><span class="line">    <span class="built_in">Resource</span>(<span class="type">const</span> Resource&amp;) &#123; <span class="comment">/* 深拷贝逻辑 */</span> &#125;  <span class="comment">// 拷贝构造</span></span><br><span class="line">    Resource&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Resource&amp;) &#123; <span class="comment">/* 拷贝赋值逻辑 */</span> <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">    <span class="built_in">Resource</span>(Resource&amp;&amp;) <span class="keyword">noexcept</span> &#123; <span class="comment">/* 移动资源 */</span> &#125; <span class="comment">// 移动构造</span></span><br><span class="line">    Resource&amp; <span class="keyword">operator</span>=(Resource&amp;&amp;) <span class="keyword">noexcept</span> &#123; <span class="comment">/* 移动赋值逻辑 */</span> <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="一句话总结"><a href="#一句话总结" class="headerlink" title="一句话总结"></a><strong>一句话总结</strong></h3><ul>
<li><strong>默认生成的函数可能不安全</strong>（尤其是管理资源时）。</li>
<li><strong>规则口诀</strong>：  <ul>
<li>定义拷贝 → 无移动；定义移动 → 无拷贝；定义析构 → 无移动（但保留拷贝）。  </li>
<li>用 <code>= default</code> 或 <code>= delete</code> 显式控制行为。</li>
</ul>
</li>
</ul>
<h3 id="三法则"><a href="#三法则" class="headerlink" title="三法则"></a>三法则</h3><p>如果一个类需要手动定义以下 任意一个 特殊成员函数，那么通常需要同时定义 全部三个：</p>
<ul>
<li>析构函数（释放资源）</li>
<li>拷贝构造函数（深拷贝资源）</li>
<li>拷贝赋值运算符（处理赋值时的资源释放和拷贝）</li>
</ul>
<h1 id="3-移动语义与右值引用"><a href="#3-移动语义与右值引用" class="headerlink" title="3. 移动语义与右值引用"></a>3. 移动语义与右值引用</h1><h2 id="3-移动语义与右值引用-1"><a href="#3-移动语义与右值引用-1" class="headerlink" title="3. 移动语义与右值引用"></a>3. 移动语义与右值引用</h2><h3 id="C-的值类别-Value-Categories"><a href="#C-的值类别-Value-Categories" class="headerlink" title="C++ 的值类别 (Value Categories)"></a>C++ 的值类别 (Value Categories)</h3><p>在 C++ 中，每个表达式都有一个值类别，它决定了表达式如何与内存交互以及可以被如何使用。C++11 引入了新的值类别系统，取代了传统的左值&#x2F;右值分类。</p>
<p>C++ 中的值类别分为两大类，共五种：</p>
<h4 id="1-左值-lvalue"><a href="#1-左值-lvalue" class="headerlink" title="1. 左值 (lvalue)"></a>1. 左值 (lvalue)</h4><ul>
<li>可以取地址的表达式</li>
<li>有持久性（生命周期超出表达式）</li>
<li>可以出现在赋值运算符的左侧</li>
<li>示例：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">10</span>;  <span class="comment">// x 是左值</span></span><br><span class="line"><span class="type">int</span>&amp; ref = x; <span class="comment">// ref 是左值引用</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="2-纯右值-prvalue-pure-rvalue"><a href="#2-纯右值-prvalue-pure-rvalue" class="headerlink" title="2. 纯右值 (prvalue, pure rvalue)"></a>2. 纯右值 (prvalue, pure rvalue)</h4><ul>
<li>临时对象或字面量</li>
<li>没有持久性（通常在表达式结束时被销毁）</li>
<li>不能出现在赋值运算符的左侧</li>
<li>不能取地址</li>
<li>示例：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">42</span>          <span class="comment">// 字面量是纯右值</span></span><br><span class="line">x + <span class="number">5</span>       <span class="comment">// 表达式结果是纯右值</span></span><br><span class="line">std::<span class="built_in">string</span>(<span class="string">&quot;hello&quot;</span>) <span class="comment">// 临时对象是纯右值</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="3-将亡值-xvalue-expiring-value"><a href="#3-将亡值-xvalue-expiring-value" class="headerlink" title="3. 将亡值 (xvalue, expiring value)"></a>3. 将亡值 (xvalue, expiring value)</h4><ul>
<li>即将被移动的对象</li>
<li>可以被资源”窃取”</li>
<li>示例：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="built_in">move</span>(x) <span class="comment">// std::move 返回将亡值</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="复合类别"><a href="#复合类别" class="headerlink" title="复合类别"></a>复合类别</h4><h5 id="广义左值-glvalue-generalized-lvalue"><a href="#广义左值-glvalue-generalized-lvalue" class="headerlink" title="广义左值 (glvalue, generalized lvalue)"></a>广义左值 (glvalue, generalized lvalue)</h5><ul>
<li>包括左值和将亡值</li>
<li>有标识（可以确定对象身份）</li>
</ul>
<h5 id="右值-rvalue"><a href="#右值-rvalue" class="headerlink" title="右值 (rvalue)"></a>右值 (rvalue)</h5><ul>
<li>包括纯右值和将亡值</li>
<li>可以被移动</li>
</ul>
<p>关系图</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">        expression</span><br><span class="line">        /        \</span><br><span class="line">     glvalue    rvalue</span><br><span class="line">    /      \    /    \</span><br><span class="line">lvalue     xvalue    prvalue</span><br></pre></td></tr></table></figure>
<p><img src="/../images/1746961095204-image.png" alt="alt text"></p>
<h4 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h4><ol>
<li><p><strong>引用绑定规则</strong>：</p>
<ul>
<li>左值引用 (<code>T&amp;</code>) 只能绑定到左值</li>
<li>常量左值引用 (<code>const T&amp;</code>) 可以绑定到所有值类别</li>
<li>右值引用 (<code>T&amp;&amp;</code>) 只能绑定到右值</li>
</ul>
</li>
<li><p><strong>移动语义</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(std::string&amp;&amp; str)</span></span>; <span class="comment">// 只接受右值</span></span><br><span class="line"></span><br><span class="line">std::string s = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="built_in">process</span>(std::<span class="built_in">move</span>(s)); <span class="comment">// 将左值转为右值</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>完美转发</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">wrapper</span><span class="params">(T&amp;&amp; arg)</span> </span>&#123; <span class="comment">// 通用引用</span></span><br><span class="line">    <span class="built_in">process</span>(std::forward&lt;T&gt;(arg)); <span class="comment">// 保持值类别</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>理解值类别对于编写高效的现代 C++ 代码至关重要，特别是在涉及移动语义和完美转发时。</p>
<h3 id="移动的实现和意义"><a href="#移动的实现和意义" class="headerlink" title="移动的实现和意义"></a>移动的实现和意义</h3><ul>
<li>允许资源的传递</li>
<li>允许返回大对象和容器<ul>
<li>一般同时使用异常来表示错误<br>其意义在于：</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string str = <span class="built_in">string</span>(<span class="string">&quot;hello&quot;</span>) + name + <span class="string">&quot;!&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>如果没有移动语义的话，上述代码会生成临时对象，然后进行字符串拼接，最后再销毁临时对象。</p>
<h3 id="移动和noexcept"><a href="#移动和noexcept" class="headerlink" title="移动和noexcept"></a>移动和noexcept</h3><p>下列成员函数不允许抛出异常，否则编译器会报错。</p>
<ul>
<li>析构</li>
<li><strong>移动构造函数</strong></li>
<li><strong>移动赋值运算符</strong></li>
<li>交换函数</li>
</ul>
<h3 id="对象的生命期"><a href="#对象的生命期" class="headerlink" title="对象的生命期"></a>对象的生命期</h3><p><img src="/../images/1746962209368-image.png" alt="alt text"></p>
<h3 id="转发引用"><a href="#转发引用" class="headerlink" title="转发引用"></a>转发引用</h3><p>转发引用是C++11引入的一种特殊引用类型，也称为”万能引用”(Universal Reference)。它能够根据传入的参数类型自动推导为左值引用或右值引用。<br>转发引用主要用于完美转发(perfect forwarding)，即保持参数原始值类别(左值&#x2F;右值)传递到下层函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">wrapper</span><span class="params">(T&amp;&amp; arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用std::forward保持arg的原始值类别</span></span><br><span class="line">    <span class="built_in">some_function</span>(std::forward&lt;T&gt;(arg));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="五法则"><a href="#五法则" class="headerlink" title="五法则"></a>五法则</h3><p>C++的五法则是对三法则（Rule of Three）的扩展，适用于现代C++（C++11及以后版本）。它指出如果一个类需要显式定义以下任何一个特殊成员函数，那么它通常需要显式定义所有这五个函数：</p>
<ol>
<li>析构函数（Destructor）</li>
<li>拷贝构造函数（Copy constructor）</li>
<li>拷贝赋值运算符（Copy assignment operator）</li>
<li>移动构造函数（Move constructor）</li>
<li>移动赋值运算符（Move assignment operator）</li>
</ol>
<h4 id="五法则的背景"><a href="#五法则的背景" class="headerlink" title="五法则的背景"></a>五法则的背景</h4><p>在C++11引入移动语义之前，只有三法则（析构函数、拷贝构造函数、拷贝赋值运算符）。随着移动语义的加入，管理资源的类现在也需要考虑移动操作。</p>
<h4 id="为什么需要五法则"><a href="#为什么需要五法则" class="headerlink" title="为什么需要五法则"></a>为什么需要五法则</h4><p>当一个类管理资源（如动态内存、文件句柄等）时，编译器生成的默认特殊成员函数可能无法正确管理这些资源。如果你定义了其中任何一个函数，通常意味着你需要自定义资源管理，因此需要定义所有五个函数以确保资源在所有情况下都被正确处理。</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ResourceHolder</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 1. 构造函数</span></span><br><span class="line">    <span class="built_in">ResourceHolder</span>(<span class="type">size_t</span> size) : <span class="built_in">data</span>(<span class="keyword">new</span> <span class="type">int</span>[size]), <span class="built_in">size</span>(size) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 析构函数</span></span><br><span class="line">    ~<span class="built_in">ResourceHolder</span>() &#123; <span class="keyword">delete</span>[] data; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 拷贝构造函数</span></span><br><span class="line">    <span class="built_in">ResourceHolder</span>(<span class="type">const</span> ResourceHolder&amp; other) </span><br><span class="line">        : <span class="built_in">data</span>(<span class="keyword">new</span> <span class="type">int</span>[other.size]), <span class="built_in">size</span>(other.size) &#123;</span><br><span class="line">        std::<span class="built_in">copy</span>(other.data, other.data + other.size, data);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4. 拷贝赋值运算符</span></span><br><span class="line">    ResourceHolder&amp; <span class="keyword">operator</span>=(<span class="type">const</span> ResourceHolder&amp; other) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other) &#123;</span><br><span class="line">            <span class="keyword">delete</span>[] data;</span><br><span class="line">            data = <span class="keyword">new</span> <span class="type">int</span>[other.size];</span><br><span class="line">            size = other.size;</span><br><span class="line">            std::<span class="built_in">copy</span>(other.data, other.data + other.size, data);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 5. 移动构造函数</span></span><br><span class="line">    <span class="built_in">ResourceHolder</span>(ResourceHolder&amp;&amp; other) <span class="keyword">noexcept</span> </span><br><span class="line">        : <span class="built_in">data</span>(other.data), <span class="built_in">size</span>(other.size) &#123;</span><br><span class="line">        other.data = <span class="literal">nullptr</span>;</span><br><span class="line">        other.size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 6. 移动赋值运算符</span></span><br><span class="line">    ResourceHolder&amp; <span class="keyword">operator</span>=(ResourceHolder&amp;&amp; other) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other) &#123;</span><br><span class="line">            <span class="keyword">delete</span>[] data;</span><br><span class="line">            data = other.data;</span><br><span class="line">            size = other.size;</span><br><span class="line">            other.data = <span class="literal">nullptr</span>;</span><br><span class="line">            other.size = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span>* data;</span><br><span class="line">    <span class="type">size_t</span> size;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="例外情况"><a href="#例外情况" class="headerlink" title="例外情况"></a>例外情况</h4><p>在某些情况下，你可能不需要全部五个函数：</p>
<ul>
<li>如果类不需要移动语义，三法则仍然适用</li>
<li>如果类是不可拷贝的（如单例模式），你可能只需要析构函数和删除拷贝操作</li>
</ul>
<h4 id="现代C-的替代方案"><a href="#现代C-的替代方案" class="headerlink" title="现代C++的替代方案"></a>现代C++的替代方案</h4><p>使用RAII（资源获取即初始化）原则和智能指针（如<code>std::unique_ptr</code>、<code>std::shared_ptr</code>）可以避免手动实现五法则，因为智能指针已经正确处理了这些操作。</p>
<h2 id="小节自测"><a href="#小节自测" class="headerlink" title="小节自测"></a>小节自测</h2><p><img src="/../images/1746962538602-image.png" alt="alt text"><br>在C++中，左值（lvalue）是指那些可以出现在赋值语句左侧的表达式，它们通常代表一个具有明确内存位置的对象。右值（rvalue）则是临时对象或字面量，不能出现在赋值语句的左侧。<br>让我们逐一分析选项：</p>
<ul>
<li><p><strong>A. ++x</strong><br><code>++x</code> 是前置递增操作，它先增加 <code>x</code> 的值，然后返回 <code>x</code> 本身（作为左值）。因此，<code>++x</code> 是一个左值。</p>
</li>
<li><p><strong>B. x++</strong><br><code>x++</code> 是后置递增操作，它先返回 <code>x</code> 的当前值（作为临时对象），然后再增加 <code>x</code> 的值。因此，<code>x++</code> 是一个右值，而不是左值。</p>
</li>
<li><p><strong>C. “hello world”</strong><br>字符串字面量 <code>&quot;hello world&quot;</code> 是一个左值，因为它是一个具有确定内存位置的字符数组（尽管不可修改）。</p>
</li>
<li><p><strong>D. 函数名字</strong><br>函数名字是一个左值，因为它代表一个具体的函数实体，具有明确的内存地址。</p>
</li>
</ul>
<p>因此，<strong>B. x++</strong> 是唯一不是左值的选项。</p>
<p><img src="/../images/1746962827885-image.png" alt="alt text"><br>在C++中，<code>&amp;&amp;</code> 表示右值引用（rvalue reference），它是C++11引入的重要特性，主要用于实现移动语义和完美转发。我们逐一分析选项：</p>
<ul>
<li><p><strong>A. 右值引用通常使用类型名称加 <code>&amp;&amp;</code> 的方式表示。</strong><br>这是正确的。例如，<code>int&amp;&amp;</code> 表示一个右值引用，绑定到临时对象或可移动的对象。</p>
</li>
<li><p><strong>B. <code>T&amp;&amp;</code> 这样的类型代表一个右值引用。</strong><br>这<strong>不完全正确</strong>，因为在模板或 <code>auto&amp;&amp;</code> 推导时，<code>T&amp;&amp;</code> 可能是右值引用，但也可能是<strong>转发引用（universal reference）</strong>，具体取决于上下文。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(T&amp;&amp; arg)</span></span>;  <span class="comment">// arg 可能是右值引用或左值引用（转发引用）</span></span><br></pre></td></tr></table></figure>
<p>只有在明确类型（如 <code>int&amp;&amp;</code>）时，<code>&amp;&amp;</code> 才一定是右值引用。</p>
</li>
<li><p><strong>C. 函数直接返回一个对象可以匹配相应的右值引用。</strong><br>这是正确的。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::string <span class="title">getString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>; &#125;</span><br><span class="line">std::string&amp;&amp; s = <span class="built_in">getString</span>();  <span class="comment">// 正确：getString() 返回临时对象（右值）</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>D. 函数要返回对象，通常不应该使用 <code>T&amp;&amp;</code> 这样的返回值。</strong><br>这是正确的。返回 <code>T&amp;&amp;</code> 通常用于特殊场景（如 <code>std::move</code> 或 <code>std::forward</code>），一般函数直接返回对象时，应返回值（<code>T</code>）或引用（<code>T&amp;</code>&#x2F;<code>const T&amp;</code>），而非 <code>T&amp;&amp;</code>。<br><strong>B</strong> 的描述不严谨，因为 <code>T&amp;&amp;</code> 不一定是右值引用（可能是转发引用）。因此，<strong>B 是不正确的选项</strong>。</p>
</li>
</ul>
<p><img src="/../images/1746962906840-image.png" alt="alt text"><br>B 的说法是错误的，因为定义其中一个特殊成员函数并不会强制要求定义其他函数，也不会导致编译错误。五法则是一个编程规范，而非语言强制规则。</p>
<h1 id="4-智能指针"><a href="#4-智能指针" class="headerlink" title="4. 智能指针"></a>4. 智能指针</h1><h2 id="4-智能指针-1"><a href="#4-智能指针-1" class="headerlink" title="4. 智能指针"></a>4. 智能指针</h2><ul>
<li>auto_ptr和unique_ptr</li>
<li>shared_ptr和weak_ptr</li>
<li>make_shared和make_unique 两个帮助函数</li>
</ul>
<p>智能指针是C++中的一种对象，它像普通指针一样工作，但能自动管理内存，防止内存泄漏。简单来说，它们是”聪明”的指针，能自己清理内存。</p>
<h3 id="主要类型"><a href="#主要类型" class="headerlink" title="主要类型"></a>主要类型</h3><ol>
<li><p><strong>unique_ptr</strong> - 唯一指针</p>
<ul>
<li>同一时间只能有一个unique_ptr指向某个对象</li>
<li>当指针被销毁时，它指向的对象也会自动删除</li>
<li>不能复制，但可以移动</li>
</ul>
</li>
<li><p><strong>shared_ptr</strong> - 共享指针</p>
<ul>
<li>多个shared_ptr可以指向同一个对象</li>
<li>内部有引用计数，记录有多少指针指向该对象</li>
<li>当最后一个指针销毁时，对象才会被删除</li>
</ul>
</li>
<li><p><strong>weak_ptr</strong> - 弱指针</p>
<ul>
<li>配合shared_ptr使用，不增加引用计数</li>
<li>用于解决shared_ptr的循环引用问题</li>
</ul>
</li>
</ol>
<h3 id="为什么用智能指针？"><a href="#为什么用智能指针？" class="headerlink" title="为什么用智能指针？"></a>为什么用智能指针？</h3><ul>
<li>自动释放内存，避免忘记delete</li>
<li>防止内存泄漏</li>
<li>更安全的代码，减少悬空指针问题</li>
<li>让内存管理更简单</li>
</ul>
<h3 id="简单例子"><a href="#简单例子" class="headerlink" title="简单例子"></a>简单例子</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// unique_ptr示例</span></span><br><span class="line"><span class="function">std::unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">10</span>))</span></span>; <span class="comment">// 创建</span></span><br><span class="line">*p1 = <span class="number">20</span>; <span class="comment">// 使用</span></span><br><span class="line"><span class="comment">// 不需要手动delete，离开作用域自动释放</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// shared_ptr示例</span></span><br><span class="line">std::shared_ptr&lt;<span class="type">int</span>&gt; p2 = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">30</span>);</span><br><span class="line"><span class="keyword">auto</span> p3 = p2; <span class="comment">// 现在p2和p3共享同一个对象</span></span><br></pre></td></tr></table></figure>

<p>智能指针让C++内存管理变得更简单、更安全！</p>
<h3 id="使用建议"><a href="#使用建议" class="headerlink" title="使用建议"></a>使用建议</h3><p><img src="/../images/1747049713743-image.png" alt="alt text"></p>
<h2 id="小节自测-1"><a href="#小节自测-1" class="headerlink" title="小节自测"></a>小节自测</h2><p><img src="/../images/1747049838519-image.png" alt="alt text"><br><img src="/../images/1747049854419-image.png" alt="alt text"><br>B. 错误：赋值时不需要显式使用 std::move，因为函数返回的 unique_ptr 已经是右值，会自动移动。显式使用 std::move 是多余的（尽管语法上不会报错）。</p>
<h1 id="5-容器和类容器"><a href="#5-容器和类容器" class="headerlink" title="5. 容器和类容器"></a>5. 容器和类容器</h1><h2 id="5-1-string；序列容器"><a href="#5-1-string；序列容器" class="headerlink" title="5.1 string；序列容器"></a>5.1 string；序列容器</h2><h2 id="5-2-关联容器和无序关联容器"><a href="#5-2-关联容器和无序关联容器" class="headerlink" title="5.2 关联容器和无序关联容器"></a>5.2 关联容器和无序关联容器</h2><h2 id="小节自测-2"><a href="#小节自测-2" class="headerlink" title="小节自测"></a>小节自测</h2><h1 id="6-迭代器和循环"><a href="#6-迭代器和循环" class="headerlink" title="6. 迭代器和循环"></a>6. 迭代器和循环</h1><h2 id="6-迭代器和循环-1"><a href="#6-迭代器和循环-1" class="headerlink" title="6. 迭代器和循环"></a>6. 迭代器和循环</h2><h2 id="小节自测-3"><a href="#小节自测-3" class="headerlink" title="小节自测"></a>小节自测</h2><h1 id="7-对象返回和异常"><a href="#7-对象返回和异常" class="headerlink" title="7. 对象返回和异常"></a>7. 对象返回和异常</h1><h2 id="7-1-返回值优化和对象返回"><a href="#7-1-返回值优化和对象返回" class="headerlink" title="7.1 返回值优化和对象返回"></a>7.1 返回值优化和对象返回</h2><h2 id="7-2-异常的得失和相关建议"><a href="#7-2-异常的得失和相关建议" class="headerlink" title="7.2 异常的得失和相关建议"></a>7.2 异常的得失和相关建议</h2><h2 id="小节自测-4"><a href="#小节自测-4" class="headerlink" title="小节自测"></a>小节自测</h2>
    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/cpp/" rel="tag"># cpp</a>
              <a href="/tags/%E5%8D%8E%E4%B8%BA/" rel="tag"># 华为</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2025/04/29/%E5%8D%8E%E4%B8%BA%E5%85%A5%E8%81%8C%E5%9F%B9%E8%AE%AD-%E5%BC%80%E5%8F%91%E8%80%85%E6%B5%8B%E8%AF%95/" rel="prev" title="华为入职培训-开发者测试">
      <i class="fa fa-chevron-left"></i> 华为入职培训-开发者测试
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-C-%E7%9A%84%E7%89%B9%E7%82%B9%E4%B8%8E%E6%BC%94%E5%8C%96"><span class="nav-number">1.</span> <span class="nav-text">1. C++的特点与演化</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8C"><span class="nav-number">1.1.</span> <span class="nav-text">为什么要用C++</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C%E4%B8%8EC"><span class="nav-number">1.2.</span> <span class="nav-text">C与C++</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-%E7%9A%84%E6%BC%94%E8%BF%9B"><span class="nav-number">1.3.</span> <span class="nav-text">C++的演进</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#c-%E5%A7%94%E5%91%98%E4%BC%9A%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%96%B9%E5%BC%8F"><span class="nav-number">1.4.</span> <span class="nav-text">c++委员会的工作方式</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%A7%84%E5%88%99"><span class="nav-number">2.</span> <span class="nav-text">2. 资源管理和对象的基本规则</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%A7%84%E5%88%99-1"><span class="nav-number">2.1.</span> <span class="nav-text">2. 资源管理和对象的基本规则</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A0%86%E4%B8%8E%E6%A0%88"><span class="nav-number">2.1.1.</span> <span class="nav-text">堆与栈</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E6%A0%88%EF%BC%88Stack%EF%BC%89%E2%80%94%E2%80%94%E5%83%8F%E2%80%9C%E5%BF%AB%E9%A4%90%E5%BA%97%E5%8F%96%E9%A4%90%E7%9B%98%E2%80%9D"><span class="nav-number">2.1.1.1.</span> <span class="nav-text">1. 栈（Stack）——像“快餐店取餐盘”</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E5%A0%86%EF%BC%88Heap%EF%BC%89%E2%80%94%E2%80%94%E5%83%8F%E2%80%9C%E8%87%AA%E5%8A%A9%E4%BB%93%E5%BA%93%E2%80%9D"><span class="nav-number">2.1.1.2.</span> <span class="nav-text">2. 堆（Heap）——像“自助仓库”</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B3%E9%94%AE%E5%8C%BA%E5%88%AB%E6%80%BB%E7%BB%93"><span class="nav-number">2.1.1.3.</span> <span class="nav-text">关键区别总结</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%9A%E4%BF%97%E6%AF%94%E5%96%BB"><span class="nav-number">2.1.1.4.</span> <span class="nav-text">通俗比喻</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%8D%E7%A7%B0%E6%9D%A5%E6%BA%90"><span class="nav-number">2.1.1.5.</span> <span class="nav-text">名称来源</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RAII-Resource-Acquisition-Is-Initialization"><span class="nav-number">2.1.2.</span> <span class="nav-text">RAII&#x2F;Resource Acquisition Is Initialization</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%8B%B7%E8%B4%9D%E5%92%8C%E7%A7%BB%E5%8A%A8"><span class="nav-number">2.1.3.</span> <span class="nav-text">对象的拷贝和移动</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%89%B9%E6%AE%8A%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="nav-number">2.1.4.</span> <span class="nav-text">对象的特殊成员函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C-%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%89%B9%E6%AE%8A%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E6%80%BB%E7%BB%93%E8%A1%A8"><span class="nav-number">2.1.5.</span> <span class="nav-text">C++ 对象的特殊成员函数总结表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E5%8F%A5%E8%AF%9D%E6%80%BB%E7%BB%93"><span class="nav-number">2.1.6.</span> <span class="nav-text">一句话总结</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%89%E6%B3%95%E5%88%99"><span class="nav-number">2.1.7.</span> <span class="nav-text">三法则</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89%E4%B8%8E%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8"><span class="nav-number">3.</span> <span class="nav-text">3. 移动语义与右值引用</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89%E4%B8%8E%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8-1"><span class="nav-number">3.1.</span> <span class="nav-text">3. 移动语义与右值引用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#C-%E7%9A%84%E5%80%BC%E7%B1%BB%E5%88%AB-Value-Categories"><span class="nav-number">3.1.1.</span> <span class="nav-text">C++ 的值类别 (Value Categories)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E5%B7%A6%E5%80%BC-lvalue"><span class="nav-number">3.1.1.1.</span> <span class="nav-text">1. 左值 (lvalue)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E7%BA%AF%E5%8F%B3%E5%80%BC-prvalue-pure-rvalue"><span class="nav-number">3.1.1.2.</span> <span class="nav-text">2. 纯右值 (prvalue, pure rvalue)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E5%B0%86%E4%BA%A1%E5%80%BC-xvalue-expiring-value"><span class="nav-number">3.1.1.3.</span> <span class="nav-text">3. 将亡值 (xvalue, expiring value)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%8D%E5%90%88%E7%B1%BB%E5%88%AB"><span class="nav-number">3.1.1.4.</span> <span class="nav-text">复合类别</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B9%BF%E4%B9%89%E5%B7%A6%E5%80%BC-glvalue-generalized-lvalue"><span class="nav-number">3.1.1.4.1.</span> <span class="nav-text">广义左值 (glvalue, generalized lvalue)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8F%B3%E5%80%BC-rvalue"><span class="nav-number">3.1.1.4.2.</span> <span class="nav-text">右值 (rvalue)</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8"><span class="nav-number">3.1.1.5.</span> <span class="nav-text">实际应用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A7%BB%E5%8A%A8%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%92%8C%E6%84%8F%E4%B9%89"><span class="nav-number">3.1.2.</span> <span class="nav-text">移动的实现和意义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A7%BB%E5%8A%A8%E5%92%8Cnoexcept"><span class="nav-number">3.1.3.</span> <span class="nav-text">移动和noexcept</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%94%9F%E5%91%BD%E6%9C%9F"><span class="nav-number">3.1.4.</span> <span class="nav-text">对象的生命期</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BD%AC%E5%8F%91%E5%BC%95%E7%94%A8"><span class="nav-number">3.1.5.</span> <span class="nav-text">转发引用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%94%E6%B3%95%E5%88%99"><span class="nav-number">3.1.6.</span> <span class="nav-text">五法则</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%94%E6%B3%95%E5%88%99%E7%9A%84%E8%83%8C%E6%99%AF"><span class="nav-number">3.1.6.1.</span> <span class="nav-text">五法则的背景</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E4%BA%94%E6%B3%95%E5%88%99"><span class="nav-number">3.1.6.2.</span> <span class="nav-text">为什么需要五法则</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B"><span class="nav-number">3.1.6.3.</span> <span class="nav-text">示例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BE%8B%E5%A4%96%E6%83%85%E5%86%B5"><span class="nav-number">3.1.6.4.</span> <span class="nav-text">例外情况</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%8E%B0%E4%BB%A3C-%E7%9A%84%E6%9B%BF%E4%BB%A3%E6%96%B9%E6%A1%88"><span class="nav-number">3.1.6.5.</span> <span class="nav-text">现代C++的替代方案</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%8F%E8%8A%82%E8%87%AA%E6%B5%8B"><span class="nav-number">3.2.</span> <span class="nav-text">小节自测</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="nav-number">4.</span> <span class="nav-text">4. 智能指针</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88-1"><span class="nav-number">4.1.</span> <span class="nav-text">4. 智能指针</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BB%E8%A6%81%E7%B1%BB%E5%9E%8B"><span class="nav-number">4.1.1.</span> <span class="nav-text">主要类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%EF%BC%9F"><span class="nav-number">4.1.2.</span> <span class="nav-text">为什么用智能指针？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%80%E5%8D%95%E4%BE%8B%E5%AD%90"><span class="nav-number">4.1.3.</span> <span class="nav-text">简单例子</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%BB%BA%E8%AE%AE"><span class="nav-number">4.1.4.</span> <span class="nav-text">使用建议</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%8F%E8%8A%82%E8%87%AA%E6%B5%8B-1"><span class="nav-number">4.2.</span> <span class="nav-text">小节自测</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5-%E5%AE%B9%E5%99%A8%E5%92%8C%E7%B1%BB%E5%AE%B9%E5%99%A8"><span class="nav-number">5.</span> <span class="nav-text">5. 容器和类容器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#5-1-string%EF%BC%9B%E5%BA%8F%E5%88%97%E5%AE%B9%E5%99%A8"><span class="nav-number">5.1.</span> <span class="nav-text">5.1 string；序列容器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-2-%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8%E5%92%8C%E6%97%A0%E5%BA%8F%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8"><span class="nav-number">5.2.</span> <span class="nav-text">5.2 关联容器和无序关联容器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%8F%E8%8A%82%E8%87%AA%E6%B5%8B-2"><span class="nav-number">5.3.</span> <span class="nav-text">小节自测</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6-%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E5%BE%AA%E7%8E%AF"><span class="nav-number">6.</span> <span class="nav-text">6. 迭代器和循环</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#6-%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E5%BE%AA%E7%8E%AF-1"><span class="nav-number">6.1.</span> <span class="nav-text">6. 迭代器和循环</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%8F%E8%8A%82%E8%87%AA%E6%B5%8B-3"><span class="nav-number">6.2.</span> <span class="nav-text">小节自测</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#7-%E5%AF%B9%E8%B1%A1%E8%BF%94%E5%9B%9E%E5%92%8C%E5%BC%82%E5%B8%B8"><span class="nav-number">7.</span> <span class="nav-text">7. 对象返回和异常</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#7-1-%E8%BF%94%E5%9B%9E%E5%80%BC%E4%BC%98%E5%8C%96%E5%92%8C%E5%AF%B9%E8%B1%A1%E8%BF%94%E5%9B%9E"><span class="nav-number">7.1.</span> <span class="nav-text">7.1 返回值优化和对象返回</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-2-%E5%BC%82%E5%B8%B8%E7%9A%84%E5%BE%97%E5%A4%B1%E5%92%8C%E7%9B%B8%E5%85%B3%E5%BB%BA%E8%AE%AE"><span class="nav-number">7.2.</span> <span class="nav-text">7.2 异常的得失和相关建议</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%8F%E8%8A%82%E8%87%AA%E6%B5%8B-4"><span class="nav-number">7.3.</span> <span class="nav-text">小节自测</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Yueht</p>
  <div class="site-description" itemprop="description">个人博客</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">9</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yueht</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>











<script>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : 'default',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>


  

  

  

</body>
</html>
