<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yueht23.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false,"animation":true,"content_length":400,"show_result":true,"show_result_on_focus":true,"auto_focus":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="第零章、核心刷题框架汇总本章导读学习数据结构和算法的框架思维 这一部分不要dfs,后面刷够题了，回顾再看。大概说了几个观点，但是目前感触不是很深，可能是做的题目太少了。  观点1：种种数据结构，皆为数组（顺序存储）和链表（链式存储）的变换。 观点2：数据结构的关键点在于遍历和访问，即增删查改等基本操作。 观点3：种种算法，皆为穷举。穷举的关键点在于无遗漏和无冗余。 熟练掌握算法框架，可以做到无遗漏">
<meta property="og:type" content="article">
<meta property="og:title" content="labuladong-第零章-核心刷题框架汇总">
<meta property="og:url" content="https://yueht23.github.io/2025/04/23/labuladong-%E7%AC%AC%E9%9B%B6%E7%AB%A0-%E6%A0%B8%E5%BF%83%E5%88%B7%E9%A2%98%E6%A1%86%E6%9E%B6%E6%B1%87%E6%80%BB/index.html">
<meta property="og:site_name" content="Yueht&#39;s Blog">
<meta property="og:description" content="第零章、核心刷题框架汇总本章导读学习数据结构和算法的框架思维 这一部分不要dfs,后面刷够题了，回顾再看。大概说了几个观点，但是目前感触不是很深，可能是做的题目太少了。  观点1：种种数据结构，皆为数组（顺序存储）和链表（链式存储）的变换。 观点2：数据结构的关键点在于遍历和访问，即增删查改等基本操作。 观点3：种种算法，皆为穷举。穷举的关键点在于无遗漏和无冗余。 熟练掌握算法框架，可以做到无遗漏">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://yueht23.github.io/images/image-12.png">
<meta property="og:image" content="https://yueht23.github.io/images/image-13.png">
<meta property="og:image" content="https://yueht23.github.io/images/image-14.png">
<meta property="og:image" content="https://yueht23.github.io/images/image-15.png">
<meta property="og:image" content="https://yueht23.github.io/images/image-16.png">
<meta property="og:image" content="https://yueht23.github.io/images/image-21.png">
<meta property="og:image" content="https://yueht23.github.io/images/image-19.png">
<meta property="og:image" content="https://yueht23.github.io/images/image-20.png">
<meta property="og:image" content="https://yueht23.github.io/images/image-22.png">
<meta property="og:image" content="https://yueht23.github.io/images/image-23.png">
<meta property="og:image" content="https://yueht23.github.io/images/image-21.png">
<meta property="article:published_time" content="2025-04-23T09:27:49.000Z">
<meta property="article:modified_time" content="2025-04-28T23:01:14.985Z">
<meta property="article:author" content="Yueht">
<meta property="article:tag" content="cpp">
<meta property="article:tag" content="数据结构">
<meta property="article:tag" content="排序算法">
<meta property="article:tag" content="算法">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://yueht23.github.io/images/image-12.png">

<link rel="canonical" href="https://yueht23.github.io/2025/04/23/labuladong-%E7%AC%AC%E9%9B%B6%E7%AB%A0-%E6%A0%B8%E5%BF%83%E5%88%B7%E9%A2%98%E6%A1%86%E6%9E%B6%E6%B1%87%E6%80%BB/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>labuladong-第零章-核心刷题框架汇总 | Yueht's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">
<!-- hexo injector head_end end --></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Yueht's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://yueht23.github.io/2025/04/23/labuladong-%E7%AC%AC%E9%9B%B6%E7%AB%A0-%E6%A0%B8%E5%BF%83%E5%88%B7%E9%A2%98%E6%A1%86%E6%9E%B6%E6%B1%87%E6%80%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yueht">
      <meta itemprop="description" content="个人博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yueht's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          labuladong-第零章-核心刷题框架汇总
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-04-23 17:27:49" itemprop="dateCreated datePublished" datetime="2025-04-23T17:27:49+08:00">2025-04-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-04-29 07:01:14" itemprop="dateModified" datetime="2025-04-29T07:01:14+08:00">2025-04-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/labuladong%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">labuladong算法笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="第零章、核心刷题框架汇总"><a href="#第零章、核心刷题框架汇总" class="headerlink" title="第零章、核心刷题框架汇总"></a><a target="_blank" rel="noopener" href="https://labuladong.online/algo/menu/core/">第零章、核心刷题框架汇总</a></h1><h2 id="本章导读"><a href="#本章导读" class="headerlink" title="本章导读"></a><a target="_blank" rel="noopener" href="https://labuladong.online/algo/intro/core-intro/">本章导读</a></h2><h2 id="学习数据结构和算法的框架思维"><a href="#学习数据结构和算法的框架思维" class="headerlink" title="学习数据结构和算法的框架思维"></a><a target="_blank" rel="noopener" href="https://labuladong.online/algo/essential-technique/algorithm-summary/">学习数据结构和算法的框架思维</a></h2><blockquote>
<p>这一部分不要dfs,后面刷够题了，回顾再看。大概说了几个观点，但是目前感触不是很深，可能是做的题目太少了。</p>
<ul>
<li>观点1：种种数据结构，皆为数组（顺序存储）和链表（链式存储）的变换。</li>
<li>观点2：数据结构的关键点在于遍历和访问，即增删查改等基本操作。</li>
<li>观点3：种种算法，皆为穷举。穷举的关键点在于无遗漏和无冗余。<ul>
<li>熟练掌握算法框架，可以做到无遗漏</li>
<li>充分利用信息，可以做到无冗余。</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="双指针技巧秒杀七道链表题目"><a href="#双指针技巧秒杀七道链表题目" class="headerlink" title="双指针技巧秒杀七道链表题目"></a><a target="_blank" rel="noopener" href="https://labuladong.online/algo/essential-technique/linked-list-skills-summary/">双指针技巧秒杀七道链表题目</a></h2><ul>
<li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-two-sorted-lists/">Leetcode 21</a> 合并两个有序链表<br>当你需要创造一条新链表的时候，可以使用虚拟头结点简化边界情况的处理。比如说，让你把两条有序链表合并成一条新的有序链表，是不是要创造一条新链表？再比你想把一条链表分解成两条链表，是不是也在创造新链表？这些情况都可以使用虚拟头结点简化边界情况的处理。</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/partition-list/description/">Leetcode 86</a> 分隔链表<br>同样是要创造一条新链表，使用虚拟头结点简化边界情况的处理。同时，遍历给定链表的时候需要注意搞一个<code>tmp</code>把节点从原链表中摘下来。如果不这么搞会TLE，会成环，遍历不完。</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-k-sorted-lists/">Leetcode 23*</a> 合并K个升序链表<br>注意优先队列在python中的调用：</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line">lls = [list1, list2, list3, ...] <span class="comment"># K个链表组成的动态数组</span></span><br><span class="line">heap = [ (l.val,,idx,l) <span class="keyword">for</span> l,idx <span class="keyword">in</span> <span class="built_in">enumerate</span>(lls) <span class="keyword">if</span> ll ] <span class="comment"># 只把非空链表入队</span></span><br><span class="line">heapq.heapify(heap) <span class="comment"># 堆化,先比较val,再比较idx,最后比较l，</span></span><br><span class="line"><span class="comment"># l的比较没实现，需要重载__lt__方法,但是Leetcode不支持，所以直接用idx来比较</span></span><br></pre></td></tr></table></figure>

<p>  在C++中</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;ListNode*&gt; lists; <span class="comment">// K个链表组成的动态数组</span></span><br><span class="line"><span class="keyword">auto</span> cmp = [](ListNode* a, ListNode* b) &#123; <span class="keyword">return</span> a-&gt;val &gt; b-&gt;val; &#125;;</span><br><span class="line">priority_queue&lt;ListNode*, vector&lt;ListNode*&gt;, <span class="keyword">decltype</span>(cmp)&gt; <span class="built_in">pq</span>(cmp);</span><br><span class="line"><span class="comment">// C++中默认是大顶堆，所以提供一个比较函数cmp来实现小顶堆</span></span><br><span class="line"><span class="comment">// 这里cmp是一个lambda表达式，比较两个ListNode的val大小</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/kth-node-from-end-of-list-lcci/description/">链表中倒数第k个节点</a><br>快慢指针的应用，快指针先走k步，然后快慢指针一起走，直到快指针走到链表尾部，慢指针就是倒数第k个节点。</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/middle-of-the-linked-list/">Leetcode 876</a> 链表的中间结点<br>快慢指针，快的指针走两步，慢的指针走一步，快指针到达链表尾部的时候，慢指针就是链表的中间节点。框架如下：</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> fast <span class="keyword">and</span> fast.<span class="built_in">next</span>:</span><br><span class="line">    slow = slow.<span class="built_in">next</span></span><br><span class="line">    fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>

</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/linked-list-cycle/">Leetcode 141</a> 环形链表<br>判断链表是否有环，快慢指针，快的指针走两步，慢的指针走一步，如果有环，快指针和慢指针会相遇。如果 fast 走着走着竟然和 slow 相遇了，那肯定是 fast 在链表中转圈了，说明链表中含有环。</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/linked-list-cycle-ii/">Leetcode 142*</a> 环形链表 II<br>最简单的过法就是用hash表，但是这样的空间复杂度就不为O(1)了。<strong>但是快慢指针向撞的位置不是入环的节点</strong><br><img src="/../images/image-12.png" alt="alt text"><br>在slow走了k步之后，fast也走了2k步子，两个相撞了，相撞点到入环点的距离为m，fast和slow距离head的距离为k，距离入环点的距离为m，这个时候把slow放在head上，两个一起走。两个再次相撞的时候，slow就是入环的节点。</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/intersection-of-two-linked-lists/">Leetcode 160*</a> 相交链表<br>最简单的过法就是用hash表，但是这样的空间复杂度就不为O(1)了。维护p,q。p遍历A-B，q遍历B-A。p和q都走完了链表A和链表B，p和q相遇的地方就是相交的节点,如果没有相交点，两个指针会同时到达链表尾部，返回null。<br><img src="/../images/image-13.png" alt="alt text"></p>
</li>
</ul>
<h2 id="双指针技巧秒杀七道数组题目"><a href="#双指针技巧秒杀七道数组题目" class="headerlink" title="双指针技巧秒杀七道数组题目"></a><a target="_blank" rel="noopener" href="https://labuladong.online/algo/essential-technique/array-two-pointers-summary/">双指针技巧秒杀七道数组题目</a></h2><blockquote>
<p>左右指针:就是两个指针相向而行或者<strong>相背而行</strong><br>快慢指针，就是两个指针<strong>同向而行</strong>，一快一慢（两个的方向是一样的）<br>对于数组问题，再具体点总结：</p>
<ul>
<li>求满足条件的子数组，一般是前缀和、滑动窗口，经常结合哈希表；</li>
<li>区间操作元素，一般是前缀和、差分数组、线段树；</li>
<li>数组有序，主要是双指针技巧，更大概率会用到二分搜索。</li>
</ul>
</blockquote>
<h3 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h3><h4 id="原地修改"><a href="#原地修改" class="headerlink" title="原地修改"></a>原地修改</h4><blockquote>
<p>快慢指针的指针的初始化一般是<code>slow=0, fast=0</code>，然后根据题目的要求来移动指针。</p>
</blockquote>
<ul>
<li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array/">Leetcode 26*</a> 删除排序数组中的重复项<br>不是真删除啊，真删除搞不到O(1)的空间复杂度。只要把不重复的元素放在前面就行了，返回长度就行了，这个和下面的<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-element/">Leetcode 27*</a>是一样的。我们维护快慢指针，其中<code>nums[0,1,..slow)</code>是没有重复的元素。由于<code>nums</code>是有序的，所以只要<code>nums[slow] != nums[fast]</code>，就把<code>nums[fast]</code>放到<code>nums[slow]</code>上，然后<code>slow++</code>。最后返回<code>slow</code>就行了。</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-element/">Leetcode 27*</a> 移除元素<br>和上面类似</p>
</li>
</ul>
<h4 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 滑动窗口算法框架伪码</span></span><br><span class="line"><span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (right &lt; nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">    <span class="comment">// 增大窗口</span></span><br><span class="line">    window.<span class="built_in">addLast</span>(nums[right]);</span><br><span class="line">    right++;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (window needs shrink) &#123;</span><br><span class="line">        <span class="comment">// 缩小窗口</span></span><br><span class="line">        window.<span class="built_in">removeFirst</span>(nums[left]);</span><br><span class="line">        left++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请查看下文档的<a href="##%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%AE%97%E6%B3%95%E6%A0%B8%E5%BF%83%E4%BB%A3%E7%A0%81%E6%A8%A1%E6%9D%BF">滑动窗口算法核心代码模板</a>。</p>
<h3 id="左右指针"><a href="#左右指针" class="headerlink" title="左右指针"></a>左右指针</h3><blockquote>
<p>左右指针的初始化一般是<code>left=0, right=nums.size()-1</code>，然后根据题目的要求来移动指针。</p>
</blockquote>
<h4 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h4><p>对于有序的数组，我们可以使用二分查找来快速定位目标元素的位置。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">binarySearch</span>(<span class="params">nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="comment"># 一左一右两个指针相向而行</span></span><br><span class="line">    left, right = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">        mid = (right + left) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        <span class="keyword">elif</span> nums[mid] &lt; target:</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> nums[mid] &gt; target:</span><br><span class="line">            right = mid - <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>


<h4 id="n数之和"><a href="#n数之和" class="headerlink" title="n数之和"></a>n数之和</h4><ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/">Leetcode 167*</a> 两数之和 II - 输入有序数组<br>只要数组有序，就应该想到双指针技巧。通过调节 left 和 right 就可以调整 nums[left] + nums[right] 的值。将left&#x3D;0,right&#x3D;nums.size()-1，nums[left] + nums[right] &lt; target，说明left指针需要向右移动，nums[left] + nums[right] &gt; target，说明right指针需要向左移动。</li>
</ul>
<h4 id="原地反转"><a href="#原地反转" class="headerlink" title="原地反转"></a>原地反转</h4><ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-string/">Leetcode 344</a> 反转字符串<br>L，R两个指针分别指向字符串的首尾，L++，R–，交换L和R指向的字符。</li>
</ul>
<h4 id="回文串判断"><a href="#回文串判断" class="headerlink" title="回文串判断"></a>回文串判断</h4><ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-palindromic-substring/">Leetcode 5*</a> 最长回文子串<br>首先，最简单的判断一个字符串是不是回文串的方法就是用双指针</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">isPalindrome</span>(<span class="params">s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">    left, right = <span class="number">0</span>, <span class="built_in">len</span>(s) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> left &lt; right:</span><br><span class="line">        <span class="keyword">if</span> s[left] != s[right]:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        left += <span class="number">1</span></span><br><span class="line">        right -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p>对于这个题目，我们需要查找最长的回文子串。我们可以使用中心扩展法来解决这个问题。对于每一个字符，我们都可以将它作为回文串的中心，然后向两边扩展，直到不能扩展为止。我们需要考虑两种情况：</p>
<ul>
<li>奇数长度的回文串，中心是一个字符，比如<code>aba</code>，<code>a</code>就是中心。</li>
<li>偶数长度的回文串，中心是两个字符，比如<code>abba</code>，<code>ab</code>就是中心。</li>
</ul>
<p>针对这个特殊需求，我们重新设置一个基于左右指针的判断是不是回文串的函数<code>expandAroundCenter</code>，然后在主函数中遍历每一个字符，调用这个函数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">expandAroundCenter</span>(<span class="params">s: <span class="built_in">str</span>, left: <span class="built_in">int</span>, right: <span class="built_in">int</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">    <span class="keyword">while</span> left &gt;= <span class="number">0</span> <span class="keyword">and</span> right &lt; <span class="built_in">len</span>(s) <span class="keyword">and</span> s[left] == s[right]:</span><br><span class="line">        left -= <span class="number">1</span></span><br><span class="line">        right += <span class="number">1</span></span><br><span class="line">    <span class="comment"># 此时：left &lt; 0 or right = len(s) or s[left] != s[right]</span></span><br><span class="line">    <span class="keyword">return</span> s[left + <span class="number">1</span>:right]</span><br></pre></td></tr></table></figure>
<h2 id="滑动窗口算法核心代码模板"><a href="#滑动窗口算法核心代码模板" class="headerlink" title="滑动窗口算法核心代码模板"></a><a target="_blank" rel="noopener" href="https://labuladong.online/algo/essential-technique/sliding-window-framework/">滑动窗口算法核心代码模板</a></h2><p>滑动窗口可以归为快慢双指针，一快一慢两个指针前后相随，中间的部分就是窗口。滑动窗口算法技巧主要用来解决子数组问题，比如让你寻找符合某个条件的最长&#x2F;最短子数组。 如果没有滑动窗口，最为简单的办法就是暴力破解，O(N^2)的时间复杂度。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> l <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">    <span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(l, <span class="built_in">len</span>(nums)):</span><br><span class="line">        <span class="comment"># 处理 nums[l:r+1] 这个子数组</span></span><br><span class="line">        <span class="keyword">if</span> check(nums[l:r+<span class="number">1</span>]):</span><br><span class="line">            <span class="comment"># 满足条件，做一些操作</span></span><br></pre></td></tr></table></figure>

<p>而滑动窗口的可以做到O(N)的时间复杂度, 之所以是两层while循环还是复杂度为O(N)，是因为每个指针不会回退。<strong>如下的框架并没有枚举所有的子数组，滑动窗口做到了合理的剪枝。这个方法有点像，先找个可行解，再在可行解上优化</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 滑动窗口算法伪码框架</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">slidingWindow</span>(<span class="params">s: <span class="built_in">str</span></span>):</span><br><span class="line">    <span class="comment"># 用合适的数据结构记录窗口中的数据，根据具体场景变通</span></span><br><span class="line">    <span class="comment"># 比如说，我想记录窗口中元素出现的次数，就用 map</span></span><br><span class="line">    <span class="comment"># 如果我想记录窗口中的元素和，就可以只用一个 int</span></span><br><span class="line">    window = ...</span><br><span class="line"></span><br><span class="line">    left, right = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> right &lt; <span class="built_in">len</span>(s):</span><br><span class="line">        <span class="comment"># c 是将移入窗口的字符</span></span><br><span class="line">        c = s[right]</span><br><span class="line">        window.add(c)</span><br><span class="line">        <span class="comment"># 增大窗口</span></span><br><span class="line">        right += <span class="number">1</span></span><br><span class="line">        <span class="comment"># 进行窗口内数据的一系列更新</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Your code here 1</span></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="comment"># *** debug 输出的位置 ***</span></span><br><span class="line">        <span class="comment"># 注意在最终的解法代码中不要 print</span></span><br><span class="line">        <span class="comment"># 因为 IO 操作很耗时，可能导致超时</span></span><br><span class="line">        <span class="comment"># print(f&quot;window: [&#123;left&#125;, &#123;right&#125;)&quot;)</span></span><br><span class="line">        <span class="comment"># ***********************</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 判断左侧窗口是否要收缩</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> window needs shrink:</span><br><span class="line">            <span class="comment"># d 是将移出窗口的字符</span></span><br><span class="line">            d = s[left]</span><br><span class="line">            window.remove(d)</span><br><span class="line">            <span class="comment"># 缩小窗口</span></span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 进行窗口内数据的一系列更新</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment"># Your code here 2</span></span><br><span class="line">            ...</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Your code here 3</span></span><br><span class="line">        ...</span><br></pre></td></tr></table></figure>
<p>上述三处<code>Your code here</code>的地方是需要根据题目的要求来进行修改的。回顾一下，遇到子数组&#x2F;子串相关的问题，你只要能回答出来以下几个问题，就能运用滑动窗口算法：</p>
<ul>
<li>1、什么时候应该扩大窗口？</li>
<li>2、什么时候应该缩小窗口？</li>
<li>3、什么时候应该更新答案？</li>
</ul>
<h3 id="最小覆盖字串"><a href="#最小覆盖字串" class="headerlink" title="最小覆盖字串"></a>最小覆盖字串</h3><ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-window-substring/">Leetcode 76*</a> 最小覆盖子串<br>需要有<code>need</code>和<code>window</code>两个<code>Counter</code>，<code>need</code>用来记录需要的字符和数量，<code>window</code>用来记录当前窗口中的字符和数量。在<code>your code here 2</code>的地方，一定满足覆盖，在这里判断当前的窗口是不是最小。</li>
</ul>
<h3 id="字符串排列"><a href="#字符串排列" class="headerlink" title="字符串排列"></a>字符串排列</h3><ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/permutation-in-string/">Leetcode 567*</a> 字符串的排列<br>这个是简化版本的滑动窗口，窗口的大小是固定的，等于<code>p</code>的长度。</li>
</ul>
<h3 id="找所有字母异位词"><a href="#找所有字母异位词" class="headerlink" title="找所有字母异位词"></a>找所有字母异位词</h3><ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-all-anagrams-in-a-string/">Leetcode 438</a> 找到字符串中所有字母异位词<br>和<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/permutation-in-string/">Leetcode 567*</a> 本质上一样，但是这个需要有个list把所有的结果存起来。</li>
</ul>
<h3 id="最长重复字符"><a href="#最长重复字符" class="headerlink" title="最长重复字符"></a>最长重复字符</h3><ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">Leetcode 3*</a> 无重复字符的最长子串<br>在<code>your code here 3</code>的地方，判断当前窗口是不是最优解。</li>
</ul>
<h2 id="一个视角-两种思维模式搞定递归"><a href="#一个视角-两种思维模式搞定递归" class="headerlink" title="一个视角 + 两种思维模式搞定递归"></a><a target="_blank" rel="noopener" href="https://labuladong.online/algo/essential-technique/understand-recursion/">一个视角 + 两种思维模式搞定递归</a></h2><h3 id="一个视角"><a href="#一个视角" class="headerlink" title="一个视角"></a>一个视角</h3><p>**任何递归都可以从树的角度来看，**算法的本质是穷举，递归是一种重要的穷举手段，递归的正确理解方法是从「树」的角度理解。</p>
<h3 id="两种思维"><a href="#两种思维" class="headerlink" title="两种思维"></a>两种思维</h3><h4 id="分解问题的思维"><a href="#分解问题的思维" class="headerlink" title="分解问题的思维"></a>分解问题的思维</h4><blockquote>
<p>如果你想用「分解问题」的思维模式来写递归算法，那么这个递归函数一定要有一个清晰的定义，说明这个函数参数的含义是什么，返回什么结果。</p>
</blockquote>
<p>例如：对于斐波那契数列的求解，递归函数的定义就是：输入一个非负整数 n，返回斐波那契数列中的第 n 个数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> fib(<span class="built_in">int</span> n) &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">    // 利用定义，计算前两个斐波那契数（子问题）</span><br><span class="line">    <span class="built_in">int</span> fib_n_1 = fib(n - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">int</span> fib_n_2 = fib(n - <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    // 通过子问题的解，计算原问题的解</span><br><span class="line">    <span class="keyword">return</span> fib_n_1 + fib_n_2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例如：对于求一个树的最大深度，递归函数的定义就是：输入一个树的根节点，返回这个树的最大深度。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> max_depth(TreeNode* root) &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == nullptr) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    // 计算子树的最大深度</span><br><span class="line">    <span class="built_in">int</span> left_depth = max_depth(root.left);</span><br><span class="line">    <span class="built_in">int</span> right_depth = max_depth(root.right);</span><br><span class="line"></span><br><span class="line">    // 通过子问题的解，计算原问题的解</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(left_depth, right_depth) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="遍历的思维"><a href="#遍历的思维" class="headerlink" title="遍历的思维"></a>遍历的思维</h4><blockquote>
<p>如果你想用「遍历」的思维模式来写递归算法，那么你需要一个无返回值的遍历函数，在遍历的过程中收集结果。</p>
</blockquote>
<p>例如：对于全排列问题, 本质上就是一个多叉树的遍历问题。我们可以使用一个无返回值的递归函数来遍历这个多叉树，在遍历的过程中收集结果。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">permute</span>(<span class="params">nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">    res = []</span><br><span class="line">    track = []</span><br><span class="line">    used = [<span class="literal">False</span>] * <span class="built_in">len</span>(nums)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backtrack</span>():</span><br><span class="line">        <span class="comment"># 终止条件</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(track) == <span class="built_in">len</span>(nums):</span><br><span class="line">            res.append(track[:])</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="comment"># 排除不合法的选择</span></span><br><span class="line">            <span class="keyword">if</span> used[i]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 做选择</span></span><br><span class="line">            track.append(nums[i])</span><br><span class="line">            used[i] = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 进入下一层决策树</span></span><br><span class="line">            backtrack()</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 撤销选择</span></span><br><span class="line">            track.pop()</span><br><span class="line">            used[i] = <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line">    backtrack(nums, res, track, used)</span><br></pre></td></tr></table></figure>


<p>例如，同样的对于求一个树的最大深度，我们可以使用一个无返回值的递归函数来遍历这个树，在遍历的过程中收集结果。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">max_depth</span>(<span class="params">root: TreeNode</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    depth = <span class="number">0</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">travel</span>(<span class="params">node: TreeNode</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 前序遍历位置（进入节点）增加深度</span></span><br><span class="line">        depth += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 遍历到叶子节点时记录最大深度</span></span><br><span class="line">        <span class="keyword">if</span> node.left <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> node.right <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            res = <span class="built_in">max</span>(res, depth)</span><br><span class="line"></span><br><span class="line">        travel(node.left, depth + <span class="number">1</span>)</span><br><span class="line">        travel(node.right, depth + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 后序遍历位置（离开节点）减少深度</span></span><br><span class="line">        depth -= <span class="number">1</span></span><br></pre></td></tr></table></figure>









<h2 id="动态规划解题套路框架"><a href="#动态规划解题套路框架" class="headerlink" title="动态规划解题套路框架"></a><a target="_blank" rel="noopener" href="https://labuladong.online/algo/essential-technique/dynamic-programming-framework/">动态规划解题套路框架</a></h2><blockquote>
<p>动态规划问题的一般形式就是求最值，求方案数量</p>
</blockquote>
<ul>
<li>只有列出正确的「<strong>状态转移方程</strong>」，才能正确地穷举</li>
<li>而且，你需要判断算法问题是否具备「<strong>最优子结构</strong>」，是否能够通过子问题的最值得到原问题的最值<ul>
<li><em>要符合「最优子结构」，子问题间必须互相独立。啥叫相互独立？你肯定不想看数学证明，我用一个直观的例子来讲解。比如说，假设你考试，每门科目的成绩都是互相独立的。你的原问题是考出最高的总成绩，那么你的子问题就是要把语文考到最高，数学考到最高…… 为了每门课考到最高，你要把每门课相应的选择题分数拿到最高，填空题分数拿到最高…… 当然，最终就是你每门课都是满分，这就是最高的总成绩。得到了正确的结果：最高的总成绩就是总分。因为这个过程符合最优子结构，「每门科目考到最高」这些子问题是互相独立，互不干扰的。但是，如果加一个条件：你的语文成绩和数学成绩会互相制约，不能同时达到满分，数学分数高，语文分数就会降低，反之亦然。这样的话，显然你能考到的最高总成绩就达不到总分了，按刚才那个思路就会得到错误的结果。因为「每门科目考到最高」的子问题并不独立，语文数学成绩户互相影响，无法同时最优，所以最优子结构被破坏。</em></li>
</ul>
</li>
<li>动态规划问题存在「<strong>重叠子问题</strong>」，如果暴力穷举的话效率会很低，<strong>所以需要你使用「memo」或者「DP table」来优化穷举过程，避免不必要的计算</strong></li>
</ul>
<p>其一般的流程为：</p>
<ul>
<li><ol>
<li>明确「状态」</li>
</ol>
</li>
<li><ol start="2">
<li>明确「选择」</li>
</ol>
</li>
<li><ol start="3">
<li>定义 dp 数组&#x2F;函数的含义</li>
</ol>
</li>
</ul>
<p>动态规划的问题，按照笨蛋到聪明的顺序，可以有如下几种不同的解决方法：</p>
<ul>
<li><ol>
<li><strong>暴力递归</strong>，很多子问题会重复计算，时间复杂度高</li>
</ol>
</li>
<li><ol start="2">
<li><strong>记忆化搜索or带memo的递归</strong>，避免了重复计算,先问问memo有没有答案，如果有就直接返回，没有就计算，计算完了存到memo中，以空间换时间</li>
</ol>
</li>
<li><ol start="3">
<li><strong>自底向上的动态规划</strong>，使用 dp 数组来存储子问题的解，避免了重复计算 ，以空间换时间</li>
</ol>
</li>
<li><ol start="4">
<li><strong>自底向上的动态规划+空间优化</strong>，使用 dp 数组来存储子问题的解，避免了重复计算，并且使用滚动数组来优化空间复杂度</li>
</ol>
</li>
</ul>
<p>上述1，2的方法是自顶向下的动态规划，3，4的方法是自底向上的动态规划，4是尽可能把不要的子问题的答案给drop掉，从而达到空间复杂度的优化。</p>
<p>下面说两个具体题目，用上面4种方法来解决。</p>
<ul>
<li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/fibonacci-number/">Leetcode 509</a> 斐波那契数</p>
<ul>
<li><ol>
<li><strong>暴力递归</strong></li>
</ol>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fib</span>(<span class="params">n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    <span class="keyword">return</span> fib(n - <span class="number">1</span>) + fib(n - <span class="number">2</span>)</span><br></pre></td></tr></table></figure></li>
<li><ol start="2">
<li><strong>记忆化搜索or带memo的递归</strong></li>
</ol>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">memo = &#123;&#125;</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fib</span>(<span class="params">n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="keyword">if</span> n <span class="keyword">in</span> memo:</span><br><span class="line">        <span class="keyword">return</span> memo[n]</span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    memo[n] = fib(n - <span class="number">1</span>) + fib(n - <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> memo[n]</span><br></pre></td></tr></table></figure></li>
<li><ol start="3">
<li><strong>自底向上的动态规划</strong></li>
</ol>
<ul>
<li>明确「状态」：<code>dp[i]</code>表示第i个斐波那契数</li>
<li>明确「选择」：只有一个选择，就是<code>dp[i] = dp[i-1] + dp[i-2]</code></li>
<li>定义 dp 数组&#x2F;函数的含义：<code>dp = [0] * (n + 1)</code>，<code>dp[0] = 0, dp[1] = 1</code><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fib</span>(<span class="params">n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    dp = [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line">    dp[<span class="number">0</span>], dp[<span class="number">1</span>] = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">        dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>]</span><br><span class="line">    <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><ol start="4">
<li><strong>自底向上的动态规划+空间优化</strong></li>
</ol>
<ul>
<li>只需要知道最后两个状态，所以只需要两个变量来存储前两个状态，<code>a, b = 0, 1</code>，<code>a, b = b, a + b</code>。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fib</span>(<span class="params">n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    a, b = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">        a, b = b, a + b</span><br><span class="line">    <span class="keyword">return</span> b</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/coin-change/">Leetcode 322</a> 零钱兑换</p>
<ul>
<li><ol>
<li><strong>暴力递归</strong></li>
</ol>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">waysOfcoinChange</span>(<span class="params">self, coins, amount</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        返回coins可以凑成amount所需的最少的硬币个数</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> amount &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> amount == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">elif</span> amount <span class="keyword">in</span> coins:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            ress = []</span><br><span class="line">            <span class="keyword">for</span> coin <span class="keyword">in</span> coins:</span><br><span class="line">                res = <span class="variable language_">self</span>.waysOfcoinChange(coins,amount - coin)</span><br><span class="line">                <span class="keyword">if</span> res != -<span class="number">1</span>:</span><br><span class="line">                    ress.append(res + <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span> <span class="keyword">if</span> ress == [] <span class="keyword">else</span> <span class="built_in">min</span>(ress)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">coinChange</span>(<span class="params">self, coins, amount</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type coins: List[int]</span></span><br><span class="line"><span class="string">        :type amount: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.waysOfcoinChange(coins,amount)</span><br></pre></td></tr></table></figure>
</li>
<li><ol start="2">
<li><strong>记忆化搜索or带memo的递归</strong></li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.memo = &#123;&#125;</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">waysOfcoinChange</span>(<span class="params">self, coins, amount</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        返回coins可以凑成amount所需的最少的硬币个数</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> amount <span class="keyword">in</span> <span class="variable language_">self</span>.memo:</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">self</span>.memo[amount]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> amount &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="variable language_">self</span>.memo[amount] = -<span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> amount == <span class="number">0</span>:</span><br><span class="line">            <span class="variable language_">self</span>.memo[amount] = <span class="number">0</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">elif</span> amount <span class="keyword">in</span> coins:</span><br><span class="line">            <span class="variable language_">self</span>.memo[amount] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            ress = []</span><br><span class="line">            <span class="keyword">for</span> coin <span class="keyword">in</span> coins:</span><br><span class="line">                res = <span class="variable language_">self</span>.waysOfcoinChange(coins,amount - coin)</span><br><span class="line">                <span class="keyword">if</span> res != -<span class="number">1</span>:</span><br><span class="line">                    ress.append(res + <span class="number">1</span>)</span><br><span class="line">            <span class="variable language_">self</span>.memo[amount] = -<span class="number">1</span> <span class="keyword">if</span> ress == [] <span class="keyword">else</span> <span class="built_in">min</span>(ress)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span> <span class="keyword">if</span> ress == [] <span class="keyword">else</span> <span class="built_in">min</span>(ress)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">coinChange</span>(<span class="params">self, coins, amount</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type coins: List[int]</span></span><br><span class="line"><span class="string">        :type amount: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.waysOfcoinChange(coins,amount)</span><br></pre></td></tr></table></figure>
</li>
<li><ol start="3">
<li><strong>自底向上的动态规划</strong></li>
</ol>
<ul>
<li><ol>
<li>明确「状态」：<code>dp[i]</code>表示凑成金额i所需的最少的硬币个数</li>
</ol>
</li>
<li><ol start="2">
<li>明确「选择」：有<code>len(coins)</code>个选择，<code>dp[i] = min(dp[i - coins[j]]) + 1</code>，<code>j = 0, 1, ..., len(coins) - 1</code></li>
</ol>
</li>
<li><ol start="3">
<li>定义 dp 数组&#x2F;函数的含义：<code>dp = [0] * (amount + 1)</code>，<code>dp[0] = 0</code></li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">coinChange</span>(<span class="params">self, coins, amount</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :type coins: List[int]</span></span><br><span class="line"><span class="string">    :type amount: int</span></span><br><span class="line"><span class="string">    :rtype: int</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    dp = [<span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>)]*(amount + <span class="number">1</span>)</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(dp)):</span><br><span class="line">        ress = []</span><br><span class="line">        <span class="keyword">for</span> coin <span class="keyword">in</span> coins:</span><br><span class="line">            <span class="keyword">if</span> i &lt; coin:</span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line">            <span class="keyword">elif</span> i == coin:</span><br><span class="line">                ress.append(<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># i &gt; coin</span></span><br><span class="line">                ress.append(dp[i-coin] + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> ress != []:</span><br><span class="line">            dp[i] = <span class="built_in">min</span>(ress)</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span> <span class="keyword">if</span> dp[amount] == <span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>) <span class="keyword">else</span> dp[amount]</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><ol start="4">
<li><strong>自底向上的动态规划+空间优化</strong>, 该题目没有空间优化的必要，因为<code>dp</code>数组的大小是<code>amount + 1</code>，而且<code>coins</code>的大小是<code>len(coins)</code></li>
</ol>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/climbing-stairs/">Leetcode 70</a> 爬楼梯</p>
<ul>
<li><ol>
<li><strong>暴力递归</strong></li>
</ol>
</li>
<li><ol start="2">
<li><strong>记忆化搜索or带memo的递归</strong></li>
</ol>
</li>
<li><ol start="3">
<li><strong>自底向上的动态规划</strong></li>
</ol>
<ul>
<li><ol>
<li>明确「状态」：<code>dp[i]</code>表示第i阶楼梯的走法</li>
</ol>
</li>
<li><ol start="2">
<li>明确「选择」：有<code>1</code>个选择，<code>dp[i] = dp[i - 1] + dp[i - 2]</code></li>
</ol>
</li>
<li><ol start="3">
<li>定义 dp 数组&#x2F;函数的含义：<code>dp = [0] * (n + 1)</code>，<code>dp[0] = 1, dp[1] = 1</code></li>
</ol>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">climbStairs</span>(<span class="params">self, n</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        dp = [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>], dp[<span class="number">1</span>] = <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>]</span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><ol start="4">
<li><strong>自底向上的动态规划+空间优化</strong></li>
</ol>
<ul>
<li>只需要知道最后两个状态，所以只需要两个变量来存储前两个状态，<code>a, b = 1, 1</code>，<code>a, b = b, a + b</code>。</li>
</ul>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">climbStairs</span>(<span class="params">self, n</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        a, b = <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">            a, b = b, a + b</span><br><span class="line">        <span class="keyword">return</span> b</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="回溯算法解题套路框架"><a href="#回溯算法解题套路框架" class="headerlink" title="回溯算法解题套路框架"></a><a target="_blank" rel="noopener" href="https://labuladong.online/algo/essential-technique/backtrack-framework/">回溯算法解题套路框架</a></h2><blockquote>
<p>其实<strong>回溯算法和我们常说的 DFS 算法基本可以认为是同一种算法</strong>, 抽象地说，<strong>解决一个回溯问题，实际上就是遍历一棵决策树的过程</strong>，树的每个叶子节点存放着一个合法答案。你把整棵树遍历一遍，把叶子节点上的答案都收集起来，就能得到所有的合法答案。下面的框架可以确保结果没有漏，但是<strong>回溯的难点往往是是如何剪枝，减少重复计算。</strong></p>
</blockquote>
<p>站在回溯树的一个节点上，你只需要思考 3 个问题：</p>
<ul>
<li>1、路径：也就是已经做出的选择。</li>
<li>2、选择列表：也就是你当前可以做的选择。</li>
<li>3、结束条件：也就是到达决策树底层，无法再做选择的条件。</li>
</ul>
<p>其一般的算法框架为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">res = []</span><br><span class="line">path = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">路径, 选择列表</span>):</span><br><span class="line">    <span class="comment"># 触发结束条件，收集结果</span></span><br><span class="line">    <span class="keyword">if</span> 结束条件:</span><br><span class="line">        res.append(path[:])</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> 选择 <span class="keyword">in</span> 选择列表:</span><br><span class="line">        <span class="comment"># 做选择</span></span><br><span class="line">        path.append(选择)</span><br><span class="line">        <span class="comment"># 进入下一层决策树</span></span><br><span class="line">        backtrack(路径, 选择列表)</span><br><span class="line">        <span class="comment"># 撤销选择</span></span><br><span class="line">        path.pop()</span><br></pre></td></tr></table></figure>




<p>考虑到<a href="###%E5%A4%9A%E5%8F%89%E6%A0%91%E7%9A%84%E9%80%92%E5%BD%92/%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86">多叉树的遍历</a>,他是没有中序遍历的</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">(NTreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span>; <span class="comment">// 递归终止条件</span></span><br><span class="line">    <span class="comment">//时机点1 do something with root-&gt;val; e.g. arr.push_back(root-&gt;val); </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> child : root-&gt;children) &#123; <span class="comment">// 遍历子节点</span></span><br><span class="line">        <span class="built_in">traverse</span>(child); <span class="comment">// 遍历子节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//时机点2 do something with root-&gt;val; e.g. arr.push_back(root-&gt;val);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是前序和后续的位置在for的外面，而回溯是在for的里面，这是为什么？详见如下图的解释：<br><img src="/../images/image-14.png" alt="alt text"></p>
<p><strong>回溯的算法复杂度不会低于O(N!)，因为你必须遍历所有的节点,不像动态规划存在重叠子问题可以优化，回溯算法就是纯暴力穷举，复杂度一般都很高</strong></p>
<h3 id="回溯算法的例题："><a href="#回溯算法的例题：" class="headerlink" title="回溯算法的例题："></a>回溯算法的例题：</h3><ul>
<li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/permutations/">Leetcode 46</a> 全排列<br>之前写过</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/permutations-ii/">Leetcode 47*</a> 全排列 II<br>  和下面的39题目类似，都是不会剪枝，用哈希表来去重，非常慢但是可以AC。</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.res = []</span><br><span class="line">        <span class="variable language_">self</span>.path = []</span><br><span class="line">        <span class="variable language_">self</span>.aux = <span class="built_in">set</span>()</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">self,choices</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(choices) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">str</span>(<span class="variable language_">self</span>.path) <span class="keyword">not</span> <span class="keyword">in</span> <span class="variable language_">self</span>.aux:</span><br><span class="line">                <span class="variable language_">self</span>.aux.add(<span class="built_in">str</span>(<span class="variable language_">self</span>.path))</span><br><span class="line">                <span class="variable language_">self</span>.res.append(<span class="variable language_">self</span>.path[:])</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        <span class="keyword">for</span> idx,choice <span class="keyword">in</span> <span class="built_in">enumerate</span>(choices):</span><br><span class="line">            <span class="variable language_">self</span>.path.append(choice)</span><br><span class="line">            <span class="variable language_">self</span>.backtrack(choices[:idx] +choices[idx+<span class="number">1</span>:])</span><br><span class="line">            <span class="variable language_">self</span>.path.pop()</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">permuteUnique</span>(<span class="params">self, nums</span>):</span><br><span class="line">        <span class="variable language_">self</span>.backtrack(nums)</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.res</span><br></pre></td></tr></table></figure>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/combination-sum/">Leetcode 39*</a> 组合总和<br>这个题目可以直接套用上面的框架，但是结果是有重复的，个人觉得要剪枝，但是不会剪枝，用了<code>Counter</code>在加如res的时候去重。</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        </span><br><span class="line">        <span class="variable language_">self</span>.res = []</span><br><span class="line">        <span class="variable language_">self</span>.aux_for_drop_same = []</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">self</span>.path = []</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">self,candidates,target</span>):</span><br><span class="line">        path_sum = <span class="built_in">sum</span>(<span class="variable language_">self</span>.path)</span><br><span class="line">        <span class="keyword">if</span> path_sum &gt; target:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">elif</span> path_sum == target:</span><br><span class="line">            <span class="keyword">if</span> Counter(<span class="variable language_">self</span>.path) <span class="keyword">not</span> <span class="keyword">in</span> <span class="variable language_">self</span>.aux_for_drop_same:</span><br><span class="line">                <span class="variable language_">self</span>.aux_for_drop_same.append( Counter(<span class="variable language_">self</span>.path))</span><br><span class="line">                <span class="variable language_">self</span>.res.append(<span class="variable language_">self</span>.path[:])</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">for</span> choice <span class="keyword">in</span> candidates:</span><br><span class="line">                <span class="variable language_">self</span>.path.append(choice)</span><br><span class="line">                <span class="variable language_">self</span>.backtrack(candidates,target)</span><br><span class="line">                <span class="variable language_">self</span>.path.pop()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">combinationSum</span>(<span class="params">self, candidates, target</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type candidates: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="variable language_">self</span>.backtrack(candidates,target)</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.res</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="BFS-算法解题套路框架"><a href="#BFS-算法解题套路框架" class="headerlink" title="BFS 算法解题套路框架"></a><a target="_blank" rel="noopener" href="https://labuladong.online/algo/essential-technique/bfs-framework/">BFS 算法解题套路框架</a></h2><blockquote>
<p>DFS&#x2F;回溯&#x2F;BFS 这类算法，本质上就是把具体的问题抽象成树结构，然后遍历这棵树进行暴力穷举，所以这些穷举算法的代码本质上就是树的遍历代码。在真实的面试笔试题目中，一般不是直接让你遍历树&#x2F;图这种标准数据结构，而是给你一个具体的场景题，<strong>你需要把具体的场景抽象成一个标准的图&#x2F;树结构，然后利用 BFS 算法穷举得出答案。抽象往往是问题的难点</strong></p>
</blockquote>
<p>为啥 BFS 算法经常用来求解最短路径问题？其实所谓的最短路径，都可以类比成二叉树最小深度这类问题（寻找距离根节点最近的叶子节点），<strong>递归遍历必须要遍历整棵树的所有节点才能找到目标节点，而层序遍历不需要遍历所有节点就能搞定</strong>，所以层序遍历适合解决这类最短路径问题。</p>
<p>回忆到之前的<a href="####BFS%E9%81%8D%E5%8E%86%E5%AE%9E%E7%8E%B0">BFS遍历实现</a>,我们总共提到了3种遍历方式：</p>
<ul>
<li><ol>
<li>vinila BFS 最为简单的BFS，无法知道当前的层数</li>
</ol>
</li>
<li><ol start="2">
<li>知道层数的BFS，使用一个队列来存储当前层的节点，遍历完当前层的节点后，增加层数</li>
</ol>
</li>
<li><ol start="3">
<li>知道变长层数的BFS，使用<code>state</code>来存储当前层的节点以及其层数，队列中是state，遍历完当前层的节点后，增加变长层数</li>
</ol>
</li>
</ul>
<h3 id="下面介绍几个BFS的例题："><a href="#下面介绍几个BFS的例题：" class="headerlink" title="下面介绍几个BFS的例题："></a>下面介绍几个BFS的例题：</h3><ul>
<li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sliding-puzzle/">Leetcode 773*</a> 滑动谜题<br>  非常经典的BFS题目，如何抽象成图结构？每个Node其实就是一种<code>board</code>的状态，<code>board</code>的每个状态可以看成是一个节点，<code>board</code>的邻节点就是<code>board</code>的每个状态可以变成的状态，具体可以抽象为：</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Myboard</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, board</span>):</span><br><span class="line">        <span class="variable language_">self</span>.m = <span class="built_in">len</span>(board)</span><br><span class="line">        <span class="variable language_">self</span>.n = <span class="built_in">len</span>(board[<span class="number">0</span>])</span><br><span class="line">        <span class="variable language_">self</span>.board = copy.deepcopy(board)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">uuid</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">str</span>(<span class="variable language_">self</span>.board)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">str</span>(<span class="variable language_">self</span>.board)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.__str__()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__eq__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.uuid() == other.uuid()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">neighbors</span>(<span class="params">self</span>):</span><br><span class="line">        res = []</span><br><span class="line">        idx0, idy = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="variable language_">self</span>.m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="variable language_">self</span>.n):</span><br><span class="line">                <span class="keyword">if</span> <span class="variable language_">self</span>.board[i][j] == <span class="number">0</span>:</span><br><span class="line">                    idx0, idy = i, j</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i, j <span class="keyword">in</span> [(<span class="number">0</span>, <span class="number">1</span>), (<span class="number">0</span>, -<span class="number">1</span>), (<span class="number">1</span>, <span class="number">0</span>), (-<span class="number">1</span>, <span class="number">0</span>)]:</span><br><span class="line">            <span class="keyword">if</span> <span class="number">0</span> &lt;= idx0 + i &lt; <span class="variable language_">self</span>.m <span class="keyword">and</span> <span class="number">0</span> &lt;= idy + j &lt; <span class="variable language_">self</span>.n:</span><br><span class="line">                new_board = copy.deepcopy(<span class="variable language_">self</span>.board)</span><br><span class="line">                new_board[idx0][idy], new_board[idx0 + i][idy + j] = new_board[idx0 + i][idy + j], new_board[idx0][idy]</span><br><span class="line">                res.append(Myboard(new_board))</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p>  有了上述抽象的数据结构，直接套用BFS的框架就可以了，<strong>注意python中二维数据的深度拷贝。</strong></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/open-the-lock/">Leetcode 752*</a> 打开转盘锁<br>  将🔒抽象为：</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Lock</span>:</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, init_lock</span>):</span><br><span class="line">    <span class="variable language_">self</span>.lock = init_lock</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="string">f&quot;Lock:(<span class="subst">&#123;self.lock&#125;</span>)&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__eq__</span>(<span class="params">self, other</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">self</span>.lock == other.lock</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">uuid</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">self</span>.lock</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">neighbors</span>(<span class="params">self</span>):</span><br><span class="line">    neighbors = []</span><br><span class="line">    <span class="keyword">for</span> idx, digit <span class="keyword">in</span> <span class="built_in">enumerate</span>(<span class="variable language_">self</span>.lock):</span><br><span class="line">        <span class="keyword">for</span> delta <span class="keyword">in</span> [-<span class="number">1</span>, <span class="number">1</span>]:</span><br><span class="line">            new_digit = (<span class="built_in">int</span>(digit) + delta) % <span class="number">10</span></span><br><span class="line">            new_lock = <span class="variable language_">self</span>.lock[:idx] + <span class="built_in">str</span>(new_digit) + <span class="variable language_">self</span>.lock[idx + <span class="number">1</span>:]</span><br><span class="line">            neighbors.append(Lock(new_lock))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> neighbors</span><br></pre></td></tr></table></figure>
<p>  对于deadends的处理可以直接加到<code>visited</code>中，这样不会影响整体的逻辑。</p>
</li>
</ul>
<h3 id="BFS优化：双向BFS"><a href="#BFS优化：双向BFS" class="headerlink" title="BFS优化：双向BFS"></a>BFS优化：双向BFS</h3><blockquote>
<p>双向 BFS 的思路是从起点和终点同时开始搜索，直到两者相遇。传统的 BFS 框架是从起点开始向四周扩散，遇到终点时停止；而双向 BFS 则是从起点和终点同时开始扩散，当两边有交集的时候停止。为什么这样能够能够提升效率呢？ 就好比有 A 和 B 两个人，传统 BFS 就相当于 A 出发去找 B，而 B 待在原地不动；双向 BFS 则是 A 和 B 一起出发，双向奔赴。那当然第二种情况下 A 和 B 可以更快相遇。</p>
</blockquote>
<p><strong>无论是单向还是双向算法的复杂度都是O(N)，所以在实际应用中，双向BFS的效率会更高。<strong>但</strong>双向BFS需要你知道destination的状态</strong>，单向BFS不需要你知道destination的状态，如果不知道就没有办法从两端同时开始扩散。可以看如下图：</p>
<p><img src="/../images/image-15.png" alt="alt text"></p>
<p>针对<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/open-the-lock/">Leetcode 752</a> 打开转盘锁，我们可以使用双向BFS来优化，代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Lock</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, init_lock</span>):</span><br><span class="line">        <span class="variable language_">self</span>.lock = init_lock</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;Lock:(<span class="subst">&#123;self.lock&#125;</span>)&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__eq__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(other, Lock):</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">self</span>.lock == other.lock</span><br><span class="line">        <span class="keyword">elif</span> <span class="built_in">isinstance</span>(other, <span class="built_in">str</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">self</span>.lock == other</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> TypeError(<span class="string">&quot;Invalid type&quot;</span>)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__hash__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">hash</span>(<span class="variable language_">self</span>.lock)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">neighbors</span>(<span class="params">self</span>):</span><br><span class="line">        neighbors = []</span><br><span class="line">        <span class="keyword">for</span> idx, digit <span class="keyword">in</span> <span class="built_in">enumerate</span>(<span class="variable language_">self</span>.lock):</span><br><span class="line">            <span class="keyword">for</span> delta <span class="keyword">in</span> [-<span class="number">1</span>, <span class="number">1</span>]:</span><br><span class="line">                new_digit = (<span class="built_in">int</span>(digit) + delta) % <span class="number">10</span></span><br><span class="line">                new_lock = <span class="variable language_">self</span>.lock[:idx] + <span class="built_in">str</span>(new_digit) + <span class="variable language_">self</span>.lock[idx + <span class="number">1</span>:]</span><br><span class="line">                neighbors.append(Lock(new_lock))</span><br><span class="line">        <span class="keyword">return</span> neighbors</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">openLock</span>(<span class="params">self, deadends, target</span>):</span><br><span class="line">        begin = Lock(init_lock=<span class="string">&quot;0000&quot;</span>)</span><br><span class="line">        target = Lock(init_lock=target)</span><br><span class="line">        <span class="keyword">if</span> begin == target:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> begin <span class="keyword">in</span> deadends:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        deadends = <span class="built_in">set</span>([Lock(_) <span class="keyword">for</span> _ <span class="keyword">in</span> deadends])</span><br><span class="line">        b2t_visited = &#123;begin&#125;</span><br><span class="line">        b2t_q = deque([begin])</span><br><span class="line"></span><br><span class="line">        t2b_visited = &#123;target&#125;</span><br><span class="line">        t2b_q = deque([target])</span><br><span class="line"></span><br><span class="line">        depth = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> b2t_q <span class="keyword">and</span> t2b_q:</span><br><span class="line">            depth += <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(b2t_q)):</span><br><span class="line">                curr = b2t_q.popleft()</span><br><span class="line">                <span class="keyword">for</span> neighbor <span class="keyword">in</span> curr.neighbors():</span><br><span class="line">                    <span class="keyword">if</span> neighbor <span class="keyword">in</span> deadends:</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    <span class="keyword">if</span> neighbor <span class="keyword">in</span> t2b_visited:</span><br><span class="line">                        <span class="keyword">return</span> depth</span><br><span class="line">                    <span class="keyword">if</span> neighbor <span class="keyword">not</span> <span class="keyword">in</span> b2t_visited:</span><br><span class="line">                        b2t_q.append(neighbor)</span><br><span class="line">                        b2t_visited.add(neighbor)</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            depth += <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(t2b_q)):</span><br><span class="line">                curr = t2b_q.popleft()</span><br><span class="line">                <span class="keyword">for</span> neighbor <span class="keyword">in</span> curr.neighbors():</span><br><span class="line">                    <span class="keyword">if</span> neighbor <span class="keyword">in</span> deadends:</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    <span class="keyword">if</span> neighbor <span class="keyword">in</span> b2t_visited:</span><br><span class="line">                        <span class="keyword">return</span> depth</span><br><span class="line">                    <span class="keyword">if</span> neighbor <span class="keyword">not</span> <span class="keyword">in</span> t2b_visited:</span><br><span class="line">                        t2b_q.append(neighbor)</span><br><span class="line">                        t2b_visited.add(neighbor)</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>确实是要比单项BFS快很多，<strong>但是双向BFS的实现会比单向BFS复杂很多</strong>。</p>
<h2 id="二叉树系列算法核心纲领"><a href="#二叉树系列算法核心纲领" class="headerlink" title="二叉树系列算法核心纲领"></a><a target="_blank" rel="noopener" href="https://labuladong.online/algo/essential-technique/binary-tree-summary/">二叉树系列算法核心纲领</a></h2><h3 id="二叉树的重要性"><a href="#二叉树的重要性" class="headerlink" title="二叉树的重要性"></a>二叉树的重要性</h3><p>对于如下<code>quicksort</code>和<code>mergesort</code>的实现，我可以说<code>quicksort</code>是二叉树的前序遍历，<code>mergesort</code>是二叉树的后序遍历</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">quick_sort</span>(<span class="params">arr</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(arr) &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> arr</span><br><span class="line">    <span class="comment"># 前序遍历时机点</span></span><br><span class="line">    pivot = arr[<span class="built_in">len</span>(arr) // <span class="number">2</span>]</span><br><span class="line">    left = [x <span class="keyword">for</span> x <span class="keyword">in</span> arr <span class="keyword">if</span> x &lt; pivot]</span><br><span class="line">    middle = [x <span class="keyword">for</span> x <span class="keyword">in</span> arr <span class="keyword">if</span> x == pivot]</span><br><span class="line">    right = [x <span class="keyword">for</span> x <span class="keyword">in</span> arr <span class="keyword">if</span> x &gt; pivot]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 递归调用</span></span><br><span class="line">    <span class="keyword">return</span> quick_sort(left) + middle + quick_sort(right)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">merge_sort</span>(<span class="params">arr</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(arr) &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> arr</span><br><span class="line">    mid = <span class="built_in">len</span>(arr) // <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 递归调用</span></span><br><span class="line">    left = merge_sort(arr[:mid])</span><br><span class="line">    right = merge_sort(arr[mid:])</span><br><span class="line">    <span class="comment"># 后序遍历的时机点</span></span><br><span class="line">    result = []</span><br><span class="line">    i = j = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(left) <span class="keyword">and</span> j &lt; <span class="built_in">len</span>(right):</span><br><span class="line">        <span class="keyword">if</span> left[i] &lt; right[j]:</span><br><span class="line">            result.append(left[i])</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            result.append(right[j])</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">    result.extend(left[i:])</span><br><span class="line">    result.extend(right[j:])</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

<h3 id="深入理解前中后序遍历"><a href="#深入理解前中后序遍历" class="headerlink" title="深入理解前中后序遍历"></a>深入理解前中后序遍历</h3><p>在此之前有个更基本的问题，什么是遍历,什么是<code>traverse</code>？ </p>
<p>遍历就是把数据结构中的每个节点都访问一遍，遍历按照实现的方式可以分为两类：</p>
<ul>
<li><ol>
<li>递归遍历：使用递归函数来遍历数据结构，递归函数的参数是当前节点，返回值是当前节点的值。</li>
</ol>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 递归遍历数组</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">traverse_recursive</span>(<span class="params">arr: <span class="type">List</span>[<span class="built_in">int</span>], i: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">    <span class="keyword">if</span> i == <span class="built_in">len</span>(arr):</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="comment"># 前序位置</span></span><br><span class="line">    traverse_recursive(arr, i + <span class="number">1</span>)</span><br><span class="line">    <span class="comment"># 后序位置</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 递归遍历链表</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">traverse_recursive</span>(<span class="params">head: ListNode</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">    <span class="keyword">if</span> head <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="comment"># 前序位置</span></span><br><span class="line">    traverse_recursive(head.<span class="built_in">next</span>)</span><br><span class="line">    <span class="comment"># 后序位置</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 递归遍历树</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">traverse_recursive</span>(<span class="params">root: TreeNode</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="comment"># 前序位置</span></span><br><span class="line">    traverse_recursive(root.left)</span><br><span class="line">    <span class="comment"># 中序位置，只有二叉搜索树有意义</span></span><br><span class="line">    traverse_recursive(root.right)</span><br><span class="line">    <span class="comment"># 后序位置</span></span><br></pre></td></tr></table></figure></li>
<li><ol start="2">
<li>迭代遍历：不通过调用自身来遍历数据结构，而是使用循环结构来遍历数据结构，迭代遍历的实现方式有很多种，最常见的就是使用栈来模拟递归的过程。</li>
</ol>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 迭代遍历数组</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">traverse_iterative</span>(<span class="params">arr: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(arr)):</span><br><span class="line">        <span class="comment"># do something with arr[i]</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 迭代遍历链表</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">traverse_iterative</span>(<span class="params">head: ListNode</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">    <span class="keyword">while</span> head <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="comment"># do something with head.val</span></span><br><span class="line">        head = head.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 迭代遍历树，如下是dfs的前序遍历实现，迭代的中序和后序遍历一般不用，过于复杂！</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">traverse_iterative</span>(<span class="params">root: TreeNode</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">    stack = [root]</span><br><span class="line">    <span class="keyword">while</span> stack:</span><br><span class="line">        node = stack.pop()</span><br><span class="line">        <span class="comment"># do something with node.val</span></span><br><span class="line">        <span class="keyword">if</span> node.right:</span><br><span class="line">            stack.append(node.right)</span><br><span class="line">        <span class="keyword">if</span> node.left:</span><br><span class="line">            stack.append(node.left)</span><br><span class="line"><span class="comment"># 迭代遍历树，如下是bfs的实现，最常用</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">traverse_iterative</span>(<span class="params">root: TreeNode</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">    queue = [root]</span><br><span class="line">    <span class="keyword">while</span> queue:</span><br><span class="line">        node = queue.pop(<span class="number">0</span>)</span><br><span class="line">        <span class="comment"># do something with node.val</span></span><br><span class="line">        <span class="keyword">if</span> node.left:</span><br><span class="line">            queue.append(node.left)</span><br><span class="line">        <span class="keyword">if</span> node.right:</span><br><span class="line">            queue.append(node.right)</span><br></pre></td></tr></table></figure></li>
</ul>
<table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>递归</strong></th>
<th><strong>迭代</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>实现方式</strong></td>
<td>函数调用自身</td>
<td>使用循环结构</td>
</tr>
<tr>
<td><strong>终止条件</strong></td>
<td>必须显式定义 Base Case</td>
<td>通过循环条件控制</td>
</tr>
<tr>
<td><strong>性能</strong></td>
<td>可能有额外的函数调用开销（栈空间）</td>
<td>通常更高效（无函数调用开销）</td>
</tr>
<tr>
<td><strong>代码可读性</strong></td>
<td>更简洁（对符合递归思维的问题）</td>
<td>可能更直观（线性流程）</td>
</tr>
<tr>
<td><strong>适用问题</strong></td>
<td>问题可分解为同类子问题（如分治）</td>
<td>线性或简单的重复操作</td>
</tr>
<tr>
<td><strong>空间复杂度</strong></td>
<td>可能占用更多栈空间（栈溢出风险）</td>
<td>通常空间效率更高</td>
</tr>
<tr>
<td><strong>缺点</strong></td>
<td>可能导致栈溢出（深度递归）</td>
<td>树结构遍历复杂时代码较长</td>
</tr>
</tbody></table>
<p>说到递归遍历的缺点，如下代码，深度为2128的递归遍历会导致栈溢出，python的默认递归深度为1000，超过这个深度就需要谨慎了。如下的这个例子可以注释不同的print语句来观察前序遍历和后序遍历的区别，非常好的例子。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">traverse_recursive</span>(<span class="params">arr, idx</span>):</span><br><span class="line">    <span class="keyword">if</span> idx == <span class="built_in">len</span>(arr):</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="comment"># print(arr[idx])</span></span><br><span class="line">    traverse_recursive(arr, idx + <span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(arr[idx])</span><br><span class="line">traverse_recursive(<span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">2129</span>)), <span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<hr>
<p>当我们在说前序&#x2F;后序遍历的时候，我们实际上在说什么？</p>
<p>首先前序&#x2F;后序遍历只存在递归遍历中（迭代遍历需要需要使用栈来模拟递归的过程），前序&#x2F;后序遍历是指在递归函数中，当前节点的值在什么时机点被访问。在调用自身之前访问当前节点的值叫做前序遍历，在调用自身之后访问当前节点的值叫做后序遍历。 或者说就是刚进入一个节点（元素）的时候，后序位置就是即将离开一个节点（元素）的时候。总结为：</p>
<ul>
<li>前序遍历：在进入一个节点之前访问它的值&#x2F;递归函数调用自身之前访问它的值</li>
<li>后序遍历：在离开一个节点之前访问它的值&#x2F;递归函数调用自身之后访问它的值</li>
</ul>
<p>具体的图示如下：<br><img src="/../images/image-16.png" alt="alt text"></p>
<p>链表和数组的好好的迭代遍历不用，为什么要用递归遍历？<br>递归遍历可以倒序遍历链表和数组，其实是没啥卵用，而且还容易栈溢出。</p>
<p>多叉树没有中序遍历嘛？<br>准确来说是没有唯一的中序遍历，因为<strong>n叉树的有n-1种中序遍历方式，n叉树的中序遍历是没有意义的。</strong></p>
<hr>
<p>二叉树的所有问题，就是让你在前中后序位置注入巧妙的代码逻辑，去达到自己的目的，你只需要单独思考每一个节点应该做什么，其他的不用你管，抛给二叉树遍历框架，递归会在所有节点上做相同的操作</p>
<h3 id="两种解题思路"><a href="#两种解题思路" class="headerlink" title="两种解题思路"></a>两种解题思路</h3><p>在之前的<a target="_blank" rel="noopener" href="https://labuladong.online/algo/essential-technique/understand-recursion/">一个视角 + 两种思维模式搞定递归</a>中已经提到过，<strong>二叉树解题的思维模式分两类：</strong></p>
<p>1、是否可以通过遍历一遍二叉树得到答案？如果可以，用一个 traverse 函数配合外部变量来实现，这叫「遍历」的思维模式。其函数签名为 <code>void traverse(TreeNode root, ...)</code>，无返回值，遍历过程中修改外部变量。</p>
<blockquote>
<p>遍历这种思维对应这<strong>回溯</strong>，回溯的函数签名为 <code>void backtrack(TreeNode root, ...)</code>，无返回值，遍历过程中修改外部变量。但两者也存在区别<br><code>void backtrack(TreeNode root, ...)</code> 需要在for内部做选择与撤销，重点关注树枝</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">res = []</span><br><span class="line">&gt;path = []</span><br><span class="line">&gt;<span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">路径, 选择列表</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">   <span class="comment"># 触发结束条件，收集结果</span></span><br><span class="line">   <span class="keyword">if</span> 结束条件:</span><br><span class="line">       res.append(path[:])</span><br><span class="line">       <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> 选择 <span class="keyword">in</span> 选择列表:</span><br><span class="line">       <span class="comment"># 做选择</span></span><br><span class="line">       path.append(选择)</span><br><span class="line">       <span class="comment"># 进入下一层决策树</span></span><br><span class="line">       backtrack(路径, 选择列表)</span><br><span class="line">       <span class="comment"># 撤销选择</span></span><br><span class="line">       path.pop()</span><br></pre></td></tr></table></figure>
<p><code>void traverse(TreeNode root, ...)</code> 不需要在for内部做选择与撤销，重点关注树的节点</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">res = []</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">traverse</span>(<span class="params">root, ...</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="comment"># 前序遍历时机点</span></span><br><span class="line">    <span class="keyword">for</span> child <span class="keyword">in</span> root.children:</span><br><span class="line">        traverse(child, ...)</span><br><span class="line">    <span class="comment"># 后序遍历时机点</span></span><br></pre></td></tr></table></figure></blockquote>
<p>2、是否可以定义一个递归函数，通过子问题（子树）的答案推导出原问题的答案？如果可以，写出这个递归函数的定义，并充分利用这个函数的返回值，这叫「分解问题」的思维模式。 其函数签名为 <code>T func(TreeNode root, ...)</code> ，存在返回值，函数的返回值就是原问题的答案，常见的有<code>int fibonacci(int n)</code>、<code>int maxDepth(TreeNode root)</code>等。</p>
<blockquote>
<p>分解问题这种思维对应着<strong>动态规划</strong>，都是devide and conquer 的思维模式。不同的是，动态规划是自底向上的思维模式，<strong>而递归是自顶向下的思维模式</strong>。</p>
</blockquote>
<hr>
<p><strong>上述的两种思维模式不是互斥的</strong>，有的问题可以都从这两种思维模式来解决。<code>void traverse(...)</code>得到前序，中序，后序的时候非常简单，只用决策将<code>self.res.append(root.val)</code>放在不同的位置就可以了,同样的递归也可以实现上述的功能。但为什么很少看到这种写法呢？原因是这个方法依赖<code>list.addAll</code>,由于list是连续的内存空间，所以<code>list.addAll</code>的时间复杂度是O(N)，而递归的时间复杂度是O(1)，所以递归的时间复杂度更低。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">pre</span>/<span class="keyword">in</span>/post_order_traversal(root) -&gt; <span class="type">List</span>:</span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="comment"># pre</span></span><br><span class="line">    <span class="keyword">return</span> [root.val] + pre/<span class="keyword">in</span>/post_order_traversal(root.left) + pre/<span class="keyword">in</span>/post_order_traversal(root.right)</span><br><span class="line">    <span class="comment"># in</span></span><br><span class="line">    <span class="keyword">return</span>  pre/<span class="keyword">in</span>/post_order_traversal(root.left)+[root.val] + pre/<span class="keyword">in</span>/post_order_traversal(root.right)</span><br><span class="line">    <span class="comment"># post</span></span><br><span class="line">    <span class="keyword">return</span> pre/<span class="keyword">in</span>/post_order_traversal(root.left) + pre/<span class="keyword">in</span>/post_order_traversal(root.right)+[root.val]</span><br></pre></td></tr></table></figure>


<p>**其次思维2也可以融合思维1，**思维2的递归也是在遍历，可以在遍历的过程中，更新外部变量，达到遍历的效果。例如<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/diameter-of-binary-tree/">二叉树直径</a>就是一个思维1和2的融合</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 思维1,全局变量</span></span><br><span class="line">diameter = <span class="number">0</span></span><br><span class="line"><span class="comment"># 思维2</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">maxDepth</span>(<span class="params">root</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    left = maxDepth(root.left)</span><br><span class="line">    right = maxDepth(root.right)</span><br><span class="line">    <span class="comment"># 思维1,更新全局变量</span></span><br><span class="line">    diameter = <span class="built_in">max</span>(diameter, left + right)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(left, right) + <span class="number">1</span></span><br></pre></td></tr></table></figure>





<h3 id="后序遍历的特殊之处"><a href="#后序遍历的特殊之处" class="headerlink" title="后序遍历的特殊之处"></a>后序遍历的特殊之处</h3><p>对于<code>void traverse(...)</code>来说,其三个时间点</p>
<ul>
<li>前序遍历时机点：第一次进入这个节点，只知道其父节点的信息</li>
<li>中序遍历时机点：第二次进入这个节点，知道其父节点的信息 + 部分子树的信息</li>
<li>后序遍历时机点：第三次进入这个节点，知道其父节点的信息 + 所有子树的信息</li>
</ul>
<p>前序遍历是最朴素的</p>
<p>中序遍历只知道部分子树的信息，其的特殊点是在BST中可输出有序结果，但在多叉树中没有意义。</p>
<p>后序遍历是威力最大的，因为其知道的信息是最多的，如下两个问题：</p>
<ul>
<li>Q1:如何打印出每一个节点所在的层数？</li>
<li>Q2:如何打印出每个节点的左右子树各有多少节点？</li>
</ul>
<table>
<thead>
<tr>
<th><strong>问题</strong></th>
<th><strong>前序遍历</strong></th>
<th><strong>中序遍历</strong></th>
<th><strong>后序遍历</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Q1</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>Q2</td>
<td>×</td>
<td>x</td>
<td>√</td>
</tr>
</tbody></table>
<h3 id="以树的视角看动归-回溯-DFS算法的区别和联系"><a href="#以树的视角看动归-回溯-DFS算法的区别和联系" class="headerlink" title="以树的视角看动归&#x2F;回溯&#x2F;DFS算法的区别和联系"></a>以树的视角看动归&#x2F;回溯&#x2F;DFS算法的区别和联系</h3><table>
<thead>
<tr>
<th>方法</th>
<th>以树的视角</th>
<th>特点</th>
<th>经典题目</th>
</tr>
</thead>
<tbody><tr>
<td>(树形)动规</td>
<td>根节点是原问题，<strong>子树是子问题</strong></td>
<td>将树分解为重叠子问题，通过记忆化或自底向上</td>
<td><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/house-robber/">打家劫舍</a><br>  <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/coin-change/">找零钱</a> <br></td>
</tr>
<tr>
<td>DFS</td>
<td>从根节点出发，尽可能深地访问子节点，直到叶子<strong>节点</strong></td>
<td>无状态性：不关心子问题的合并或路径的选择，仅完成对节点的遍历或简单操作</td>
<td><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-preorder-traversal/">二叉树的前序遍历</a> <br> <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/number-of-islands/">岛屿数量</a> <br></td>
</tr>
<tr>
<td>回溯</td>
<td>回溯是DFS在解空间树上的应用，关注<strong>树枝(i.e.选择)的收集</strong></td>
<td>状态管理：需要维护和回撤路径状态（如移除已选元素）。<br>剪枝优化：提前终止不符合条件的路径（如组合总和问题）。</td>
<td><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/permutations/">全排列</a> <br> <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/combination-sum/">组合总和</a> <br></td>
</tr>
</tbody></table>
<p>关于<code>void traverse(...)</code> 中的前序，后序时机，以及<code>void backtrack(...)</code>中的选择和撤销时机，如下的代码很好反应的上述的区别：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># traverse 把「做选择」「撤销选择」的逻辑放在 for 循环外面</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">traverse</span>(<span class="params">root</span>):</span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="comment"># 做选择</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;enter node %s&quot;</span> % root)</span><br><span class="line">    <span class="keyword">for</span> child <span class="keyword">in</span> root.children:</span><br><span class="line">        traverse(child)</span><br><span class="line">    <span class="comment"># 撤销选择</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;leave node %s&quot;</span> % root)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 回溯算法把「做选择」「撤销选择」的逻辑放在 for 循环里面</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">root</span>):</span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">for</span> child <span class="keyword">in</span> root.children:</span><br><span class="line">        <span class="comment"># 做选择</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;I&#x27;m on the branch from %s to %s&quot;</span> % (root, child))</span><br><span class="line">        backtrack(child)</span><br><span class="line">        <span class="comment"># 撤销选择</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;I&#x27;ll leave the branch from %s to %s&quot;</span> % (child, root))</span><br></pre></td></tr></table></figure>






<h3 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h3><p>除了队列实现的3种层序遍历，还有不用队列的方法,这个方法是我之前老爱用的方法，最为直观。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">level_traverse</span>(<span class="params">root</span>):</span><br><span class="line">    level = <span class="number">0</span></span><br><span class="line">    curr_level = [root]</span><br><span class="line">    next_level = []</span><br><span class="line">    <span class="keyword">while</span> curr_level:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;level <span class="subst">&#123;level&#125;</span> with : <span class="subst">&#123;[node.val <span class="keyword">for</span> node <span class="keyword">in</span> curr_level]&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> curr_level:</span><br><span class="line">            <span class="comment"># do something with node.val</span></span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                next_level.append(node.left)</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                next_level.append(node.right)</span><br><span class="line">        curr_level = next_level</span><br><span class="line">        next_level = []</span><br><span class="line">        level += <span class="number">1</span></span><br></pre></td></tr></table></figure>




<h2 id="回溯算法秒杀所有排列-组合-子集问题"><a href="#回溯算法秒杀所有排列-组合-子集问题" class="headerlink" title="回溯算法秒杀所有排列&#x2F;组合&#x2F;子集问题"></a><a target="_blank" rel="noopener" href="https://labuladong.online/algo/essential-technique/permutation-combination-subset-all-in-one/">回溯算法秒杀所有排列&#x2F;组合&#x2F;子集问题</a></h2><h3 id="什么是排列-组合-子集问题问题？"><a href="#什么是排列-组合-子集问题问题？" class="headerlink" title="什么是排列&#x2F;组合&#x2F;子集问题问题？"></a>什么是排列&#x2F;组合&#x2F;子集问题问题？</h3><p>最基础地，给定<code>nums=[1,2,3]</code>数组，我们定义<code>n= len(nums)</code>，</p>
<ul>
<li>排列问题就是输出<code>n!</code>个元素的所有排列组合，例如<code>[1,2,3]</code>的排列组合有<code>[[1,2,3]</code>、<code>[1,3,2]</code>、<code>[2,1,3]</code>、<code>[2,3,1]</code>、<code>[3,1,2]</code>、<code>[3,2,1]]</code></li>
<li>组合问题一般给定<code>k</code>，输出<code>C_n^k</code>个元素的所有组合，例如<code>[1,2,3]的k=2</code>的组合有<code>[[1,2]</code>、<code>[1,3]</code>、<code>[2,3]]</code></li>
<li>子集问题就是输出$C_n^0+C_n^1+C_n^2+…+C_n^n &#x3D; 2^n$个元素的所有子集，例如<code>[1,2,3]</code>的组合有<code>[],[1]</code>、<code>[2]</code>、<code>[3]</code>、<code>[1,2]</code>、<code>[1,3]</code>、<code>[2,3]</code>、<code>[1,2,3]</code>, 或者给定某种条件的子集，如给一个<code>target</code>，输出所有和为<code>target</code>的子集，例如<code>target=3</code>的子集有<code>[[1,2]</code>、<code>[3]]</code></li>
</ul>
<p><strong>可见组合和子集问题本质上就是一类问题，组合只不过是子集问题的一个特例，限制了长度的子集问题</strong>。 回溯算法十分适合解决这类问题，上述三种&#x2F;两类问题的决策树，详见下图。</p>
<h3 id="元素不重复不可复选"><a href="#元素不重复不可复选" class="headerlink" title="元素不重复不可复选"></a>元素不重复不可复选</h3><p>最简单的情况，上述已经讨论过了，直接套用回溯算法的框架就可以了，重点关注排列与组合&#x2F;子集在<code>candidates</code>更新上的区别。</p>
<p><img src="/../images/image-21.png" alt="alt text"></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/permutations/">Leetcode 46</a> 全排列</li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/subsets/">Leetcode 78</a> 子集</li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/combinations/">Leetcode 77</a> 组合</li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/combination-sum-iii/">Leetcode 216</a> 组合总和 III</li>
</ul>
<h3 id="元素重复不可复选"><a href="#元素重复不可复选" class="headerlink" title="元素重复不可复选"></a>元素重复不可复选</h3><p>最笨比的方法就是全部遍历，添加的时候用哈希表+字符串去重，也能过所有测试。比较聪明的方法是剪枝，下面用剪枝的方法：<br><img src="/../images/image-19.png" alt="alt text"></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/permutations-ii/">Leetcode 47</a> 全排列 II</li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/subsets-ii/">Leetcode 90</a> 子集 II</li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/combination-sum-ii/">Leetcode 40</a> 组合总和 II</li>
</ul>
<h3 id="元素不重复可复选"><a href="#元素不重复可复选" class="headerlink" title="元素不重复可复选"></a>元素不重复可复选</h3><p>由于元素可以重复选，所以决策集不可能为空，树会一直长，所以找出排列是没有意义的，因为上述问题等价于<code>nums = [1,...1,2...2,3...3]</code>的元素重复不可复选问题，排列和子集有无穷多种，但是给定一个<code>target</code>的组合总和问题是有限的，所以我们可以用回溯算法来解决这个问题，重点注意的是<code>candidates</code>的更新方式，即<code>candidates</code>的更新方式是<code>candidates[i:]</code>，而不是<code>candidates[i+1:]</code>因为一个元素是可以重复选的。<br><img src="/../images/image-20.png" alt="alt text"></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/combination-sum/">Leetcode 39</a> 组合总和</li>
</ul>
<h3 id="元素重复可复选"><a href="#元素重复可复选" class="headerlink" title="元素重复可复选"></a>元素重复可复选</h3><p>… 可复选了还在乎重复吗？等价于 <a href="###%E5%85%83%E7%B4%A0%E4%B8%8D%E9%87%8D%E5%A4%8D%E5%8F%AF%E5%A4%8D%E9%80%89">元素不重复可复选</a></p>
<h2 id="贪心算法解题套路框架"><a href="#贪心算法解题套路框架" class="headerlink" title="贪心算法解题套路框架"></a><a target="_blank" rel="noopener" href="https://labuladong.online/algo/essential-technique/greedy/">贪心算法解题套路框架</a></h2><p>贪心算法是指在每一步选择中都采取在当前状态下最好或最优（即最有利）的选择，从而<strong>希望</strong>导致结果是一个全局最好或最优的解。但实际上，贪心算法并不一定能得到全局最优解，贪心算法得到最优解的条件是：<strong>贪心选择性质</strong>和<strong>最优子结构</strong>。</p>
<ul>
<li><strong>贪心选择性质(Greedy Choice Property)</strong>：局部最优解可以推导出全局最优解</li>
<li><strong>最优子结构(Optimal Substructure)</strong>：一个问题的最优解包含其子问题的最优解</li>
</ul>
<p>考虑如下4种情况：</p>
<h3 id="1-具备贪心选择性质和最优子结构"><a href="#1-具备贪心选择性质和最优子结构" class="headerlink" title="1.具备贪心选择性质和最优子结构"></a>1.具备贪心选择性质和最优子结构</h3><p>问题：<strong>[1，100]两种纸币，只能拿3次，求最多拿多少</strong></p>
<ul>
<li><strong>具备贪心选择性质：</strong> 每次最贪的拿，就是最优解为[100,100,100]</li>
<li><strong>具备最优子结构：</strong> 最优的[100,100,100]包含了拿2次的最优解[100,100]和拿1次的最优解[100]</li>
</ul>
<h3 id="2-具备贪心选择性质但不具备最优子结构"><a href="#2-具备贪心选择性质但不具备最优子结构" class="headerlink" title="2.具备贪心选择性质但不具备最优子结构"></a>2.具备贪心选择性质但不具备最优子结构</h3><p>不存在吧？感觉没有</p>
<h3 id="3-不具备贪心选择性质但具备最优子结构"><a href="#3-不具备贪心选择性质但具备最优子结构" class="headerlink" title="3.不具备贪心选择性质但具备最优子结构"></a>3.不具备贪心选择性质但具备最优子结构</h3><p>问题：<strong>DAG的最长路径问题</strong>，例如想计算<code>u</code>到<code>v</code>的最长路径, 如下图</p>
<pre class="mermaid">graph TB
   u --10--> A
   A --2--> B
   B --1--> v
   u --1--> C
   C --1--> D
   A--1-->D
   D --1000--> v</pre>
<ul>
<li><strong>不具备贪心选择性质：</strong> 按照贪心算法的思路，应该选择<code>u-&gt;A-&gt;B-&gt;v</code>，但是实际上<code>u-&gt;A-&gt;D-&gt;v</code>才是最长路径。</li>
<li><strong>具备最优子结构：</strong> <code>u-&gt;A-&gt;D-&gt;v</code>是最优解，包含了u到A的最优解<code>u-&gt;A</code>和u到D的最优解<code>u-&gt;A-&gt;D</code></li>
</ul>
<p><strong>不具备贪心选择性质但具备最优子结构的情况不能用贪心算法来解决</strong></p>
<h3 id="4-不具备贪心选择性质和最优子结构"><a href="#4-不具备贪心选择性质和最优子结构" class="headerlink" title="4.不具备贪心选择性质和最优子结构"></a>4.不具备贪心选择性质和最优子结构</h3><p>问题：TSP</p>
<ul>
<li><p><strong>不具备贪心选择性质：</strong> 每次找没有访问且离当前节点最近的节点不一定是最优解</p>
</li>
<li><p><strong>不具备最优子结构：</strong> 这是肯定的，如果<code>u-&gt;A-&gt;B-&gt;C-&gt;D-&gt;u</code>是最优解，删除D的子问题的最优解不一定为<code>u-&gt;A-&gt;B-&gt;C-&gt;u</code>，可能是<code>u-&gt;B-&gt;A-&gt;C-&gt;u</code>，所以不具备最优子结构</p>
</li>
</ul>
<hr>
<h3 id="贪心算法的解题步骤"><a href="#贪心算法的解题步骤" class="headerlink" title="贪心算法的解题步骤"></a>贪心算法的解题步骤</h3><ul>
<li>没有框架和套路</li>
<li>没必要刻意地识别一道题是否具备贪心选择性质</li>
<li>你只需时刻记住，算法的本质是穷举，遇到任何题目都要先想暴力穷举思路<ul>
<li><strong>超时</strong>说明穷举的过程中如果存在冗余计算，就用memo化来优化</li>
<li><strong>还是超时</strong> 说明穷举的过程中没有冗余计算，说明不需要穷举所有的解空间就能求出最优解，这种情况下肯定需要用到贪心算法。你可以仔细观察题目，是否可以提前排除掉一些不合理的选择，是否可以直接通过局部最优解推导全局最优解。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/jump-game/">Leetcode 55*</a> 跳跃游戏<br>直接暴力枚举所有可能：</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 暴力枚举</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.res = []</span><br><span class="line">        <span class="variable language_">self</span>.track = []</span><br><span class="line">        <span class="variable language_">self</span>.nums = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">sum</span>(<span class="variable language_">self</span>.track) &gt;= <span class="built_in">len</span>(<span class="variable language_">self</span>.nums) - <span class="number">1</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="variable language_">self</span>.track)</span><br><span class="line">            <span class="variable language_">self</span>.res.append(<span class="variable language_">self</span>.track[:])</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        candidates = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">1</span>, <span class="number">1</span> + <span class="variable language_">self</span>.nums[<span class="built_in">sum</span>(<span class="variable language_">self</span>.track)]))</span><br><span class="line">        <span class="keyword">for</span> candidate <span class="keyword">in</span> candidates:</span><br><span class="line">            <span class="variable language_">self</span>.track.append(candidate)</span><br><span class="line">            <span class="variable language_">self</span>.backtrack()</span><br><span class="line">            <span class="variable language_">self</span>.track.pop()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">canJump</span>(<span class="params">self, nums</span>):</span><br><span class="line">        <span class="variable language_">self</span>.nums = nums</span><br><span class="line">        <span class="variable language_">self</span>.backtrack()</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.res != []</span><br></pre></td></tr></table></figure>
<p>想法是对的，但是TLE，暴力枚举的时间复杂度是O(2^n)，所以我们需要用贪心算法来解决这个问题。</p>
<p>例如对于<code>nums = [2,3,1,1,4]</code>我们的贪心不是每一步都跳最大，i.e. 每一步就跳&#96;&#96;nums[i]<code>，而是我们关心，**别管我具体跳多少，而是我能达到最远的地方是什么，我们用</code>farthest&#96;来表示我们能到达的最远的地方**。 每次贪心前我们看看能不能贪，是不是已经G了</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 贪心算法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">canJump</span>(<span class="params">self, nums </span>)  :</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        farthest = <span class="number">0</span> + nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> idx, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            <span class="keyword">if</span> idx &lt;= farthest:</span><br><span class="line">                farthest = <span class="built_in">max</span>(farthest, idx + num)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/jump-game-ii/">Leetcode 45*</a> 跳跃游戏 II<br>同理最为朴素的就是暴力枚举了，把所有的可行解都找出来：</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 暴力枚举</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.res = []</span><br><span class="line">        <span class="variable language_">self</span>.track = [] <span class="comment"># 记录每次跳的步数</span></span><br><span class="line">        <span class="variable language_">self</span>.nums = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">sum</span>(<span class="variable language_">self</span>.track) &gt;= <span class="built_in">len</span>(<span class="variable language_">self</span>.nums) - <span class="number">1</span>:</span><br><span class="line">            <span class="variable language_">self</span>.res.append(<span class="variable language_">self</span>.track[:])</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="comment"># 所有可以跳的步数的集合</span></span><br><span class="line">        <span class="comment"># 这里倒序是因为想让他往原处跳，其实没啥用</span></span><br><span class="line">        <span class="comment"># 因为整个递归树都要被遍历</span></span><br><span class="line">        candidates = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">1</span>, <span class="number">1</span> + <span class="variable language_">self</span>.nums[<span class="built_in">sum</span>(<span class="variable language_">self</span>.track)]))[::-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> candidate <span class="keyword">in</span> candidates:</span><br><span class="line">            <span class="variable language_">self</span>.track.append(candidate)</span><br><span class="line">            <span class="variable language_">self</span>.backtrack()</span><br><span class="line">            <span class="variable language_">self</span>.track.pop()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">jump</span>(<span class="params">self, nums</span>):</span><br><span class="line">        <span class="variable language_">self</span>.nums = nums</span><br><span class="line">        <span class="variable language_">self</span>.backtrack()</span><br><span class="line">        <span class="built_in">print</span>(<span class="variable language_">self</span>.res)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>([<span class="built_in">len</span>(_) <span class="keyword">for</span> _ <span class="keyword">in</span>  <span class="variable language_">self</span>.res])</span><br></pre></td></tr></table></figure>
<p>上述方法暴力回溯了所有可能解，把所有的可行解都保存了下来，最后返回了长度最小的解，时间复杂度是O(2^n)，TLE了。不难观察到这个问题有重叠子问题的性质，我们定义<br>$$<br>dp[i] &#x3D; \text{从位置 i 到达最后一个位置所需的最少跳跃次数}<br>$$<br>对于问题给定的第一个测样例<code>nums = [2,3,1,1,4]</code>,不难看出，原问题的答案就是<code>dp[0]</code>,我们先看一下<code>dp[4] = 0</code>，因为已经到达了最后一个位置，所以<code>dp[4] = 0</code>。然后我们看<code>dp[3] = 1</code>，因为从<code>3-&gt;4</code>只需要跳一次，所以<code>dp[3] = 1</code>。接下来我们看<code>dp[2] = 1 + min(dp[3]) = 2</code>，因为2只能到达3，所以<code>dp[2] = 1 + min(dp[3]) = 2</code>。接下来我们看<code>dp[1] = 1 + min(dp[2], dp[3]，dp[4]) = 1 + min(2, 1, 0) = 1 + 0 = 1</code>。最后我们看<code>dp[0] = 1 + min(dp[1], dp[2]) = 1 + min(1, 2) = 1 + 1 = 2</code>。所以我们可以得到<code>dp[0] = 2</code>，即从<code>0-&gt;1-&gt;4</code>只需要跳两次。其状态转移方程为：<br>$$<br>dp[i] &#x3D; 1 + min(dp[i+1], dp[i+2], …, dp[i+nums[i]])<br>$$</p>
<p>基于上述dp的方法+memo的优化，我们可以得到如下的代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 动态规划+memo化</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.nums = <span class="literal">None</span></span><br><span class="line">        <span class="variable language_">self</span>.n = <span class="literal">None</span></span><br><span class="line">        <span class="variable language_">self</span>.memo = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dp</span>(<span class="params">self, idx</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        从idx跳到self.nums的末尾的步数</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> idx <span class="keyword">in</span> <span class="variable language_">self</span>.memo:</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">self</span>.memo[idx]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> idx &gt;= <span class="variable language_">self</span>.n - <span class="number">1</span>:</span><br><span class="line">            <span class="variable language_">self</span>.memo[idx] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># assert 0&lt;= idx &lt;self.n</span></span><br><span class="line">        <span class="keyword">elif</span> <span class="variable language_">self</span>.nums[idx] == <span class="number">0</span>:</span><br><span class="line">            <span class="variable language_">self</span>.memo[idx] = <span class="number">2</span> ** <span class="number">31</span> - <span class="number">1</span> <span class="comment"># 无解</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># assert self.nums[idx] &gt;= 1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="variable language_">self</span>.memo[idx] = <span class="number">1</span> + <span class="built_in">min</span>([<span class="variable language_">self</span>.dp(_) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(idx + <span class="number">1</span>, idx + <span class="variable language_">self</span>.nums[idx] + <span class="number">1</span>)])</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.memo[idx]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">jump</span>(<span class="params">self, nums</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="variable language_">self</span>.nums = nums</span><br><span class="line">        <span class="variable language_">self</span>.n = <span class="built_in">len</span>(<span class="variable language_">self</span>.nums)</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.dp(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p><img src="/../images/image-22.png" alt="alt text"><br>上图这种情况，我们站在索引 0 的位置，可以向前跳 1，2 或 3 步，你说应该选择跳多少呢？</p>
<p>你可以确定地说，<strong>应该跳 2 步调到索引 2，因为 nums[2] 的可跳跃区域涵盖了索引区间 [3..6]，比其他的都大。题目求最少的跳跃次数，那么往索引 2 跳必然是最优的选择。这就是贪心选择性质，</strong></p>
<p>我们不需要真的递归穷举出所有选择的具体结果来比较求最值，而只需要每次选择那个最有潜力的局部最优解，最终就能得到全局最优解。针对上述的贪心策略，我们可以得到如下的代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">jump</span>(<span class="params">self, nums</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        jumps_cnt, curr_pos = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> curr_pos &lt; n - <span class="number">1</span>:</span><br><span class="line">            <span class="comment"># 下一次可以跳到的位置</span></span><br><span class="line">            choices = [choice <span class="keyword">for</span> choice <span class="keyword">in</span> <span class="built_in">range</span>(curr_pos + <span class="number">1</span>, <span class="built_in">min</span>(curr_pos + nums[curr_pos] + <span class="number">1</span>, n))]</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 直接跳过去了，避免出现nums = [2,100000,1]第一下不跳过去，选择跳到1</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">max</span>(choices) &gt;= n - <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> jumps_cnt + <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 加上跳到c后可以最远跳到的位置</span></span><br><span class="line">            choices = [(c + nums[c], c) <span class="keyword">for</span> c <span class="keyword">in</span> choices]</span><br><span class="line">            choices.sort(reverse=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">            curr_pos = choices[<span class="number">0</span>][<span class="number">1</span>]</span><br><span class="line">            jumps_cnt += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> jumps_cnt</span><br></pre></td></tr></table></figure>






<h2 id="分治算法解题套路框架"><a href="#分治算法解题套路框架" class="headerlink" title="分治算法解题套路框架"></a><a target="_blank" rel="noopener" href="https://labuladong.online/algo/essential-technique/divide-and-conquer/">分治算法解题套路框架</a></h2><h3 id="分治思想"><a href="#分治思想" class="headerlink" title="分治思想"></a>分治思想</h3><p>分治的思想广泛的存在算法当中：</p>
<ul>
<li>递归：将一个问题分解为多个子问题，递归地解决每个子问题，然后将它们的解合并起来，eg. fibonacci数列</li>
<li>动划：动态规划的递归形式自不必多说，自底向上的也是分治的思想，从base case开始，逐步向上推导出原问题的解</li>
<li>回溯：回溯似乎不算是某种分治思想，但是硬要说有分治也行，因为将整体解分了若干层，先选第一步，然后再选第二步，直到选完所有的步骤，最后再回溯到第一步，选第二步，直到选完所有的步骤，也算是分治的思想吧？</li>
</ul>
<p>有分治思想的算法很多，但不是分治算法，<strong>分治算法与上述有分治思想的算法有本质的区别！</strong></p>
<h3 id="分治算法"><a href="#分治算法" class="headerlink" title="分治算法"></a>分治算法</h3><p>一般分为三步：</p>
<ul>
<li><strong>分解</strong>：将原问题分解为若干个子问题，通常是相同类型的子问题</li>
<li><strong>解决</strong>：递归地解决每个子问题，直到子问题足够小，可以直接求解</li>
<li><strong>合并</strong>：将子问题的解合并成原问题的解</li>
</ul>
<p>伪代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">divide_conquer</span>(<span class="params">problem</span>):</span><br><span class="line">    <span class="comment"># 递归终止条件</span></span><br><span class="line">    <span class="keyword">if</span> problem <span class="keyword">is</span> small enough:</span><br><span class="line">        <span class="keyword">return</span> solution</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 分解子问题</span></span><br><span class="line">    subproblems = split_problem(problem)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 递归解决子问题</span></span><br><span class="line">    subresult1 = divide_conquer(subproblems[<span class="number">0</span>])</span><br><span class="line">    subresult2 = divide_conquer(subproblems[<span class="number">1</span>])</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 合并结果</span></span><br><span class="line">    result = merge(subresult1, subresult2)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<p>分治的子问题如果不独立，i.e. 存在重叠子问题的情况，那么这个时候用分治就有点低效了，要用动态规划或者memo递归了。</p>
<h4 id="无效的分治算法"><a href="#无效的分治算法" class="headerlink" title="无效的分治算法"></a>无效的分治算法</h4><p>基于上面有分治思想的的几个例子，我们发现</p>
<ul>
<li><strong>1.分治是广泛存在的</strong></li>
<li><strong>2. 分治思想不一定减小复杂度</strong> 例如：</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 没有分治思想的算法，复杂度为O(n)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sum</span>(<span class="params">nums</span>)-&gt; <span class="built_in">int</span>:</span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">        res += num</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 有分治思想但不减小复杂度的算法，递归树的高度为n，宽度为1，遍历节点数量为n，复杂度为O(n)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sum</span>(<span class="params">nums</span>)-&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">return</span> nums[<span class="number">0</span>] + <span class="built_in">sum</span>(nums[<span class="number">1</span>:])</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 有分治思想但不减小复杂度的算法，加上二分的思想，递归树的高度为log(n)，宽度不为1，遍历节点数量为n，复杂度为O(nlog(n))</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sum</span>(<span class="params">nums</span>)-&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">    mid = <span class="built_in">len</span>(nums) // <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span>(nums[:mid]) + <span class="built_in">sum</span>(nums[mid:])</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>再者用二分的方式进行分治可以将递归树的深度从O(n)减少到O(logn)，但是宽度不为1，遍历节点数量为n，所以复杂度为O(N),而不是O(logn)</strong> 确实有优化效果。对于上面这个元素求和的例子，无论怎么分治都不如原解法高效，但可以看出二分的分治方式是确实有助于减少递归树的高度。</li>
</ul>
<h4 id="有效的分治"><a href="#有效的分治" class="headerlink" title="有效的分治"></a>有效的分治</h4><p>把递归算法抽象成递归树，<strong>如果递归树节点的时间复杂度和树的深度相关，那么使用分治思想对问题进行二分</strong>就可以使递归树尽可能平衡，进而优化总的时间复杂度。对于一个原复杂度为O(n^2)的算法，我们分成m个小问题<br>$$<br>n^2 &gt; (n&#x2F;m)^2 + … + (n&#x2F;m)^2 &#x3D; n^2&#x2F;m<br>$$<br>做一个如下的试验，插入排序的复杂度为O(n^2)，我们可以将其分成5个桶，确实要快一些：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">insertion_sort</span>(<span class="params">nums</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i, <span class="number">0</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> nums[j] &lt; nums[j - <span class="number">1</span>]:</span><br><span class="line">                nums[j], nums[j - <span class="number">1</span>] = nums[j - <span class="number">1</span>], nums[j]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bucket_sort</span>(<span class="params">arr, bucket_size=<span class="number">5</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;桶排序</span></span><br><span class="line"><span class="string">    :param arr: 输入数组</span></span><br><span class="line"><span class="string">    :param bucket_size: 每个桶的大小（默认5）</span></span><br><span class="line"><span class="string">    :return: 排序后的数组</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(arr) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> arr</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 确定数据的范围</span></span><br><span class="line">    min_val, max_val = <span class="built_in">min</span>(arr), <span class="built_in">max</span>(arr)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算需要的桶数量</span></span><br><span class="line">    bucket_count = (max_val - min_val) // bucket_size + <span class="number">1</span></span><br><span class="line">    buckets = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(bucket_count)]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将数据分配到各个桶中</span></span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> arr:</span><br><span class="line">        index = (num - min_val) // bucket_size</span><br><span class="line">        buckets[index].append(num)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 对每个桶进行插入排序，并合并结果</span></span><br><span class="line">    sorted_arr = []</span><br><span class="line">    <span class="keyword">for</span> bucket <span class="keyword">in</span> buckets:</span><br><span class="line">        insertion_sort(bucket)  <span class="comment"># 使用插入排序</span></span><br><span class="line">        sorted_arr.extend(bucket)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sorted_arr</span><br><span class="line"></span><br><span class="line">nums = [random.randint(<span class="number">0</span>, <span class="number">100</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10000</span>)]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">start = time.time()</span><br><span class="line">insertion_sort(nums[:])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;插入排序耗时：&quot;</span>, time.time() - start)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">start = time.time()</span><br><span class="line">bucket_sort(nums[:])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;桶排序耗时：&quot;</span>, time.time() - start)</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">插入排序耗时： <span class="number">4.030400514602661</span></span><br><span class="line">桶排序耗时： <span class="number">0.14693975448608398</span></span><br></pre></td></tr></table></figure>
<p>差了30倍，确实是有分治的效果。<strong>感觉就是多掏一些分解和合并的世界，减小求解的时间，从而整体上提高效率。</strong></p>
<h2 id="算法时空复杂度分析实用指南"><a href="#算法时空复杂度分析实用指南" class="headerlink" title="算法时空复杂度分析实用指南"></a><a target="_blank" rel="noopener" href="https://labuladong.online/algo/essential-technique/complexity-analysis/">算法时空复杂度分析实用指南</a></h2><h3 id="借助复杂度反推解题思路"><a href="#借助复杂度反推解题思路" class="headerlink" title="借助复杂度反推解题思路"></a>借助复杂度反推解题思路</h3><blockquote>
<p>不要以为复杂度分析是专门用来难为你的，它其实是来帮你的，它是来偷偷告诉你解题思路的。</p>
</blockquote>
<p>你应该在开始写代码之前就留意题目给的数据规模,例如给定一个<code>n=10^6</code></p>
<ul>
<li>你给一个O(2^n)的算法，肯定会TLE，因为<code>2^10^6</code>是个天文数字</li>
<li>你给一个O(n^2)的算法，可能会TLE，因为<code>10^6*10^6=10^12</code>,实际上到<code>10^4</code>的问题规模就很可能要TLE了<ul>
<li>得提供一个O(nlogn)的算法，或者O(n)的算法,想想对数组进行排序处理、前缀和、双指针、一维 dp 等等，从这些思路切入就比较靠谱。</li>
<li>像嵌套 for 循环、二维 dp、回溯算法这些思路，基本可以直接排除掉了</li>
</ul>
</li>
</ul>
<p>如果给你的<strong>问题规模比较小则说明肯定是因为最优解就是指数&#x2F;阶乘级别的复杂度</strong>。你放心用回溯算法，不用想别的算法了。</p>
<h3 id="Big-O-Notation"><a href="#Big-O-Notation" class="headerlink" title="Big-O Notation"></a>Big-O Notation</h3><p>Big-O 的严格定义是：<br>$$<br>O(f(n)) &#x3D; {g(n) | \exists c&gt;0, n_0&gt;0, \forall n&gt;n_0, g(n) \leq c*f(n)}<br>$$<br>所以其实是一个集合，表示所有的函数 g(n) 都是 O(f(n)) 的，比如：<br>$$<br>sin(n) + log(n) +1000n^2 \in O(1+0.3n+0.5n^2+2^n)<br>$$<br>Big-O的只能表示上届，且这个上届是不是紧致的不知道，一个复杂度为$O(n^2)$的算法，我们可以说它是$O(2^n)$的算法，但是我们不能说它是O(nlogn)的算法, 但一般不会夸大其上届。对于递归算法的复杂度，估计起来比较困难，可能估算到一个非常宽松的上届，例如之前的找零钱的例子，定义amount为N，有K个硬币。最坏的条件：</p>
<ul>
<li>都是1块的硬币，树高为N</li>
<li>每次都是满叉树，每个节点都K个子节点<br>最终的复杂度为$O(K^N)$这显然是个非常宽松的上届</li>
</ul>
<h3 id="非递归算法的复杂度"><a href="#非递归算法的复杂度" class="headerlink" title="非递归算法的复杂度"></a>非递归算法的复杂度</h3><p>最朴素的算法复杂度分析，有k层循环就是$O(N^k)$，但也不一定，<strong>对于双指针（左右指针，快慢指针）等就不能数循环嵌套次数</strong></p>
<h3 id="递归算法的复杂度"><a href="#递归算法的复杂度" class="headerlink" title="递归算法的复杂度"></a>递归算法的复杂度</h3><blockquote>
<ul>
<li>递归算法的时间复杂度 &#x3D; 递归的次数 x 每次递归的时间复杂度 &#x3D; 递归树的节点个数 x 每个节点的时间复杂度</li>
<li>递归算法的空间复杂度 &#x3D; 递归树的高度 + 算法申请的存储空间</li>
</ul>
</blockquote>
<p>对于递归算法的空间复杂度之所以要考虑到递归树的高度，是因为函数递归的原理是操作系统维护的函数堆栈，所以递归栈的空间消耗也需要算在空间复杂度之内，如下图所示：</p>
<p><img src="/../images/image-23.png" alt="alt text"></p>
<hr>
<h4 id="递归算法复杂度分析：以凑硬币为例"><a href="#递归算法复杂度分析：以凑硬币为例" class="headerlink" title="递归算法复杂度分析：以凑硬币为例"></a>递归算法复杂度分析：以凑硬币为例</h4><p>接下来我们通过分析凑硬币的例子来分析递归算法的复杂度，我们从:</p>
<ul>
<li>自定向下的递归算法</li>
<li>自顶向下的递归算法+memo化</li>
<li>自底向上的动态规划算法</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 凑硬币,没有memo化的递归算法</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dp</span>(<span class="params">coins: <span class="type">List</span>[<span class="built_in">int</span>], amount: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="comment"># base case</span></span><br><span class="line">    <span class="keyword">if</span> amount == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> amount &lt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    res = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">    <span class="comment"># 时间 O(K)</span></span><br><span class="line">    <span class="keyword">for</span> coin <span class="keyword">in</span> coins:</span><br><span class="line">        sub_problem = dp(coins, amount - coin)</span><br><span class="line">        <span class="keyword">if</span> sub_problem == -<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        res = <span class="built_in">min</span>(res, sub_problem + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span> <span class="keyword">if</span> res == <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>) <span class="keyword">else</span> res</span><br></pre></td></tr></table></figure>
<p>首先看递归树高度的最差情况为$O(N)$，其中N为amount的大小，最差情况发生着coins都是1的情况。再者我们看递归树节点的数量，假设都是$K$满叉树，树的高度为$N$，所以节点的数量为$O(K^N)$。那么其空间与时间复杂度为：</p>
<ul>
<li>空间复杂度&#x3D;递归树的高度 + 算法申请的存储空间&#x3D;O(N) + O(1) &#x3D; O(N)</li>
<li>时间复杂度&#x3D;递归树的节点个数 x 每个节点的时间复杂度&#x3D;O(K^N) x O(K) &#x3D; O(K^(N+1))<ul>
<li>之所以每个节点的时间复杂度为O(K)是因为<code>for coin in coins:</code>这一行的时间复杂度为O(K)</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">self</span>.memo = &#123;<span class="number">0</span>: <span class="number">0</span>&#125; <span class="comment"># memo化</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dp</span>(<span class="params">coins: <span class="type">List</span>[<span class="built_in">int</span>], amount: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="keyword">if</span> amount <span class="keyword">in</span> <span class="variable language_">self</span>.memo:</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.memo[amount]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># base case</span></span><br><span class="line">    <span class="keyword">if</span> amount &lt; <span class="number">0</span>:</span><br><span class="line">        <span class="variable language_">self</span>.memo[amount] = -<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    res = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">    <span class="comment"># 时间 O(K)</span></span><br><span class="line">    <span class="keyword">for</span> coin <span class="keyword">in</span> coins:</span><br><span class="line">        sub_problem = dp(coins, amount - coin)</span><br><span class="line">        <span class="keyword">if</span> sub_problem == -<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        res = <span class="built_in">min</span>(res, sub_problem + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">self</span>.memo[amount] = -<span class="number">1</span> <span class="keyword">if</span> res == <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>) <span class="keyword">else</span> res</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">self</span>.memo[amount]</span><br></pre></td></tr></table></figure>
<p>首先看递归树高度的最差情况为$O(N)$。再者我们看递归树节点的数量，这种情况，最多递归$N$次，那么其空间与时间复杂度为：</p>
<ul>
<li>空间复杂度&#x3D;递归树的高度 + 算法申请的存储空间&#x3D;O(N) + O(N) &#x3D; O(N)<ul>
<li>递归树的高度为O(N)，coins都为1的情况，递归树的高度为N</li>
<li>算法申请的存储空间为O(N)，因为我们需要一个大小为N的memo的字典来存储中间结果</li>
</ul>
</li>
<li>时间复杂度&#x3D;递归树的节点个数 x 每个节点的时间复杂度&#x3D;O(N) x O(K) &#x3D; O(NK)<ul>
<li>之所以每个节点的时间复杂度为O(K)是因为<code>for coin in coins:</code>这一行的时间复杂度为O(K)</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 凑硬币,动态规划算法,自底向上</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">coinChange</span>(<span class="params">coins: <span class="type">List</span>[<span class="built_in">int</span>], amount: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="comment"># 空间 O(N)</span></span><br><span class="line">    dp = [amount + <span class="number">1</span>] * (amount + <span class="number">1</span>)</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 时间 O(KN)</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(dp)):</span><br><span class="line">        <span class="keyword">for</span> coin <span class="keyword">in</span> coins:</span><br><span class="line">            <span class="keyword">if</span> i - coin &lt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            dp[i] = <span class="built_in">min</span>(dp[i], <span class="number">1</span> + dp[i - coin])</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span> <span class="keyword">if</span> dp[amount] == amount + <span class="number">1</span> <span class="keyword">else</span> dp[amount]</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度&#x3D;O(KN)，其中K为coins的大小，N为amount的大小</li>
<li>空间复杂度&#x3D;O(N)，因为我们需要一个大小为N的dp的数组来存储中间结果，<strong>减小了空间复杂度，相较于递归</strong></li>
</ul>
<h4 id="递归算法复杂度分析：以全排列和子集为例"><a href="#递归算法复杂度分析：以全排列和子集为例" class="headerlink" title="递归算法复杂度分析：以全排列和子集为例"></a>递归算法复杂度分析：以全排列和子集为例</h4><p>在<a href="###%E5%85%83%E7%B4%A0%E4%B8%8D%E9%87%8D%E5%A4%8D%E4%B8%8D%E5%8F%AF%E5%A4%8D%E9%80%89">回溯算法解决全排列和子集问题的章节</a>中，我们详细介绍了回溯算法，下面探究一下其复杂度，如下图所示，我们定义N为<code>len(nums)</code>。</p>
<p><img src="/../images/image-21.png" alt="alt text"></p>
<h5 id="全排列的复杂度分析"><a href="#全排列的复杂度分析" class="headerlink" title="全排列的复杂度分析"></a>全排列的复杂度分析</h5><p>首先树的高度为N，递归树总的节点个数为$P(N, 0)+P(N, 1) + P(N, 2) + … + P(N, N)$，其中$P(N, k) &#x3D; \frac{N!}{(N-k)!}$表示从N个元素中选出k个元素的排列数。</p>
<ul>
<li>空间复杂度&#x3D;递归树的高度 + 算法申请的存储空间 &#x3D; $O(N) + O(N\times N!) &#x3D; O(N\times N!)$<ul>
<li>递归树的高度为$O(N)$，因为我们最多递归N次</li>
<li>算法申请的存储空间为 $O(N\times N!)$,每个结果为N，有N!个结果</li>
</ul>
</li>
<li>时间复杂度&#x3D;递归树的节点个数 x 每个节点的时间复杂度 &#x3D; $O(N) \times O(N\times N!) &#x3D; O(N^2\times N!)$<ul>
<li>每个节点的时间复杂度的上届为O(N)</li>
<li>递归树的节点个数为$P(N, 0)+P(N, 1) + P(N, 2) + … + P(N, N)&lt; N<em>P(N, N) &#x3D; N</em>N!$</li>
</ul>
</li>
</ul>
<h5 id="子集的复杂度分析"><a href="#子集的复杂度分析" class="headerlink" title="子集的复杂度分析"></a>子集的复杂度分析</h5><p>对于子集问题，递归树的高度为N，递归树的节点个数为$C(N, 0)+C(N, 1) + C(N, 2) + … + C(N, N)&#x3D;2^N$，其中$C(N, k) &#x3D; \frac{N!}{k!(N-k)!}$表示从N个元素中选出k个元素的组合数。</p>
<ul>
<li>空间复杂度&#x3D;递归树的高度 + 算法申请的存储空间 &#x3D; $O(N) + O(N\times 2^N) &#x3D; O(N\times 2^N)$<ul>
<li>递归树的高度为$O(N)$，因为我们最多递归N次</li>
<li>算法申请的存储空间为 $O(N\times 2^N)$,每个结果为N，有$2^N$个结果</li>
</ul>
</li>
<li>时间复杂度&#x3D;递归树的节点个数 x 每个节点的时间复杂度 &#x3D; $O(N) \times O(2^N) &#x3D; O(N\times 2^N)$<ul>
<li>每个节点的时间复杂度的上届为O(N)</li>
<li>递归树的节点个数为$C(N, 0)+C(N, 1) + C(N, 2) + … + C(N, N)&#x3D;2^N$</li>
</ul>
</li>
</ul>
<h3 id="数据结构的算法分析"><a href="#数据结构的算法分析" class="headerlink" title="数据结构的算法分析"></a>数据结构的算法分析</h3><p>分析数据结构 API 的时间复杂度和分析普通算法函数的时间复杂度稍微有一些区别，因为数据结构是会动态变化的。如动态数组的<code>push_back</code>操作，时间复杂度是 O(1)，但是如果动态数组的容量不够了，就需要扩容，时间复杂度就变成了 O(n)。哈希表的<code>put</code>操作，时间复杂度是 O(1)，但是如果哈希冲突了，需要rehash，时间复杂度就变成了 O(n)。</p>
<p>如果想衡量数据结构类中的某个方法的时间复杂度，<strong>不能简单地看最坏或者最好的时间复杂度，而应该看摊还（平均）时间复杂度</strong></p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/cpp/" rel="tag"># cpp</a>
              <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag"># 数据结构</a>
              <a href="/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" rel="tag"># 排序算法</a>
              <a href="/tags/%E7%AE%97%E6%B3%95/" rel="tag"># 算法</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2025/04/23/labuladong-%E5%9F%BA%E7%A1%80-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E6%8E%92%E5%BA%8F%E7%B2%BE%E8%AE%B2/" rel="prev" title="labuladong-基础-数据结构及排序精讲">
      <i class="fa fa-chevron-left"></i> labuladong-基础-数据结构及排序精讲
    </a></div>
      <div class="post-nav-item">
    <a href="/2025/04/23/labuladong-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E7%BB%8F%E5%85%B8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95/" rel="next" title="labuladong-第一章-经典数据结构算法">
      labuladong-第一章-经典数据结构算法 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E9%9B%B6%E7%AB%A0%E3%80%81%E6%A0%B8%E5%BF%83%E5%88%B7%E9%A2%98%E6%A1%86%E6%9E%B6%E6%B1%87%E6%80%BB"><span class="nav-number">1.</span> <span class="nav-text">第零章、核心刷题框架汇总</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%AC%E7%AB%A0%E5%AF%BC%E8%AF%BB"><span class="nav-number">1.1.</span> <span class="nav-text">本章导读</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%A6%E4%B9%A0%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E7%9A%84%E6%A1%86%E6%9E%B6%E6%80%9D%E7%BB%B4"><span class="nav-number">1.2.</span> <span class="nav-text">学习数据结构和算法的框架思维</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%8C%E6%8C%87%E9%92%88%E6%8A%80%E5%B7%A7%E7%A7%92%E6%9D%80%E4%B8%83%E9%81%93%E9%93%BE%E8%A1%A8%E9%A2%98%E7%9B%AE"><span class="nav-number">1.3.</span> <span class="nav-text">双指针技巧秒杀七道链表题目</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%8C%E6%8C%87%E9%92%88%E6%8A%80%E5%B7%A7%E7%A7%92%E6%9D%80%E4%B8%83%E9%81%93%E6%95%B0%E7%BB%84%E9%A2%98%E7%9B%AE"><span class="nav-number">1.4.</span> <span class="nav-text">双指针技巧秒杀七道数组题目</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88"><span class="nav-number">1.4.1.</span> <span class="nav-text">快慢指针</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8E%9F%E5%9C%B0%E4%BF%AE%E6%94%B9"><span class="nav-number">1.4.1.1.</span> <span class="nav-text">原地修改</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3"><span class="nav-number">1.4.1.2.</span> <span class="nav-text">滑动窗口</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B7%A6%E5%8F%B3%E6%8C%87%E9%92%88"><span class="nav-number">1.4.2.</span> <span class="nav-text">左右指针</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="nav-number">1.4.2.1.</span> <span class="nav-text">二分查找</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#n%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="nav-number">1.4.2.2.</span> <span class="nav-text">n数之和</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8E%9F%E5%9C%B0%E5%8F%8D%E8%BD%AC"><span class="nav-number">1.4.2.3.</span> <span class="nav-text">原地反转</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9B%9E%E6%96%87%E4%B8%B2%E5%88%A4%E6%96%AD"><span class="nav-number">1.4.2.4.</span> <span class="nav-text">回文串判断</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%AE%97%E6%B3%95%E6%A0%B8%E5%BF%83%E4%BB%A3%E7%A0%81%E6%A8%A1%E6%9D%BF"><span class="nav-number">1.5.</span> <span class="nav-text">滑动窗口算法核心代码模板</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%97%E4%B8%B2"><span class="nav-number">1.5.1.</span> <span class="nav-text">最小覆盖字串</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8E%92%E5%88%97"><span class="nav-number">1.5.2.</span> <span class="nav-text">字符串排列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%BE%E6%89%80%E6%9C%89%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D"><span class="nav-number">1.5.3.</span> <span class="nav-text">找所有字母异位词</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E9%95%BF%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6"><span class="nav-number">1.5.4.</span> <span class="nav-text">最长重复字符</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E4%B8%AA%E8%A7%86%E8%A7%92-%E4%B8%A4%E7%A7%8D%E6%80%9D%E7%BB%B4%E6%A8%A1%E5%BC%8F%E6%90%9E%E5%AE%9A%E9%80%92%E5%BD%92"><span class="nav-number">1.6.</span> <span class="nav-text">一个视角 + 两种思维模式搞定递归</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E4%B8%AA%E8%A7%86%E8%A7%92"><span class="nav-number">1.6.1.</span> <span class="nav-text">一个视角</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%A4%E7%A7%8D%E6%80%9D%E7%BB%B4"><span class="nav-number">1.6.2.</span> <span class="nav-text">两种思维</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E8%A7%A3%E9%97%AE%E9%A2%98%E7%9A%84%E6%80%9D%E7%BB%B4"><span class="nav-number">1.6.2.1.</span> <span class="nav-text">分解问题的思维</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%81%8D%E5%8E%86%E7%9A%84%E6%80%9D%E7%BB%B4"><span class="nav-number">1.6.2.2.</span> <span class="nav-text">遍历的思维</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%A7%A3%E9%A2%98%E5%A5%97%E8%B7%AF%E6%A1%86%E6%9E%B6"><span class="nav-number">1.7.</span> <span class="nav-text">动态规划解题套路框架</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E8%A7%A3%E9%A2%98%E5%A5%97%E8%B7%AF%E6%A1%86%E6%9E%B6"><span class="nav-number">1.8.</span> <span class="nav-text">回溯算法解题套路框架</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%9A%84%E4%BE%8B%E9%A2%98%EF%BC%9A"><span class="nav-number">1.8.1.</span> <span class="nav-text">回溯算法的例题：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BFS-%E7%AE%97%E6%B3%95%E8%A7%A3%E9%A2%98%E5%A5%97%E8%B7%AF%E6%A1%86%E6%9E%B6"><span class="nav-number">1.9.</span> <span class="nav-text">BFS 算法解题套路框架</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8B%E9%9D%A2%E4%BB%8B%E7%BB%8D%E5%87%A0%E4%B8%AABFS%E7%9A%84%E4%BE%8B%E9%A2%98%EF%BC%9A"><span class="nav-number">1.9.1.</span> <span class="nav-text">下面介绍几个BFS的例题：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BFS%E4%BC%98%E5%8C%96%EF%BC%9A%E5%8F%8C%E5%90%91BFS"><span class="nav-number">1.9.2.</span> <span class="nav-text">BFS优化：双向BFS</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%B3%BB%E5%88%97%E7%AE%97%E6%B3%95%E6%A0%B8%E5%BF%83%E7%BA%B2%E9%A2%86"><span class="nav-number">1.10.</span> <span class="nav-text">二叉树系列算法核心纲领</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7"><span class="nav-number">1.10.1.</span> <span class="nav-text">二叉树的重要性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%89%8D%E4%B8%AD%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-number">1.10.2.</span> <span class="nav-text">深入理解前中后序遍历</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%A4%E7%A7%8D%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF"><span class="nav-number">1.10.3.</span> <span class="nav-text">两种解题思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E7%9A%84%E7%89%B9%E6%AE%8A%E4%B9%8B%E5%A4%84"><span class="nav-number">1.10.4.</span> <span class="nav-text">后序遍历的特殊之处</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A5%E6%A0%91%E7%9A%84%E8%A7%86%E8%A7%92%E7%9C%8B%E5%8A%A8%E5%BD%92-%E5%9B%9E%E6%BA%AF-DFS%E7%AE%97%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E8%81%94%E7%B3%BB"><span class="nav-number">1.10.5.</span> <span class="nav-text">以树的视角看动归&#x2F;回溯&#x2F;DFS算法的区别和联系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-number">1.10.6.</span> <span class="nav-text">层序遍历</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%A7%92%E6%9D%80%E6%89%80%E6%9C%89%E6%8E%92%E5%88%97-%E7%BB%84%E5%90%88-%E5%AD%90%E9%9B%86%E9%97%AE%E9%A2%98"><span class="nav-number">1.11.</span> <span class="nav-text">回溯算法秒杀所有排列&#x2F;组合&#x2F;子集问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%8E%92%E5%88%97-%E7%BB%84%E5%90%88-%E5%AD%90%E9%9B%86%E9%97%AE%E9%A2%98%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="nav-number">1.11.1.</span> <span class="nav-text">什么是排列&#x2F;组合&#x2F;子集问题问题？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%83%E7%B4%A0%E4%B8%8D%E9%87%8D%E5%A4%8D%E4%B8%8D%E5%8F%AF%E5%A4%8D%E9%80%89"><span class="nav-number">1.11.2.</span> <span class="nav-text">元素不重复不可复选</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%83%E7%B4%A0%E9%87%8D%E5%A4%8D%E4%B8%8D%E5%8F%AF%E5%A4%8D%E9%80%89"><span class="nav-number">1.11.3.</span> <span class="nav-text">元素重复不可复选</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%83%E7%B4%A0%E4%B8%8D%E9%87%8D%E5%A4%8D%E5%8F%AF%E5%A4%8D%E9%80%89"><span class="nav-number">1.11.4.</span> <span class="nav-text">元素不重复可复选</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%83%E7%B4%A0%E9%87%8D%E5%A4%8D%E5%8F%AF%E5%A4%8D%E9%80%89"><span class="nav-number">1.11.5.</span> <span class="nav-text">元素重复可复选</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E8%A7%A3%E9%A2%98%E5%A5%97%E8%B7%AF%E6%A1%86%E6%9E%B6"><span class="nav-number">1.12.</span> <span class="nav-text">贪心算法解题套路框架</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%85%B7%E5%A4%87%E8%B4%AA%E5%BF%83%E9%80%89%E6%8B%A9%E6%80%A7%E8%B4%A8%E5%92%8C%E6%9C%80%E4%BC%98%E5%AD%90%E7%BB%93%E6%9E%84"><span class="nav-number">1.12.1.</span> <span class="nav-text">1.具备贪心选择性质和最优子结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%85%B7%E5%A4%87%E8%B4%AA%E5%BF%83%E9%80%89%E6%8B%A9%E6%80%A7%E8%B4%A8%E4%BD%86%E4%B8%8D%E5%85%B7%E5%A4%87%E6%9C%80%E4%BC%98%E5%AD%90%E7%BB%93%E6%9E%84"><span class="nav-number">1.12.2.</span> <span class="nav-text">2.具备贪心选择性质但不具备最优子结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E4%B8%8D%E5%85%B7%E5%A4%87%E8%B4%AA%E5%BF%83%E9%80%89%E6%8B%A9%E6%80%A7%E8%B4%A8%E4%BD%86%E5%85%B7%E5%A4%87%E6%9C%80%E4%BC%98%E5%AD%90%E7%BB%93%E6%9E%84"><span class="nav-number">1.12.3.</span> <span class="nav-text">3.不具备贪心选择性质但具备最优子结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E4%B8%8D%E5%85%B7%E5%A4%87%E8%B4%AA%E5%BF%83%E9%80%89%E6%8B%A9%E6%80%A7%E8%B4%A8%E5%92%8C%E6%9C%80%E4%BC%98%E5%AD%90%E7%BB%93%E6%9E%84"><span class="nav-number">1.12.4.</span> <span class="nav-text">4.不具备贪心选择性质和最优子结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E7%9A%84%E8%A7%A3%E9%A2%98%E6%AD%A5%E9%AA%A4"><span class="nav-number">1.12.5.</span> <span class="nav-text">贪心算法的解题步骤</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BE%8B%E9%A2%98"><span class="nav-number">1.12.6.</span> <span class="nav-text">例题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95%E8%A7%A3%E9%A2%98%E5%A5%97%E8%B7%AF%E6%A1%86%E6%9E%B6"><span class="nav-number">1.13.</span> <span class="nav-text">分治算法解题套路框架</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E6%B2%BB%E6%80%9D%E6%83%B3"><span class="nav-number">1.13.1.</span> <span class="nav-text">分治思想</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95"><span class="nav-number">1.13.2.</span> <span class="nav-text">分治算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%97%A0%E6%95%88%E7%9A%84%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95"><span class="nav-number">1.13.2.1.</span> <span class="nav-text">无效的分治算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%89%E6%95%88%E7%9A%84%E5%88%86%E6%B2%BB"><span class="nav-number">1.13.2.2.</span> <span class="nav-text">有效的分治</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E6%97%B6%E7%A9%BA%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90%E5%AE%9E%E7%94%A8%E6%8C%87%E5%8D%97"><span class="nav-number">1.14.</span> <span class="nav-text">算法时空复杂度分析实用指南</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%80%9F%E5%8A%A9%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%8F%8D%E6%8E%A8%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF"><span class="nav-number">1.14.1.</span> <span class="nav-text">借助复杂度反推解题思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Big-O-Notation"><span class="nav-number">1.14.2.</span> <span class="nav-text">Big-O Notation</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%9E%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95%E7%9A%84%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="nav-number">1.14.3.</span> <span class="nav-text">非递归算法的复杂度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95%E7%9A%84%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="nav-number">1.14.4.</span> <span class="nav-text">递归算法的复杂度</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90%EF%BC%9A%E4%BB%A5%E5%87%91%E7%A1%AC%E5%B8%81%E4%B8%BA%E4%BE%8B"><span class="nav-number">1.14.4.1.</span> <span class="nav-text">递归算法复杂度分析：以凑硬币为例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90%EF%BC%9A%E4%BB%A5%E5%85%A8%E6%8E%92%E5%88%97%E5%92%8C%E5%AD%90%E9%9B%86%E4%B8%BA%E4%BE%8B"><span class="nav-number">1.14.4.2.</span> <span class="nav-text">递归算法复杂度分析：以全排列和子集为例</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%A8%E6%8E%92%E5%88%97%E7%9A%84%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90"><span class="nav-number">1.14.4.2.1.</span> <span class="nav-text">全排列的复杂度分析</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AD%90%E9%9B%86%E7%9A%84%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90"><span class="nav-number">1.14.4.2.2.</span> <span class="nav-text">子集的复杂度分析</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90"><span class="nav-number">1.14.5.</span> <span class="nav-text">数据结构的算法分析</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Yueht</p>
  <div class="site-description" itemprop="description">个人博客</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">8</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yueht</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>











<script>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : 'default',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>


  

  

  

</body>
</html>
