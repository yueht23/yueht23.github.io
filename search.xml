<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2025/04/22/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h1 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h1><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
<h1 id="测试代码是否可以顺利渲染"><a href="#测试代码是否可以顺利渲染" class="headerlink" title="测试代码是否可以顺利渲染"></a>测试代码是否可以顺利渲染</h1><h2 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;hello word&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">greeting</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello from JavaScript!&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello World&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="R"><a href="#R" class="headerlink" title="R"></a>R</h2><figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 打印 Hello World</span></span><br><span class="line">print<span class="punctuation">(</span><span class="string">&quot;Hello World&quot;</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个简单的数据框</span></span><br><span class="line">data <span class="operator">&lt;-</span> data.frame<span class="punctuation">(</span></span><br><span class="line">  name <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;Alice&quot;</span><span class="punctuation">,</span> <span class="string">&quot;Bob&quot;</span><span class="punctuation">,</span> <span class="string">&quot;Charlie&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">  age <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">25</span><span class="punctuation">,</span> <span class="number">30</span><span class="punctuation">,</span> <span class="number">35</span><span class="punctuation">)</span></span><br><span class="line"><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 ggplot2 绘制简单的散点图</span></span><br><span class="line">library<span class="punctuation">(</span>ggplot2<span class="punctuation">)</span></span><br><span class="line">ggplot<span class="punctuation">(</span>data<span class="punctuation">,</span> aes<span class="punctuation">(</span>x <span class="operator">=</span> name<span class="punctuation">,</span> y <span class="operator">=</span> age<span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  geom_point<span class="punctuation">(</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  labs<span class="punctuation">(</span>title <span class="operator">=</span> <span class="string">&quot;年龄分布&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>



<h1 id="数学公式"><a href="#数学公式" class="headerlink" title="数学公式"></a>数学公式</h1><h2 id="行内公式"><a href="#行内公式" class="headerlink" title="行内公式"></a>行内公式</h2><p>$E&#x3D;mc^2$ and $\exists x \in X, \forall y \in Y, x \neq y$</p>
<h2 id="行间公式"><a href="#行间公式" class="headerlink" title="行间公式"></a>行间公式</h2><p>$$<br>\int_0^\infty \frac{x^3}{e^x} , dx &#x3D; \frac{\pi^4}{15}<br>$$</p>
<h1 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h1><table>
<thead>
<tr>
<th>列1</th>
<th>列2</th>
<th>列3</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>2</td>
<td>3</td>
</tr>
<tr>
<td>4</td>
<td>5</td>
<td>6</td>
</tr>
<tr>
<td>7</td>
<td>8</td>
<td>9</td>
</tr>
</tbody></table>
<h1 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h1><h2 id="本地图片"><a href="#本地图片" class="headerlink" title="本地图片"></a>本地图片</h2><p><img src="/../images/image-1.png" alt="alt text"></p>
<h2 id="网络图片"><a href="#网络图片" class="headerlink" title="网络图片"></a>网络图片</h2><p><img src="https://www.google.com/images/branding/googlelogo/1x/googlelogo_color_272x92dp.png" alt="alt text"></p>
<h1 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h1><p><a href="https://www.google.com/">Google</a></p>
<h1 id="有向图"><a href="#有向图" class="headerlink" title="有向图"></a>有向图</h1><pre class="mermaid">graph TD
    A --> B
    B --> C
    C --> A</pre>

]]></content>
  </entry>
  <entry>
    <title>labuladong-基础-数据结构及排序精讲</title>
    <url>/2025/04/23/labuladong-%E5%9F%BA%E7%A1%80-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E6%8E%92%E5%BA%8F%E7%B2%BE%E8%AE%B2/</url>
    <content><![CDATA[<h1 id="基础：数据结构及排序精讲"><a href="#基础：数据结构及排序精讲" class="headerlink" title="基础：数据结构及排序精讲"></a><a href="https://labuladong.online/algo/menu/quick-start/">基础：数据结构及排序精讲</a></h1><h2 id="手把手带你实现动态数组"><a href="#手把手带你实现动态数组" class="headerlink" title="手把手带你实现动态数组"></a><a href="https://labuladong.online/algo/menu/dynamic-array/">手把手带你实现动态数组</a></h2><p>以下是动态数组和静态数组的主要区别总结：</p>
<table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>静态数组 (Static Array)</strong></th>
<th><strong>动态数组 (Dynamic Array)</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>内存分配</strong></td>
<td>编译时分配，大小固定</td>
<td>运行时动态分配，大小可调整</td>
</tr>
<tr>
<td><strong>大小灵活性</strong></td>
<td>固定长度，不可扩展或收缩</td>
<td>可动态扩展或收缩（如通过 <code>realloc</code> 或自动扩容策略）</td>
</tr>
<tr>
<td><strong>内存管理</strong></td>
<td>自动管理（栈或全局内存），无需手动释放</td>
<td>需手动管理（堆内存），需显式释放（如 <code>free</code>&#x2F;<code>delete</code>）</td>
</tr>
<tr>
<td><strong>访问速度</strong></td>
<td>更快（连续内存，无额外开销）</td>
<td>稍慢（可能涉及扩容时的内存搬移）</td>
</tr>
<tr>
<td><strong>内存效率</strong></td>
<td>可能浪费内存（需预分配足够空间）</td>
<td>更高效（按需分配，减少浪费）</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>数据量已知且固定的场景</td>
<td>数据量变化频繁或未知的场景</td>
</tr>
<tr>
<td><strong>示例（C++）</strong></td>
<td><code>std::array&lt;int, 10&gt; arr;</code></td>
<td><code>std::vector&lt;int&gt; arr;</code></td>
</tr>
<tr>
<td><strong>示例（Python）</strong></td>
<td>无（Python 列表本质是动态数组）</td>
<td><code>list = []</code>（Python 列表自动扩容）</td>
</tr>
<tr>
<td><strong>扩容成本</strong></td>
<td>不支持扩容</td>
<td>扩容时可能需复制全部元素（均摊时间复杂度 O(1)）</td>
</tr>
</tbody></table>
<p>各种操作的复杂度</p>
<table>
<thead>
<tr>
<th><strong>操作</strong></th>
<th><strong>静态数组 (Static Array)</strong></th>
<th><strong>动态数组 (Dynamic Array)</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>访问 (Access)</strong></td>
<td><code>O(1)</code></td>
<td><code>O(1)</code></td>
<td>随机访问，直接通过下标定位。</td>
</tr>
<tr>
<td><strong>修改 (Update)</strong></td>
<td><code>O(1)</code></td>
<td><code>O(1)</code></td>
<td>直接修改指定位置的元素。</td>
</tr>
<tr>
<td><strong>插入 (Insert)</strong></td>
<td><code>O(n)</code>（尾部 <code>O(1)</code>）</td>
<td><code>O(n)</code>（尾部正常<code>O(1)</code>，不正常<code>O(n)</code>）</td>
<td>不是在尾部的时候都要搬运，在尾部时动态有可能要扩容，扩容为<code>O(n)</code>但平均为<code>O(1)</code></td>
</tr>
<tr>
<td><strong>删除 (Delete)</strong></td>
<td><code>O(n)</code> （尾部 <code>O(1)</code>）</td>
<td><code>O(n)</code>（尾部正常<code>O(1)</code>，不正常<code>O(n)</code>）</td>
<td>不是在尾部需搬移后续元素，在尾部时动态有可能要缩容，缩容为<code>O(n)</code> 但平均为<code>O(1)</code></td>
</tr>
<tr>
<td><strong>扩容 (Resize)</strong></td>
<td>不支持</td>
<td><code>O(n)</code></td>
<td>动态数组扩容需分配新内存并拷贝旧数据。</td>
</tr>
<tr>
<td><strong>查找 (Search)</strong></td>
<td><code>O(n)</code>（无序） &#x2F; <code>O(log n)</code>（有序）</td>
<td><code>O(n)</code>（无序） &#x2F; <code>O(log n)</code>（有序）</td>
<td>线性查找或二分查找（若有序）。</td>
</tr>
<tr>
<td><strong>查询长度 (Length)</strong></td>
<td><code>O(1)</code></td>
<td><code>O(1)</code></td>
<td>都是提前保存的，动态数组查询长度不需要遍历</td>
</tr>
</tbody></table>
<h2 id="手把手带你实现单-双链表"><a href="#手把手带你实现单-双链表" class="headerlink" title="手把手带你实现单&#x2F;双链表"></a><a href="https://labuladong.online/algo/menu/linked-list/">手把手带你实现单&#x2F;双链表</a></h2><h3 id="链表（链式存储）基本原理"><a href="#链表（链式存储）基本原理" class="headerlink" title="链表（链式存储）基本原理"></a><a href="https://labuladong.online/algo/data-structure-basic/linkedlist-basic/">链表（链式存储）基本原理</a></h3><p>Why we need linked lists? instead of dynamic arrays?<br><strong>高插入&#x2F;删除、内存碎片敏感且无需随机访问的场景。</strong></p>
<p>与数组相比链表的复杂度表格如下：</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>数组 (Array)</th>
<th>单向链表 (Singly Linked List)</th>
<th>双向链表 (Doubly Linked List)</th>
</tr>
</thead>
<tbody><tr>
<td><strong>随机访问</strong></td>
<td>O(1)</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td><strong>无序搜索</strong></td>
<td>O(n)</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td><strong>有序二分查找</strong></td>
<td>O(log n)</td>
<td>❌ 不支持（必须顺序访问）</td>
<td>❌ 不支持（必须顺序访问）</td>
</tr>
<tr>
<td><strong>插入头部</strong></td>
<td>O(n)</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
<tr>
<td><strong>插入尾部</strong></td>
<td>O(1)</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td><strong>插入中间</strong></td>
<td>O(n)</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td><strong>删除头部</strong></td>
<td>O(n)</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
<tr>
<td><strong>删除尾部</strong></td>
<td>O(1)</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td><strong>删除中间</strong></td>
<td>O(n)</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td><strong>空间开销</strong></td>
<td>O(n)</td>
<td>O(n) + 指针开销</td>
<td>O(n) + 双指针开销</td>
</tr>
<tr>
<td><strong>查看长度</strong></td>
<td>O(1)</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
</tbody></table>
<h3 id="链表代码实现"><a href="#链表代码实现" class="headerlink" title="链表代码实现"></a><a href="https://labuladong.online/algo/data-structure-basic/linkedlist-implement/">链表代码实现</a></h3><p>C++中有<code>std::list</code>和<code>std::forward_list</code>，前者是双向链表，后者是单向链表，在<a href="#%E5%8F%8C%E9%93%BE%E8%A1%A8list">前文</a>中已经介绍过了。</p>
<h2 id="环形数组技巧及实现"><a href="#环形数组技巧及实现" class="headerlink" title="[环形数组技巧及实现]"></a>[环形数组技巧及实现]</h2><h3 id="环形数组技巧"><a href="#环形数组技巧" class="headerlink" title="环形数组技巧"></a><a href="https://labuladong.online/algo/data-structure-basic/cycle-array/">环形数组技巧</a></h3><p>Why we need circular arrays? instead of dynamic arrays?<br><strong>希望以O(1)复杂度进行数组头部增删元素</strong></p>
<p>实现方法是维护两个指针<code>[start, end)</code>，<code>start</code>指向数组的头部，<code>end</code>指向数组的尾部。逻辑上数组为<code>[start, end)</code>，实际存储为<code>[0, n)</code>。</p>
<ul>
<li>当头部元素<ul>
<li>删除时，<code>start++</code>，如果<code>start == end</code>，则<code>start = 0</code>，<code>end = 0</code>，表示数组为空。</li>
<li>插入时，<code>start--</code>，如果<code>start &lt; 0</code>，则<code>start = n - 1</code>，表示数组头部插入元素。</li>
</ul>
</li>
</ul>
<p>环形数组在增删头部元素时复杂度为O(1)，而动态数组为O(n)。增删尾时与动态数组相同，复杂度为O(1)。增删中间元素时与动态数组相同，复杂度为O(n)。为什么编程语言的标准库中提供的动态数组容器底层并没有用环形数组技巧？<br><strong>如果用环形数组，增删查改的的所有操作都会涉及<code>%</code> 求模运算，这个操作是比较消耗性能的。尤其像数组的 <code>get</code> 方法，调用频率会非常非常高，如果每次调用都多一步 <code>%</code> 运算，加起来的性能损耗远大于环形数组带来的收益，因为数组很少在头部增删元素。如果你非要在头部增删，应该使用更合适的其他数据结构。所以一般只会在双端队列这种场景下使用环形数组，标准的动态数组并没有使用这个技巧。不是不能用，而是算总账不划算。</strong></p>
<h2 id="手把手带你实现队列-栈"><a href="#手把手带你实现队列-栈" class="headerlink" title="手把手带你实现队列&#x2F;栈"></a><a href="https://labuladong.online/algo/menu/queue-stack/">手把手带你实现队列&#x2F;栈</a></h2><h3 id="队列-栈基本原理"><a href="#队列-栈基本原理" class="headerlink" title="队列&#x2F;栈基本原理"></a><a href="https://labuladong.online/algo/data-structure-basic/queue-stack-basic/">队列&#x2F;栈基本原理</a></h3><ul>
<li>队列和栈都是「操作受限」的数据结构，队列是先进先出（FIFO），栈是先进后出（LIFO）。队列只能在一端插入元素，另一端删除元素；栈只能在某一端插入和删除元素。说白了就是把数组链表提供的 API 删掉了一部分，只保留头尾操作元素的 API 给你用。</li>
</ul>
<h3 id="用链表实现队列-栈"><a href="#用链表实现队列-栈" class="headerlink" title="用链表实现队列&#x2F;栈"></a><a href="https://labuladong.online/algo/data-structure-basic/linked-queue-stack/">用链表实现队列&#x2F;栈</a></h3><p>双链表有head和tail两个指针，天然的支持栈和队列的实现。满足:</p>
<ul>
<li>栈：<code>push_back</code>和<code>pop_back</code>在&#96;O(1)复杂度内完成</li>
<li>队列：<code>push_back</code>和<code>pop_front</code>在&#96;O(1)复杂度内完成</li>
</ul>
<p>注意单链表实现栈和队列时</p>
<ul>
<li>栈：<code>push_back</code>和<code>pop_back</code>在&#96;O(1)复杂度内完成（单链表头为栈顶）</li>
<li>队列：<code>push_back</code>和<code>pop_front</code>在没有办法同时<code>O(1)</code>复杂度完成，需要找到尾部元素，复杂度为<code>O(n)</code>，不过也可以保存tail指针</li>
</ul>
<h3 id="用数组实现队列-栈"><a href="#用数组实现队列-栈" class="headerlink" title="用数组实现队列&#x2F;栈"></a><a href="https://labuladong.online/algo/data-structure-basic/array-queue-stack/">用数组实现队列&#x2F;栈</a></h3><p>用动态数组实现队列和栈</p>
<ul>
<li>栈：<code>push_back</code>和<code>pop_back</code>在<code>O(1)</code>复杂度内完成，数组尾部为栈顶</li>
<li>队列：<code>push_back</code>和<code>pop_front</code>在没有办法同时<code>O(1)</code>复杂度完成，不过可以采用环形数组的方式实现，详见<a href="#%E7%8E%AF%E5%BD%A2%E6%95%B0%E7%BB%84%E6%8A%80%E5%B7%A7%E5%8F%8A%E5%AE%9E%E7%8E%B0">环形数组技巧及实现</a>。</li>
</ul>
<h3 id="双端队列（Deque）原理及实现"><a href="#双端队列（Deque）原理及实现" class="headerlink" title="双端队列（Deque）原理及实现"></a><a href="https://labuladong.online/algo/data-structure-basic/deque-implement/">双端队列（Deque）原理及实现</a></h3><p>Deque is stand for Double-Ended Queue, 即双端队列，支持在两端插入和删除元素，同stack和queue一样都是受到限制的数据结构，其实就是在栈和队列的基础上增加了一个头部操作元素的 API。可以使用数组和链表实现。</p>
<p>什么时候必须用Deque？Queue和Stack都不满足？</p>
<ul>
<li>当问题需要 灵活的双端操作 或 混合队列&#x2F;栈的逻辑 时，deque 是唯一选择。如果仅需严格的 FIFO 或 LIFO，则用 queue 或 stack 更语义化</li>
<li>例如：Undo&#x2F;Redo 功能，用户可以随时撤销或重做操作，要求在两端都能快速插入和删除元素。</li>
</ul>
<h2 id="哈希表的原理及实现"><a href="#哈希表的原理及实现" class="headerlink" title="哈希表的原理及实现"></a><a href="https://labuladong.online/algo/menu/">哈希表的原理及实现</a></h2><p>首先哈希表和Map，不是一个东西啊。</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>哈希表（Hash Table）</th>
<th>Map（映射）</th>
</tr>
</thead>
<tbody><tr>
<td><strong>本质</strong></td>
<td>具体的数据结构实现</td>
<td>抽象的接口或概念</td>
</tr>
<tr>
<td><strong>底层实现</strong></td>
<td>哈希函数 + 冲突解决</td>
<td>可以是哈希表、树、或其他结构</td>
</tr>
<tr>
<td><strong>顺序性</strong></td>
<td>通常无序</td>
<td>取决于实现（如树实现有序）</td>
</tr>
<tr>
<td><strong>语言中的例子</strong></td>
<td>C++ <code>unordered_map</code>, Python <code>dict</code></td>
<td>Java <code>Map</code> 接口，C++ <code>std::map</code></td>
</tr>
</tbody></table>
<p>总结起来说<strong>哈希表是 <code>Map</code> 的一种实现方式，但 <code>Map</code> 还可以通过其他数据结构实现（如<code>TreeMap</code>）。</strong> 其与数组和链表的复杂度总结如下：</p>
<table>
<thead>
<tr>
<th><strong>操作</strong></th>
<th><strong>哈希表(HashMap)</strong></th>
<th><strong>数组(Array)</strong></th>
<th><strong>双向链表(DoublyLinkedList)</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>随机访问元素</strong></td>
<td>O(1)</td>
<td>O(1)</td>
<td>O(n)</td>
</tr>
<tr>
<td><strong>头部插入&#x2F;删除</strong></td>
<td>-</td>
<td>O(n)(O(1)当利用环形技巧)</td>
<td>O(1)</td>
</tr>
<tr>
<td><strong>尾部插入&#x2F;删除</strong></td>
<td>-</td>
<td>O(1)（动态数组）</td>
<td>O(1)</td>
</tr>
<tr>
<td><strong>中间插入&#x2F;删除</strong></td>
<td>-</td>
<td>O(n)</td>
<td>O(n)（需遍历到位置）</td>
</tr>
<tr>
<td><strong>查找元素（按值）</strong></td>
<td>O(1)</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td><strong>更新元素</strong></td>
<td>O(1)</td>
<td>O(1)</td>
<td>O(n)（需遍历到位置）</td>
</tr>
<tr>
<td><strong>遍历所有元素</strong></td>
<td>O(n)</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
</tbody></table>
<h3 id="哈希表核心原理"><a href="#哈希表核心原理" class="headerlink" title="哈希表核心原理"></a><a href="https://labuladong.online/algo/data-structure-basic/hashmap-basic/">哈希表核心原理</a></h3><h4 id="哈希表的本质"><a href="#哈希表的本质" class="headerlink" title="哈希表的本质"></a>哈希表的本质</h4><p>本质就是一个数组，一般命名为table，(key,value)对的存储方式为<code>table[hash(key) % table.size()] = value</code>。定义size为键值对的个数，则负载因子为<code>load factor = size / table.size()</code>。负载因子本质上是空间利用率，但是负载因子越大，哈希表的性能越差，哈希冲突的概率越大。</p>
<ul>
<li>开放寻址法：负载因子接近1时，插入和查找可能需要多次探测，时间复杂度从理想的<code>O(1)</code>变为<code>O(n)</code>。</li>
<li>拉链法：冲突会导致链表（或树）变长，操作时间复杂度从 <code>O(1)</code>变为<code>O(K)</code>。<br>一般高过某个阈值（比如0.75）就要扩容了，扩容时需要重新计算哈希值。</li>
</ul>
<h4 id="哈希冲突"><a href="#哈希冲突" class="headerlink" title="哈希冲突"></a>哈希冲突</h4><p>$\exists \text{ } key_1, key_2 \text{ s.t. } hash(key_1) \bmod table.size() &#x3D; hash(key_2) \bmod table.size()$，即不同的key经过哈希函数计算后得到相同的索引位置。常见的解决方法有两种：</p>
<ul>
<li>开放地址法（线性探查法）： 即当发生冲突时，线性探查下一个空位，直到找到一个空位为止，负载因子不能大于1。</li>
<li>拉链法： 即每个索引位置存储一个链表，当发生冲突时，将新的元素插入到链表中，负载因子可以大于1。</li>
</ul>
<table>
<thead>
<tr>
<th>特性</th>
<th>C++ <code>std::unordered_map</code></th>
<th>Python <code>dict</code></th>
</tr>
</thead>
<tbody><tr>
<td><strong>冲突解决</strong></td>
<td>拉链法（链表&#x2F;动态数组）</td>
<td>开放寻址法（伪随机探查）</td>
</tr>
<tr>
<td><strong>动态扩容</strong></td>
<td>重新哈希，负载因子 ~1.0</td>
<td>重新哈希，负载因子 ~2&#x2F;3</td>
</tr>
<tr>
<td><strong>顺序保证</strong></td>
<td>无序（C++标准）</td>
<td>保持插入顺序（Python 3.7+）</td>
</tr>
</tbody></table>
<h4 id="为什么不能依赖哈希表的遍历顺序？"><a href="#为什么不能依赖哈希表的遍历顺序？" class="headerlink" title="为什么不能依赖哈希表的遍历顺序？"></a>为什么不能依赖哈希表的遍历顺序？</h4><p>一般来说哈希表的遍历顺序是无序的，如下c++代码所示，输出的结果是随机的，不是按照插入顺序的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">unordered_map&lt;<span class="type">int</span>, string&gt; umap;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">20</span>; i++) &#123;</span><br><span class="line">    umap[i] = <span class="built_in">to_string</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;pair: umap) &#123;</span><br><span class="line">    cout &lt;&lt; pair.first &lt;&lt; <span class="string">&quot;-&gt;&quot;</span> &lt;&lt; pair.second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是对于python的字典来说，遍历顺序是有序的，和插入顺序一致。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">map</span> = &#123;_:_ <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">20</span>)&#125;</span><br><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> <span class="built_in">map</span>.items():</span><br><span class="line">    <span class="built_in">print</span>(k, v)</span><br></pre></td></tr></table></figure>

<p>python的dict的有序性是基于哈希表 + 双向链表（或类似结构）：Python 的字典不仅存储键值对，还维护了一个 插入顺序的双向链表（或类似机制），使得遍历时可以按照插入顺序输出。Python 3.6 之前，<code>dict</code> 也是无序的，但官方发现有序实现并不会显著降低性能，反而提高了可用性，于是在 3.7 中将其定为语言规范。 但是<strong>不依赖哈希表的遍历顺序</strong>是一个良好的编程习惯，尤其在 C++ 中。</p>
<p>在Python中，<code>dict</code>虽然已经保证了有序性，但是强烈建议如果非要依赖顺序，还是使用<code>OrderedDict</code>，因为<code>OrderedDict</code>在此之上还实现了</p>
<ul>
<li>重新排序操作：可以通过move_to_end()方法将元素移动到开头或结尾</li>
<li>相等性比较：两个OrderedDict只有在顺序和内容都相同时才被视为相等</li>
</ul>
<h4 id="为什么不建议在-for-循环中增-删哈希表的-key？"><a href="#为什么不建议在-for-循环中增-删哈希表的-key？" class="headerlink" title="为什么不建议在 for 循环中增&#x2F;删哈希表的 key？"></a>为什么不建议在 for 循环中增&#x2F;删哈希表的 key？</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">unordered_map&lt;<span class="type">int</span>, string&gt; umap;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    umap[i] = <span class="built_in">to_string</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;pair: umap) &#123;</span><br><span class="line">    <span class="keyword">if</span> (pair.first == <span class="number">0</span>) &#123;</span><br><span class="line">        umap[<span class="number">100</span>] = <span class="string">&quot;fuck&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;first:&quot;</span> &lt;&lt; pair.first &lt;&lt; <span class="string">&quot;-&gt;&quot;</span> &lt;&lt; pair.second &lt;&lt; endl;</span><br><span class="line">&#125;    </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;pair: umap) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;sec:&quot;</span> &lt;&lt; pair.first &lt;&lt; <span class="string">&quot;-&gt;&quot;</span> &lt;&lt; pair.second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>c++是不报错的，但是输出如下，第一轮是没有添加的键值对的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">first:1-&gt;1</span><br><span class="line">first:0-&gt;0</span><br><span class="line">sec:100-&gt;fuck</span><br><span class="line">sec:1-&gt;1</span><br><span class="line">sec:0-&gt;0</span><br></pre></td></tr></table></figure>
<p>对于python来说，直接报错<code>RuntimeError: dictionary changed size during iteration</code>，因为在遍历字典时，字典的大小发生了变化，导致迭代器失效。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">omap = <span class="built_in">dict</span>()</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):</span><br><span class="line">    omap[_] = <span class="built_in">str</span>(_)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> omap.items():</span><br><span class="line">    <span class="keyword">if</span> k == <span class="number">0</span>:</span><br><span class="line">        omap[<span class="number">100</span>] = <span class="string">&quot;fuck&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;first&quot;</span>, k, <span class="string">&quot;-&gt;&quot;</span>, v)</span><br></pre></td></tr></table></figure>
<p>所以<strong>不建议在 for 循环中增&#x2F;删哈希表的 key</strong></p>
<h3 id="用拉链法实现哈希表"><a href="#用拉链法实现哈希表" class="headerlink" title="用拉链法实现哈希表"></a><a href="https://labuladong.online/algo/data-structure-basic/hashtable-chaining/">用拉链法实现哈希表</a></h3><p>首先需要注意，哈希表是存key的（如果不存，想想index没办法反哈希出key），所以如下的每个小格和的数据结构是个结构体<code>KVNode</code>，包含key和value两个属性。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">KVNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> key; <span class="comment">// 键</span></span><br><span class="line">    <span class="type">int</span> value; <span class="comment">// 值</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其次拉链法的底层的哈希表结构为<code>vector&lt;list&lt;KVNode&gt;&gt; table</code>，想想为什么不是<code>vector&lt;vector&lt;KVNode&gt;&gt; table</code>，因为如果是这样增，查，改性能与<code>vector&lt;list&lt;KVNode&gt;&gt; table</code>是一样的，但是删除性能就差了，要不然你搬运，要不然你放弃这块内存。<strong>哈希冲突链通常较短，链表在这种场景下更高效。这个链表又叫做桶，C++的unsorted_map采用了这种方法</strong> ，</p>
<p><img src="/../images/image-1.png" alt="alt text"><br>下面简单写一下拉链法的增，查，改，删操作：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> index = <span class="built_in">hash</span>(key); <span class="comment">// 计算哈希值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;node : table[index]) &#123; <span class="comment">// 遍历链表</span></span><br><span class="line">        <span class="keyword">if</span> (node.key == key) &#123; <span class="comment">// 找到键</span></span><br><span class="line">            <span class="keyword">return</span> node.value; <span class="comment">// 返回值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 未找到键，返回-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入，改</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> index = <span class="built_in">hash</span>(key); <span class="comment">// 计算哈希值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;node : table[index]) &#123; <span class="comment">// 遍历链表</span></span><br><span class="line">        <span class="keyword">if</span> (node.key == key) &#123; <span class="comment">// 找到键</span></span><br><span class="line">            node.value = value; <span class="comment">// 更新值</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    table[index].<span class="built_in">push_back</span>(&#123;key, value&#125;); <span class="comment">// 未找到键，插入新节点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> index = <span class="built_in">hash</span>(key); <span class="comment">// 计算哈希值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = table[index].<span class="built_in">begin</span>(); it != table[index].<span class="built_in">end</span>(); ++it) &#123; <span class="comment">// 遍历链表</span></span><br><span class="line">        <span class="keyword">if</span> (it-&gt;key == key) &#123; <span class="comment">// 找到键</span></span><br><span class="line">            <span class="comment">// 迭代器it指向要删除的节点，list.erase(it)会删除该节点并返回下一个节点的迭代器</span></span><br><span class="line">            table[index].<span class="built_in">erase</span>(it); <span class="comment">// 删除节点</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>






<h3 id="线性探查法的两个难点"><a href="#线性探查法的两个难点" class="headerlink" title="线性探查法的两个难点"></a><a href="https://labuladong.online/algo/data-structure-basic/linear-probing-key-point/">线性探查法的两个难点</a></h3><p>这种方法的底层的哈希表结构为<code>vector&lt;KVNode&gt; table</code>，当前的如果哈希值冲突了，就线性探查下一个空位，直到找到一个空位为止。具体来说</p>
<ul>
<li>增：如果<code>table[hash(key) % table.size()]</code>已经被占用，就线性探查下一个空位，直到找到一个空位为止，然后插入元素。</li>
<li>查：从<code>table[hash(key) % table.size()]</code>开始线性探查，直到找到key对应的元素为止。如果找到了就返回值，如果没有找到就返回-1。</li>
</ul>
<p>这种方法务必注意，<strong>发生碰撞的key必须是连续的</strong></p>
<p><img src="/../images/image-2.png" alt="alt text"></p>
<h4 id="难点一：需要环形数组"><a href="#难点一：需要环形数组" class="headerlink" title="难点一：需要环形数组"></a>难点一：需要环形数组</h4><p>如果<code>table</code>的尾部比较满，一直线性探查下去，就可能越界了，需要环形数组的技巧（见<a href="#%E7%8E%AF%E5%BD%A2%E6%95%B0%E7%BB%84%E6%8A%80%E5%B7%A7%E5%8F%8A%E5%AE%9E%E7%8E%B0">环形数组技巧及实现</a>）。</p>
<h4 id="难点二：维护元素的连续性"><a href="#难点二：维护元素的连续性" class="headerlink" title="难点二：维护元素的连续性"></a>难点二：维护元素的连续性</h4><p>例如对于上面的图片的例子，<code>hash(k1) = hash(k2) = hash(k3) = 0</code>，如果现在把<code>k2</code>删除了，不做任何处理，<code>k3</code>就无法被查了，针对这种情况，<strong>需要在删除元素时，维护元素的连续性</strong>。具体的方法是：</p>
<h5 id="方法一：懒惰删除-特殊值标记法"><a href="#方法一：懒惰删除-特殊值标记法" class="headerlink" title="方法一：懒惰删除&#x2F;特殊值标记法"></a>方法一：懒惰删除&#x2F;特殊值标记法</h5><p>即不删除元素，而是将元素标记为已删除，保留在哈希表中。查找时，如果遇到已删除的元素，就继续线性探查下一个元素。这样可以避免删除操作对哈希表的影响，但会增加哈希表的空间占用。</p>
<h5 id="方法二：搬运后面的元素-rehash法"><a href="#方法二：搬运后面的元素-rehash法" class="headerlink" title="方法二：搬运后面的元素&#x2F;rehash法"></a>方法二：搬运后面的元素&#x2F;rehash法</h5><p>即删除元素后，将后面的元素向前移动一个位置，保持元素的连续性。这样可以避免已删除元素对查找的影响，但会增加删除操作的时间复杂度。</p>
<h3 id="哈希集合的原理及代码实现"><a href="#哈希集合的原理及代码实现" class="headerlink" title="哈希集合的原理及代码实现"></a><a href="https://labuladong.online/algo/data-structure-basic/hash-set/">哈希集合的原理及代码实现</a></h3><p><strong>哈希集合就是退化的哈希表,ie.没有值的哈希表</strong></p>
<h2 id="哈希表结构的种种变换"><a href="#哈希表结构的种种变换" class="headerlink" title="哈希表结构的种种变换"></a><a href="https://labuladong.online/algo/menu/">哈希表结构的种种变换</a></h2><h3 id="用链表加强哈希表（LinkedHashMap）"><a href="#用链表加强哈希表（LinkedHashMap）" class="headerlink" title="用链表加强哈希表（LinkedHashMap）"></a><a href="https://labuladong.online/algo/data-structure-basic/hashtable-with-linked-list/">用链表加强哈希表（LinkedHashMap）</a></h3><p>Python默认的<code>dict</code>就是这种实现，包括<code>OrderedDict</code>也是这种实现,主要是为了保持插入顺序。但是C++的<code>unordered_map</code>是无序的，尤其有趣的是Golang的<code>map</code>每次输出都是随机的,专门是为了防止程序员依赖遍历顺序。</p>
<p>与之前提到的<code>KVNode</code>结构体不同,<code>LinkedHashMap</code>的<code>KVNode</code>结构体中多了两个指针，分别指向前一个节点和后一个节点。这样就可以在O(1)复杂度内实现插入顺序的遍历。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">KVNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> key; <span class="comment">// 键</span></span><br><span class="line">    <span class="type">int</span> value; <span class="comment">// 值</span></span><br><span class="line">    KVNode* prev; <span class="comment">// 前一个节点</span></span><br><span class="line">    KVNode* next; <span class="comment">// 后一个节点</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其表现为如下图所示<br><img src="/../images/image-3.png" alt="alt text"></p>
<p>当我们在做</p>
<ul>
<li>增:<code>put(key, value)</code>时，除了在哈希表中插入元素外，还要<code>tail</code>指针指向的节点后面插入一个新节点，并更新<code>tail</code>指针,复杂度为<code>O(1)</code></li>
<li>删：<code>remove(key)</code>时，除了在哈希表中删除元素外，还要删除链表中的节点，并将<code>*prev</code>和<code>*next</code>指针指向的节点连接起来，复杂度为<code>O(1)</code></li>
<li>改：<code>put(key, value)</code>时，和vainilla的哈希表一样，复杂度为<code>O(1)</code></li>
<li>查:<code>get(key)</code>时，和vainilla的哈希表一样，复杂度为<code>O(1)</code></li>
<li>遍历:直接从<code>head</code>开始遍历即可，复杂度为<code>O(n)</code></li>
</ul>
<h3 id="用数组加强哈希表（ArrayHashMap）"><a href="#用数组加强哈希表（ArrayHashMap）" class="headerlink" title="用数组加强哈希表（ArrayHashMap）"></a><a href="https://labuladong.online/algo/data-structure-basic/hashtable-with-array/">用数组加强哈希表（ArrayHashMap）</a></h3><p>为什么要用数组加强哈希表？ArrayHashMap有什么用?<strong>希望以<code>O(1)</code>复杂度从HashMap中随机抽一个KVNode(e.g. <a href="https://leetcode.cn/problems/insert-delete-getrandom-o1/description/">Leetcode3880</a>)</strong>.换言之,需要实现一个API,<code>KVNode getRandom()</code>，返回一个随机的KVNode。对于朴素的哈希表来说，随机抽取一个KVNode的算法为:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">getRandom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> index = <span class="built_in">rand</span>() % table.<span class="built_in">size</span>(); </span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>; <span class="comment">// 计数器</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;node : table[index]) &#123; <span class="comment">// 遍历链表</span></span><br><span class="line">        <span class="keyword">if</span> (count == <span class="built_in">rand</span>()) &#123; <span class="comment">// 随机数等于计数器</span></span><br><span class="line">            <span class="keyword">return</span> node; <span class="comment">// 返回节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        count++; <span class="comment">// 计数器加1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是这个算法的复杂度为<code>O(n)</code>，而我们希望它的复杂度为<code>O(1)</code>。也许你会想,直接对于HashMap的<code>table</code>数组进行随机抽取,但是这样会导致抽取到的可能会遇到空的,无论是拉链法还是线性探查法,都没有办法以<code>O(1)</code>实现<code>KVNode getRandom()</code>。 那么如何实现上述API呢？如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ArrayHashMap</span> :</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># arr: 用于存储所有的键值对[(k1, v1), (k2, v2), (k3, v3), ...]</span></span><br><span class="line">        <span class="variable language_">self</span>.arr = []</span><br><span class="line">        <span class="comment"># map: 用于储存键值对的映射关系，key -&gt; index</span></span><br><span class="line">        <span class="comment"># 例如：&#123;k1: 0, k2: 1, k3: 2, ...&#125;</span></span><br><span class="line">        <span class="variable language_">self</span>.<span class="built_in">map</span> = &#123;&#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment"># put: 插入与修改键值对,复杂度为O(1)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">put</span>(<span class="params">self, key, value</span>):</span><br><span class="line">        <span class="comment"># 如果键已经存在，更新值</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> <span class="variable language_">self</span>.<span class="built_in">map</span>:</span><br><span class="line">            index = <span class="variable language_">self</span>.<span class="built_in">map</span>[key]</span><br><span class="line">            <span class="variable language_">self</span>.arr[index] = (key, value)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 如果键不存在，插入新的键值对</span></span><br><span class="line">            <span class="variable language_">self</span>.arr.append((key, value))</span><br><span class="line">            index = <span class="built_in">len</span>(<span class="variable language_">self</span>.arr) - <span class="number">1</span></span><br><span class="line">            <span class="variable language_">self</span>.<span class="built_in">map</span>[key] = index</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># remove: 删除键值对,复杂度为O(1),</span></span><br><span class="line">    <span class="comment"># 重点是这个函数的实现</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">remove</span>(<span class="params">self, key</span>):</span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> <span class="variable language_">self</span>.<span class="built_in">map</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 获取要删除的键值对的索引</span></span><br><span class="line">        index = <span class="variable language_">self</span>.<span class="built_in">map</span>[key]</span><br><span class="line">        to_delete = <span class="variable language_">self</span>.arr[index] <span class="comment"># 获取要删除的键值对</span></span><br><span class="line">        last = <span class="variable language_">self</span>.arr[-<span class="number">1</span>] <span class="comment"># 获取最后一个键值对</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 交换</span></span><br><span class="line">        <span class="variable language_">self</span>.arr[index], <span class="variable language_">self</span>.arr[-<span class="number">1</span>] = <span class="variable language_">self</span>.arr[-<span class="number">1</span>], <span class="variable language_">self</span>.arr[index]  </span><br><span class="line">        <span class="variable language_">self</span>.<span class="built_in">map</span>[last[<span class="number">0</span>]] = index <span class="comment"># 更新映射关系</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 删除最后一个键值对</span></span><br><span class="line">        <span class="variable language_">self</span>.arr.pop() <span class="comment"># 删除最后一个键值对</span></span><br><span class="line">        <span class="comment"># 删除映射关系</span></span><br><span class="line">        <span class="variable language_">self</span>.<span class="built_in">map</span>.pop(to_delete[<span class="number">0</span>]) <span class="comment"># 删除映射关系</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># get: 获取键值对,复杂度为O(1)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self, key</span>):</span><br><span class="line">        <span class="comment"># 如果键存在，返回对应的值</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> <span class="variable language_">self</span>.<span class="built_in">map</span>:</span><br><span class="line">            index = <span class="variable language_">self</span>.<span class="built_in">map</span>[key]</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">self</span>.arr[index][<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># getRandom: 随机获取一个键值对,复杂度为O(1)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getRandom</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 随机获取一个索引</span></span><br><span class="line">        index = random.randint(<span class="number">0</span>, <span class="built_in">len</span>(<span class="variable language_">self</span>.arr) - <span class="number">1</span>)</span><br><span class="line">        <span class="comment"># 返回对应的键值对</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.arr[index]</span><br></pre></td></tr></table></figure>











<h2 id="二叉树结构及遍历"><a href="#二叉树结构及遍历" class="headerlink" title="二叉树结构及遍历"></a><a href="https://labuladong.online/algo/menu/binary-tree/">二叉树结构及遍历</a></h2><h3 id="二叉树基础及常见类型"><a href="#二叉树基础及常见类型" class="headerlink" title="二叉树基础及常见类型"></a><a href="https://labuladong.online/algo/data-structure-basic/binary-tree-basic/">二叉树基础及常见类型</a></h3><h4 id="常见的二叉树类型"><a href="#常见的二叉树类型" class="headerlink" title="常见的二叉树类型"></a>常见的二叉树类型</h4><blockquote>
<p>这一部分感觉labuladong写的有点拉,建议参考<a href="https://www.baeldung.com/cs/full-vs-complete-vs-perfect-tree">这个</a><br>另外,满二叉树和完美二叉树有点迷惑,按照wiki上的定义,Full Binary Tree其实是不”满”的<br>下面的定义是基于wiki的,即是参考<a href="https://www.baeldung.com/cs/full-vs-complete-vs-perfect-tree">这个</a>的<br>与labuladong的定义不同,但是是正确的,所以不需要纠结<br>关于定义,我采用的是如下图所示的定义<br><img src="/../images/image-5.png" alt="alt text"></p>
</blockquote>
<h5 id="满二叉树-Full-Binary-Tree"><a href="#满二叉树-Full-Binary-Tree" class="headerlink" title="满二叉树(Full Binary Tree)"></a>满二叉树(Full Binary Tree)</h5><p>满二叉树是指每个节点要么有两个子节点，要么没有子节点。</p>
<h5 id="完美二叉树-Perfect-Binary-Tree"><a href="#完美二叉树-Perfect-Binary-Tree" class="headerlink" title="完美二叉树(Perfect Binary Tree)"></a>完美二叉树(Perfect Binary Tree)</h5><p>完美二叉树是指每个节点都有两个子节点，且所有叶子节点都在同一层次上。完美二叉树的高度为$h$,第一层有$2^0$个节点，第二层有$2^1$个节点，…，第h层有$2^{h-1}$个节点，总共有$2^0+2^1+…+2^{h-1} &#x3D; 2^h - 1$个节点。 </p>
<h5 id="完全二叉树-Complete-Binary-Tree"><a href="#完全二叉树-Complete-Binary-Tree" class="headerlink" title="完全二叉树(Complete Binary Tree)"></a>完全二叉树(Complete Binary Tree)</h5><p>完全二叉树是指除了最后一层外，每一层都满员，且最后一层的节点都集中在左侧。<strong>其性质是:完全二叉树可以用数组来存储，不需要真的构建链式节点，二叉堆就是完全二叉树，可以用物理的数组来表征概念上的二叉树。</strong></p>
<h5 id="二叉搜索树-Binary-Search-Tree-BST"><a href="#二叉搜索树-Binary-Search-Tree-BST" class="headerlink" title="二叉搜索树(Binary Search Tree,BST)"></a>二叉搜索树(Binary Search Tree,BST)</h5><p>对于<strong>任何一个节点</strong>,其左子树的每个节点的值都要小于这个节点的值. <strong>其性质是:二叉搜索树的找一个节点的时间复杂度为O(logN)</strong></p>
<h5 id="平衡二叉树-Balanced-Binary-Tree-AVL-Tree"><a href="#平衡二叉树-Balanced-Binary-Tree-AVL-Tree" class="headerlink" title="平衡二叉树(Balanced Binary Tree, AVL&lt;Adelson-Velskii &amp; Landis&gt; Tree )"></a>平衡二叉树(Balanced Binary Tree, AVL&lt;Adelson-Velskii &amp; Landis&gt; Tree )</h5><p>对于<strong>任何一个节点</strong>,其左右子树的高度差不超过1. <strong>其性质是:N个节点的平衡二叉树的高度为O(logN),查找、插入和删除在平均和最坏情况下的时间复杂度都是O(logN)</strong></p>
<h5 id="自平衡二叉树-Self-Balancing-Binary-Tree"><a href="#自平衡二叉树-Self-Balancing-Binary-Tree" class="headerlink" title="自平衡二叉树 (Self-Balancing Binary Tree)"></a>自平衡二叉树 (Self-Balancing Binary Tree)</h5><p>自平衡二叉树是一种特殊的二叉搜索树，它在插入和删除节点时会自动调整树的结构，以保持平衡。常见的自平衡二叉树有红黑树。自平衡二叉树的查找、插入和删除操作的时间复杂度都是 O(log N)。</p>
<h4 id="二叉树的实现"><a href="#二叉树的实现" class="headerlink" title="二叉树的实现"></a>二叉树的实现</h4><ul>
<li>最常见的实现是采用链式存储结构，即每个节点包含三个指针，分别指向左子树、右子树</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> val; <span class="comment">// 节点值</span></span><br><span class="line">    TreeNode* left; <span class="comment">// 左子树指针</span></span><br><span class="line">    TreeNode* right; <span class="comment">// 右子树指针</span></span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;&#125; <span class="comment">// 构造函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<ul>
<li><p>另外一种实现是采用数组存储结构，即每个节点的值存储在数组中</p>
</li>
<li><p>利用哈希表存储节点的值和指针,可以实现多叉树</p>
</li>
</ul>
<h3 id="二叉树的递归-层序遍历"><a href="#二叉树的递归-层序遍历" class="headerlink" title="二叉树的递归&#x2F;层序遍历"></a><a href="https://labuladong.online/algo/data-structure-basic/binary-tree-traverse-basic/">二叉树的递归&#x2F;层序遍历</a></h3><p>和数组一样,二叉树也有遍历的概念,即访问树中的每一个节点。为了实现访问每一个节点,我们可以采用</p>
<ul>
<li>递归的方式实现，前中后序遍历</li>
<li>非递归的方式实现层序遍历，细节不同有3中写法</li>
</ul>
<h4 id="递归遍历"><a href="#递归遍历" class="headerlink" title="递归遍历"></a>递归遍历</h4><p>递归遍历的框架是</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span>; <span class="comment">// 递归终止条件</span></span><br><span class="line">    <span class="comment">//时机点1 do something with root-&gt;val; e.g. arr.push_back(root-&gt;val); </span></span><br><span class="line">    <span class="built_in">traverse</span>(root-&gt;left); <span class="comment">// 遍历左子树</span></span><br><span class="line">    <span class="comment">//时机点2 do something with root-&gt;val; e.g. arr.push_back(root-&gt;val);</span></span><br><span class="line">    <span class="built_in">traverse</span>(root-&gt;right); <span class="comment">// 遍历右子树</span></span><br><span class="line">    <span class="comment">//时机点3 do something with root-&gt;val; e.g. arr.push_back(root-&gt;val);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述遍历的方式,我们有三个时机点对root-&gt;val进行操作</p>
<ul>
<li>时机点1,也就是第一次访问该节点,该节点的左右子树都还没有被访问,此时获得的信息最少</li>
<li>时机点2,我们又一次访问了该节点,此时该节点的左子树已经被访问,右子树还没有被访问,此时获得的信息比第一次多了一点</li>
<li>时机点3,我们又一次访问了该节点,此时该节点的左右子树都已经被访问,此时获得的信息最多</li>
</ul>
<p>综上所述,我们可以得出结论,<strong>时机点1,2,3分别对应前序遍历,中序遍历,后序遍历</strong> 换言之,<strong>前序遍历,中序遍历,后序遍历</strong>的本质不同是所加的代码在上述框架中的位置不同。</p>
<blockquote>
<p>由于BST的性质,我们可以得出结论,中序遍历的结果是一个升序的数组。</p>
</blockquote>
<h4 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h4><h5 id="层序遍历的基础框架是："><a href="#层序遍历的基础框架是：" class="headerlink" title="层序遍历的基础框架是："></a>层序遍历的基础框架是：</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">levelOrderedTraverse</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span>; <span class="comment">// 递归终止条件</span></span><br><span class="line">    queue&lt;TreeNode*&gt; q; <span class="comment">// 队列</span></span><br><span class="line">    q.<span class="built_in">push</span>(root); <span class="comment">// 将根节点入队</span></span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123; <span class="comment">// 队列不为空</span></span><br><span class="line">        TreeNode* node = q.<span class="built_in">front</span>(); <span class="comment">// 取出队头元素</span></span><br><span class="line">        q.<span class="built_in">pop</span>(); <span class="comment">// 出队</span></span><br><span class="line">        <span class="comment">// do something with node-&gt;val; e.g. arr.push_back(node-&gt;val);</span></span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left != <span class="literal">nullptr</span>) q.<span class="built_in">push</span>(node-&gt;left); <span class="comment">// 左子树入队</span></span><br><span class="line">        <span class="keyword">if</span> (node-&gt;right != <span class="literal">nullptr</span>) q.<span class="built_in">push</span>(node-&gt;right); <span class="comment">// 右子树入队</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="层序遍历的带层数的框架是："><a href="#层序遍历的带层数的框架是：" class="headerlink" title="层序遍历的带层数的框架是："></a>层序遍历的带层数的框架是：</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">levelOrderedTraverse</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span>; <span class="comment">// 递归终止条件</span></span><br><span class="line">    queue&lt;TreeNode*&gt; q; <span class="comment">// 队列</span></span><br><span class="line">    q.<span class="built_in">push</span>(root); <span class="comment">// 将根节点入队</span></span><br><span class="line">    <span class="type">int</span> depth = <span class="number">0</span>; <span class="comment">// 层数</span></span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123; <span class="comment">// 队列不为空</span></span><br><span class="line">        <span class="type">int</span> size = q.<span class="built_in">size</span>(); <span class="comment">// 当前层的节点数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123; <span class="comment">// 遍历当前层的节点</span></span><br><span class="line">            TreeNode* node = q.<span class="built_in">front</span>(); <span class="comment">// 取出队头元素</span></span><br><span class="line">            q.<span class="built_in">pop</span>(); <span class="comment">// 出队</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// do something with node-&gt;val and depth; e.g:</span></span><br><span class="line">            <span class="comment">// cout &lt;&lt; &quot;depth:&quot; &lt;&lt; depth &lt;&lt; &quot; node:&quot; &lt;&lt; node-&gt;val &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (node-&gt;left != <span class="literal">nullptr</span>) q.<span class="built_in">push</span>(node-&gt;left); <span class="comment">// 左子树入队</span></span><br><span class="line">            <span class="keyword">if</span> (node-&gt;right != <span class="literal">nullptr</span>) q.<span class="built_in">push</span>(node-&gt;right); <span class="comment">// 右子树入队</span></span><br><span class="line">        &#125;</span><br><span class="line">        depth++; <span class="comment">// 层数加1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="层序遍历的”可变层数”的框架是："><a href="#层序遍历的”可变层数”的框架是：" class="headerlink" title="层序遍历的”可变层数”的框架是："></a>层序遍历的”可变层数”的框架是：</h5><p>上面一个框架中的层数本质上是该节点到根节点的距离且父节点到子节点的距离是1. 如果父节点到子节点的距离不是1,那么如何实现呢？如下图所示，每个节点的数据结构变为</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> val; <span class="comment">// 节点值</span></span><br><span class="line">    </span><br><span class="line">    TreeNode* left; <span class="comment">// 左子树指针</span></span><br><span class="line">    TreeNode* right; <span class="comment">// 右子树指针</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> l_weight; <span class="comment">// 指向左子树的权重,可以不为1</span></span><br><span class="line">    <span class="type">int</span> r_weight; <span class="comment">// 指向右子树的权重，可以不为1</span></span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>), <span class="built_in">l_weight</span>(<span class="number">0</span>), <span class="built_in">r_weight</span>(<span class="number">0</span>) &#123;&#125; <span class="comment">// 构造函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="/../images/image-7.png" alt="alt text"></p>
<p>上述功能的实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">State</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TreeNode* node; <span class="comment">// 节点</span></span><br><span class="line">    <span class="type">int</span> weight; <span class="comment">// 权重</span></span><br><span class="line">    <span class="built_in">State</span>(TreeNode* n, <span class="type">int</span> w) : <span class="built_in">node</span>(n), <span class="built_in">weight</span>(w) &#123;&#125; <span class="comment">// 构造函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">levelOrderedTraverse</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span>; <span class="comment">// 递归终止条件</span></span><br><span class="line">    queue&lt;State&gt; q; <span class="comment">// 队列</span></span><br><span class="line">    q.<span class="built_in">push</span>(<span class="built_in">State</span>(root, <span class="number">0</span>)); <span class="comment">// 将根节点入队</span></span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123; <span class="comment">// 队列不为空</span></span><br><span class="line">        State state = q.<span class="built_in">front</span>(); <span class="comment">// 取出队头元素</span></span><br><span class="line">        q.<span class="built_in">pop</span>(); <span class="comment">// 出队</span></span><br><span class="line"></span><br><span class="line">        TreeNode* node = state.node; <span class="comment">// 节点</span></span><br><span class="line">        <span class="type">int</span> weight = state.weight; <span class="comment">// 权重</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// do something with node-&gt;val and weight; e.g:</span></span><br><span class="line">        <span class="comment">// cout &lt;&lt; &quot;weight:&quot; &lt;&lt; weight &lt;&lt; &quot; node:&quot; &lt;&lt; node-&gt;val &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left != <span class="literal">nullptr</span>) q.<span class="built_in">push</span>(<span class="built_in">State</span>(node-&gt;left, weight + node-&gt;l_weight)); <span class="comment">// 左子树入队</span></span><br><span class="line">        <span class="keyword">if</span> (node-&gt;right != <span class="literal">nullptr</span>) q.<span class="built_in">push</span>(<span class="built_in">State</span>(node-&gt;right, weight + node-&gt;r_weight)); <span class="comment">// 右子树入队</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="DFS-和-BFS-的适用场景"><a href="#DFS-和-BFS-的适用场景" class="headerlink" title="DFS 和 BFS 的适用场景"></a><a href="https://labuladong.online/algo/data-structure-basic/use-case-of-dfs-bfs/">DFS 和 BFS 的适用场景</a></h3><h4 id="BFS适合查找最短路径"><a href="#BFS适合查找最短路径" class="headerlink" title="BFS适合查找最短路径"></a>BFS适合查找最短路径</h4><p>BFS适合查找最短路径,例如<a href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/">Leetcode 111</a>. 当边的权重为正的时候，层数增加势必会增加路径的长度，所以BFS适合查找最短路径，相比DFS，BFS可以提前减少不必要的搜索。</p>
<h4 id="DFS-常用来寻找所有路径"><a href="#DFS-常用来寻找所有路径" class="headerlink" title="DFS 常用来寻找所有路径"></a>DFS 常用来寻找所有路径</h4><p>DFS它本就是一条树枝一条树枝从左往右遍历的，每条树枝就是一条路径，所以 DFS 算法天然适合寻找所有路径。例如<a href="https://leetcode.cn/problems/path-sum-ii/description/">Leetcode 113</a>. DFS适合寻找所有路径的原因是DFS会遍历所有的路径，而BFS只会遍历一条路径。</p>
<h3 id="多叉树的递归-层序遍历"><a href="#多叉树的递归-层序遍历" class="headerlink" title="多叉树的递归&#x2F;层序遍历"></a><a href="https://labuladong.online/algo/data-structure-basic/n-ary-tree-traverse-basic/">多叉树的递归&#x2F;层序遍历</a></h3><p>我们可以将前文的<a href="###%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%80%92%E5%BD%92/%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86">二叉树的递归&#x2F;层序遍历</a>扩展到多叉树的递归遍历和层序遍历。如下是多叉树的节点结构体</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NTreeNode</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> val; <span class="comment">// 节点值</span></span><br><span class="line">    vector&lt;NTreeNode*&gt; children; <span class="comment">// 子节点指针</span></span><br><span class="line">    <span class="built_in">NTreeNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x) &#123;&#125; <span class="comment">// 构造函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>注意的是，多叉树的递归遍历框架如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">(NTreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span>; <span class="comment">// 递归终止条件</span></span><br><span class="line">    <span class="comment">//时机点1 do something with root-&gt;val; e.g. arr.push_back(root-&gt;val); </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> child : root-&gt;children) &#123; <span class="comment">// 遍历子节点</span></span><br><span class="line">        <span class="built_in">traverse</span>(child); <span class="comment">// 遍历子节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//时机点2 do something with root-&gt;val; e.g. arr.push_back(root-&gt;val);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>多叉树是没有中序遍历的</strong>，其层序遍历也有三种，需要注意的是，是要将</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">levelOrderedTraverse</span><span class="params">(NTreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span>; <span class="comment">// 递归终止条件</span></span><br><span class="line">    queue&lt;NTreeNode*&gt; q; <span class="comment">// 队列</span></span><br><span class="line">    q.<span class="built_in">push</span>(root); <span class="comment">// 将根节点入队</span></span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123; <span class="comment">// 队列不为空</span></span><br><span class="line">        NTreeNode* node = q.<span class="built_in">front</span>(); <span class="comment">// 取出队头元素</span></span><br><span class="line">        q.<span class="built_in">pop</span>(); <span class="comment">// 出队</span></span><br><span class="line">        <span class="comment">// do something with node-&gt;val; e.g. arr.push_back(node-&gt;val);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 只有这里与二叉树的层序遍历不同</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> child : node-&gt;children) &#123; <span class="comment">// 遍历子节点</span></span><br><span class="line">            q.<span class="built_in">push</span>(child); <span class="comment">// 子节点入队</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h2 id="二叉树结构的种种变换"><a href="#二叉树结构的种种变换" class="headerlink" title="二叉树结构的种种变换"></a><a href="https://labuladong.online/algo/menu/binary-tree/">二叉树结构的种种变换</a></h2><h3 id="二叉搜索树的应用及可视化"><a href="#二叉搜索树的应用及可视化" class="headerlink" title="二叉搜索树的应用及可视化"></a><a href="https://labuladong.online/algo/data-structure-basic/tree-map-basic/">二叉搜索树的应用及可视化</a></h3><h4 id="TreeMap-TreeSet的原理"><a href="#TreeMap-TreeSet的原理" class="headerlink" title="TreeMap&#x2F;TreeSet的原理"></a>TreeMap&#x2F;TreeSet的原理</h4><p>BST的可以在<code>O(logN)</code>的时间复杂度内查找,如下是是一个BST递归遍历查找的实现</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">search</span><span class="params">(TreeNode* root, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span>; <span class="comment">// 递归终止条件</span></span><br><span class="line">    <span class="keyword">if</span> (root-&gt;val == target) <span class="keyword">return</span>; <span class="comment">// 找到目标值</span></span><br><span class="line">    <span class="keyword">if</span> (root-&gt;val &gt; target) <span class="built_in">search</span>(root-&gt;left, target); <span class="comment">// 在左子树中查找</span></span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">search</span>(root-&gt;right, target); <span class="comment">// 在右子树中查找</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其这个特性可用于实现<code>TreeMap</code>和<code>TreeSet</code>，即有序的哈希表和哈希集合。由于我们都知道<code>set</code>是退化的<code>map</code>，所以这里我们只讨论<code>TreeMap</code>的实现，首先我们需要一个<code>TreeNode</code>的实现</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    K key; <span class="comment">// 键</span></span><br><span class="line">    V value; <span class="comment">// 值</span></span><br><span class="line">    TreeNode* left; <span class="comment">// 左子树指针</span></span><br><span class="line">    TreeNode* right; <span class="comment">// 右子树指针</span></span><br><span class="line">    <span class="built_in">TreeNode</span>(K k, V v) : <span class="built_in">key</span>(k), <span class="built_in">value</span>(v), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;&#125; <span class="comment">// 构造函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>以下是 TreeMap 和 HashMap 的区别对比表，按照接口函数分类：</p>
<table>
<thead>
<tr>
<th><strong>接口函数</strong></th>
<th><strong>说明</strong></th>
<th><strong>TreeMap</strong></th>
<th><strong>HashMap</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>put(key, value)</code></td>
<td>插入或更新键值对</td>
<td>支持，O(logN)</td>
<td>支持，平均 O(1)，最坏 O(N)</td>
</tr>
<tr>
<td><code>get(key)</code></td>
<td>获取键对应的值</td>
<td>支持，O(logN)</td>
<td>支持，平均 O(1)，最坏 O(N)</td>
</tr>
<tr>
<td><code>remove(key)</code></td>
<td>删除键值对</td>
<td>支持，O(logN)</td>
<td>支持，平均 O(1)，最坏 O(N)</td>
</tr>
<tr>
<td><code>containsKey(key)</code></td>
<td>检查是否包含键</td>
<td>支持，O(logN)</td>
<td>支持，平均 O(1)，最坏 O(N)</td>
</tr>
<tr>
<td><code>keys()</code></td>
<td>返回所有键的集合（有序）</td>
<td>支持，O(N)</td>
<td>支持，无序，O(N)</td>
</tr>
<tr>
<td><code>firstKey()</code></td>
<td>返回最小键</td>
<td>支持，O(logN)</td>
<td>不支持</td>
</tr>
<tr>
<td><code>lastKey()</code></td>
<td>返回最大键</td>
<td>支持，O(logN)</td>
<td>不支持</td>
</tr>
<tr>
<td><code>floorKey(key)</code></td>
<td>返回小于等于 key 的最大键</td>
<td>支持，O(logN)</td>
<td>不支持</td>
</tr>
<tr>
<td><code>ceilingKey(key)</code></td>
<td>返回大于等于 key 的最小键</td>
<td>支持，O(logN)</td>
<td>不支持</td>
</tr>
<tr>
<td><code>selectKey(k)</code></td>
<td>返回排名为 k 的键（按顺序）</td>
<td>支持，O(logN)</td>
<td>不支持</td>
</tr>
<tr>
<td><code>rank(key)</code></td>
<td>返回键的排名（按顺序）</td>
<td>支持，O(logN)</td>
<td>不支持</td>
</tr>
<tr>
<td><code>rangeKeys(low, high)</code></td>
<td>返回区间 [low, high] 内的键（按顺序）</td>
<td>支持，O(logN + M)（M 为结果数量）</td>
<td>不支持</td>
</tr>
</tbody></table>
<p><strong>注意：</strong> 即便我们前文中用链表加强哈希表实现了<code>LinkedHashMap</code>，但那也是仅仅实现了<strong>插入顺序</strong>的保存，没有办法按照<strong>键的顺序</strong>来遍历。只有<code>TreeMap</code>才能做到这一点。</p>
<p>下面针对上述表格中的<code>TreeMap</code>接口函数的细节实现做出一些说明：</p>
<ul>
<li><code>get(key)</code>：最基本的功能，用前文中色提到的<code>search</code>函数即可实现，复杂度为<code>O(logN)</code></li>
<li><code>put(key, value)，remove(key)，containsKey(key)</code>：都基于<code>get(key)</code>找到目标节点，然后进行相应的操作，复杂度为<code>O(logN)</code></li>
<li><code>floorKey(key),ceilingKey(key)</code>：这两个函数的实现是基于<code>get(key)</code>的，复杂度为<code>O(logN)</code>,区别是<code>get(key)</code>找不到返回的是<code>nullptr</code>,而<code>floorKey(key)</code>和<code>ceilingKey(key)</code>返回的是<code>key</code>最接近的节点</li>
<li><code>keys()</code>方法的有序需要要采用<strong>中序遍历</strong>的方式来实现，复杂度为<code>O(N)</code></li>
<li><code>selectKey(k), rank(key)</code>这两个函数比较特殊，用中序遍历也做不到<code>O(logN)</code>的复杂度,而是<code>O(k)</code>的复杂度,所以我们需要在<code>TreeNode</code>中增加一个<code>size</code>的属性。<strong>size表示以改节点为根的子树的节点总数（包含当前节点）</strong></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    K key; <span class="comment">// 键</span></span><br><span class="line">    V value; <span class="comment">// 值</span></span><br><span class="line">    TreeNode* left; <span class="comment">// 左子树指针</span></span><br><span class="line">    TreeNode* right; <span class="comment">// 右子树指针</span></span><br><span class="line">    <span class="type">int</span> size; <span class="comment">// 记录以当前节点为根的子树的节点总数（包含当前节点）</span></span><br><span class="line">    <span class="built_in">TreeNode</span>(K k, V v) : <span class="built_in">key</span>(k), <span class="built_in">value</span>(v), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>), <span class="built_in">size</span>(<span class="number">1</span>) &#123;&#125; <span class="comment">// 构造函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>则如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    7</span><br><span class="line">   / \</span><br><span class="line">  4   9</span><br><span class="line"> / \   \</span><br><span class="line">1   5   10</span><br><span class="line"></span><br><span class="line">keys [1, 4, 5, 7, 9, 10]</span><br><span class="line">rank  1  2  3  4  5  6</span><br><span class="line">size  1  3  1  6  2  1</span><br></pre></td></tr></table></figure>
<blockquote>
<p>selectKey(3)的查找过程如下:</p>
<blockquote>
<ol>
<li>从根节点7开始，size(7) &#x3D; 6, 左子树的size(4) &#x3D; 3, 则rank(7) &#x3D; size(4) + 1 &#x3D; 4, rank(7) &#x3D; 4 &gt; 2,所以去左子树查找</li>
<li>从节点4开始，size(4) &#x3D; 3, 左子树的size(1) &#x3D; 1, 则rank(4) &#x3D; size(1) + 1 &#x3D; 2, rank(4) &#x3D; 2 &lt; 3,所以去右子树查找</li>
<li>从节点5开始，rank(4)&#x3D; 2.rank(7)&#x3D;4,且5在4的右子树中,5在7的左子树中,rank(4)&#x3D;2 &lt; rank(5) &lt; rank(7)&#x3D;4，所以rank（5）&#x3D; 3</li>
<li>返回selectKey(3) &#x3D; 5</li>
</ol>
</blockquote>
</blockquote>
<blockquote>
<p>rank(9)的查找过程如下:</p>
<blockquote>
<ol>
<li>从根节点7开始，size(7) &#x3D; 6, 左子树的size(4) &#x3D; 3, 则rank(7) &#x3D; size(4) + 1 &#x3D; 4, 9在7的右子树中，所以去右子树查找</li>
<li>从节点9开始，size(9) &#x3D; 2, 左子树的为空，则rank(9) &#x3D; 1 + rank(7) &#x3D; 1 + 4 &#x3D; 5</li>
<li>返回rank(9) &#x3D; 5</li>
</ol>
</blockquote>
</blockquote>
<h4 id="性能退化"><a href="#性能退化" class="headerlink" title="性能退化"></a>性能退化</h4><p>上述所有的复杂度都是建立在该二叉树搜索树是平衡的基础上，如下所示，该二叉树也是BST</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line"> \</span><br><span class="line">  2</span><br><span class="line">   \</span><br><span class="line">    3</span><br></pre></td></tr></table></figure>
<p>显然<strong>该二叉搜索树没有办法以<code>O(logN)</code>的复杂度来查找元素,而是<code>O(N)</code>的复杂度,所以我们需要一种自动平衡的二叉搜索树</strong>,即自平衡二叉搜索树,如红黑树和AVL树，利用旋转来实现自平衡。将上述的二叉搜索树变为如下所示的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  2</span><br><span class="line"> / \</span><br><span class="line">1   3</span><br></pre></td></tr></table></figure>





<h3 id="红黑树的完美平衡及可视化"><a href="#红黑树的完美平衡及可视化" class="headerlink" title="红黑树的完美平衡及可视化"></a><a href="https://labuladong.online/algo/data-structure-basic/rbtree-basic/">红黑树的完美平衡及可视化</a></h3><blockquote>
<p>虽然红黑树是具体如何实现的，目前不得而知，但是其有如下的性质</p>
<ol>
<li>总是能保证BST的性质</li>
<li>总是能保证树的高度是O(logN)，不会退化成链表</li>
</ol>
</blockquote>
<p>可以基于这种自平衡的二叉搜索树来实现<code>TreeMap</code>和<code>TreeSet</code>，从而在**牺牲一些增删改查的性能的前提下，来满足前文中提到的<code>TreeMap</code>和<code>TreeSet</code>的特殊接口函数的实现。**我们不需要知道红黑树的具体实现，只需要能调用即可，<strong>在C++中可以使用<code>std::set</code>和<code>std::map</code>的底层就是<code>TreeMap</code>和<code>TreeSet</code>。在Python中可以使用<code>sortedcontainers</code>库中的<code>SortedDict</code>和<code>SortedSet</code>，但Python的标准库中没有。</strong></p>
<h3 id="Trie-字典树-前缀树原理及可视化"><a href="#Trie-字典树-前缀树原理及可视化" class="headerlink" title="Trie&#x2F;字典树&#x2F;前缀树原理及可视化"></a><a href="https://labuladong.online/algo/data-structure-basic/trie-map-basic/">Trie&#x2F;字典树&#x2F;前缀树原理及可视化</a></h3><blockquote>
<p>Trie在C++和PPython中都没有原生支持</p>
</blockquote>
<p>Tire这种数据结构，<strong>本质上是个多叉树</strong>，来自于retrieval的英文单词，意思是“检索”，它的主要作用是<strong>高效地存储和检索字符串</strong>，由于其本质上是tree，所以截取自retrieval中的“trie”这个词。</p>
<h4 id="Trie-树的主要应用场景"><a href="#Trie-树的主要应用场景" class="headerlink" title="Trie 树的主要应用场景"></a>Trie 树的主要应用场景</h4><h5 id="节约存储空间"><a href="#节约存储空间" class="headerlink" title="节约存储空间"></a>节约存储空间</h5><p>假设插入了大量的类似于<code>[&#123;&quot;hello&quot;:1&#125;, &#123;&quot;hell&quot;:2&#125;, &#123;&quot;he&quot;:3&#125;]</code>这样的键值对，使用Trie树可以节约存储空间。因为这些字符串有很多相同的前缀，Trie树可以将它们存储在同一条路径上。</p>
<h5 id="方便前缀处理"><a href="#方便前缀处理" class="headerlink" title="方便前缀处理"></a>方便前缀处理</h5><p>Trie树的另一个重要应用场景是前缀处理，比如查找以某个前缀开头的所有字符串。Trie树可以在O(M)的时间复杂度内找到所有以某个前缀开头的字符串，其中M为前缀的长度。</p>
<h5 id="可以使用通配符"><a href="#可以使用通配符" class="headerlink" title="可以使用通配符"></a>可以使用通配符</h5><p>比方说你想要查找所有<code>?h?o</code>的字符串，Trie树可以较为方便地实现这个功能。</p>
<h5 id="可以按照字典序遍历键"><a href="#可以按照字典序遍历键" class="headerlink" title="可以按照字典序遍历键"></a>可以按照字典序遍历键</h5><p>这个功能其实通过<code>TreeMap</code>也可以实现，但<code>HashMap</code>就不行了。Trie树可以按照字典序遍历键，时间复杂度为O(N)，其中N为Trie树的节点数。</p>
<h4 id="盘点一下截至到目前学习过的Map-Set"><a href="#盘点一下截至到目前学习过的Map-Set" class="headerlink" title="盘点一下截至到目前学习过的Map&#x2F;Set"></a>盘点一下截至到目前学习过的Map&#x2F;Set</h4><table>
<thead>
<tr>
<th><strong>数据结构</strong></th>
<th><strong>说明</strong></th>
<th><strong>时间复杂度</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>HashMap/HashSet</code></td>
<td>本质上是一个数组，通过哈希函数将键映射到数组的索引上</td>
<td>增删改查平均 O(1)</td>
</tr>
<tr>
<td><code>LinkedHashMap/LinkedHashSet</code></td>
<td>本质上是一个链表+哈希表，链表维护插入顺序</td>
<td>增删改查平均 O(1)</td>
</tr>
<tr>
<td><code>ArrayHashMap/ArrayHashSet</code></td>
<td>本质上是一个数组+哈希表，以O(1)实现<code>getRandom()</code></td>
<td>增删改查平均 O(1)</td>
</tr>
<tr>
<td><code>TreeMap/TreeSet</code></td>
<td>本质上是一个红黑树，维护键的顺序</td>
<td>增删改查 O(logN)</td>
</tr>
<tr>
<td><code>TrieMap/TrieSet</code></td>
<td>本质上是一个多叉树，维护字符串的前缀</td>
<td>插入 O(M)，查找 O(M)，M 为字符串长度</td>
</tr>
</tbody></table>
<h3 id="二叉堆核心原理及可视化"><a href="#二叉堆核心原理及可视化" class="headerlink" title="二叉堆核心原理及可视化"></a><a href="https://labuladong.online/algo/data-structure-basic/binary-heap-basic/">二叉堆核心原理及可视化</a></h3><blockquote>
<p>C++和Python中都原生的支持二叉堆的实现，C++中是<code>algorithm</code>库中的<code>make_heap</code>和<code>pop_heap</code>，Python中是<code>heapq</code>模块中的<code>heapify</code>和<code>heappop</code>。</p>
</blockquote>
<h4 id="二叉堆的性质"><a href="#二叉堆的性质" class="headerlink" title="二叉堆的性质"></a>二叉堆的性质</h4><p>以最小堆为例，二叉堆的性质是：</p>
<ul>
<li>对于二叉堆中的每一个节点，其值都小于等于其子节点的值</li>
<li>添加一个新节点时，先将其添加到堆的末尾，然后通过上浮操作将其放到正确的位置，复杂度为<code>O(logN)</code></li>
<li>删除堆顶元素时，将堆顶元素与堆的最后一个元素交换，然后删除最后一个元素，再通过下沉操作将新的堆顶元素放到正确的位置，复杂度为<code>O(logN)</code></li>
</ul>
<h4 id="应用1：优先级队列"><a href="#应用1：优先级队列" class="headerlink" title="应用1：优先级队列"></a>应用1：优先级队列</h4><p>其API如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PriorityQueue</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span></span>; <span class="comment">// 入队，复杂度为O(logN)</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span></span>; <span class="comment">// 出队，复杂度为O(logN)</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span></span>; <span class="comment">// 返回队头元素，复杂度为O(1)</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span></span>; <span class="comment">// 判断队列是否为空</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span></span>; <span class="comment">// 返回队列大小</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong> 这里之所以叫队列是因为其与队列的接口函数类似，但其本质上是一个二叉堆。 </p>
<h4 id="应用2：堆排序"><a href="#应用2：堆排序" class="headerlink" title="应用2：堆排序"></a>应用2：堆排序</h4><p>整体的复杂度为<code>O(NlogN)</code>，其实现如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">heapSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(arr.size())</span></span>; <span class="comment">// 结果数组</span></span><br><span class="line">    PriorityQueue pq; <span class="comment">// 优先级队列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 入队,复杂度为O(NlogN)</span></span><br><span class="line">        pq.<span class="built_in">push</span>(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 出队，复杂度为O(NlogN)</span></span><br><span class="line">        res[i] = pq.<span class="built_in">top</span>(); <span class="comment">// 返回队头元素</span></span><br><span class="line">        pq.<span class="built_in">pop</span>(); <span class="comment">// 出队</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res; <span class="comment">// 返回结果数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="二叉堆一定要是树吗？"><a href="#二叉堆一定要是树吗？" class="headerlink" title="二叉堆一定要是树吗？"></a>二叉堆一定要是树吗？</h4><p>不一定，二叉堆，二叉树本质上是逻辑概念，而不是物理概念。天然地，我们可以用链式存储结构来实现二叉堆，但我们也可以用连续的数据结构来表征逻辑上的二叉堆。</p>
<h3 id="二叉堆-优先级队列代码实现"><a href="#二叉堆-优先级队列代码实现" class="headerlink" title="二叉堆&#x2F;优先级队列代码实现"></a><a href="https://labuladong.online/algo/data-structure-basic/binary-heap-implement/">二叉堆&#x2F;优先级队列代码实现</a></h3><p>二叉堆的在增删元素时，其性质是通过<code>swim</code>和<code>sink</code>来确保的，这两个函数需要用到子节点和父节点的索引。由于二叉堆由于是完全二叉树，我们可以知道其子节点的索引是<code>2*i+1</code>和<code>2*i+2</code>,父节点的索引是<code>(i-1)/2</code>,所以我们可以用数组来实现二叉堆。如果采用链式存储，可节点需要保存父节点和子节点的指针。其实现如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BinaryHeapNode</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> val; <span class="comment">// 节点值</span></span><br><span class="line">    BinaryHeapNode* left; <span class="comment">// 左子树指针</span></span><br><span class="line">    BinaryHeapNode* right; <span class="comment">// 右子树指针</span></span><br><span class="line">    BinaryHeapNode* parent; <span class="comment">// 父节点指针</span></span><br><span class="line">    <span class="built_in">BinaryHeapNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>), <span class="built_in">parent</span>(<span class="literal">nullptr</span>) &#123;&#125; <span class="comment">// 构造函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="增：push-swim"><a href="#增：push-swim" class="headerlink" title="增：push&#x2F;swim"></a>增：push&#x2F;swim</h4><p>以最小堆为例，其主要流程如下</p>
<ul>
<li>1、先把新元素追加到二叉树底层的最右侧，保持完全二叉树的结构。此时该元素的父节点可能比它大，不满足小顶堆的性质。</li>
<li>2、为了恢复小顶堆的性质，需要将这个新元素不断上浮（swim），直到它的父节点比它小为止，或者到达根节点。</li>
</ul>
<h4 id="删：pop-sink"><a href="#删：pop-sink" class="headerlink" title="删：pop&#x2F;sink"></a>删：pop&#x2F;sink</h4><p>以最小堆为例，其主要流程如下</p>
<ul>
<li>1、将堆顶元素（最小值）与最后一个元素交换，然后弹出最后一个元素，保持完全二叉树的结构。</li>
<li>2、为了恢复小顶堆的性质，需要将新的堆顶元素不断下沉（sink），直到它的子节点比它大为止，或者到达叶子节点。</li>
</ul>
<h4 id="查：top-peek，-复杂度为O-1"><a href="#查：top-peek，-复杂度为O-1" class="headerlink" title="查：top&#x2F;peek， 复杂度为O(1)"></a>查：top&#x2F;peek， 复杂度为<code>O(1)</code></h4><p>没啥好说的，直接返回堆顶元素即可。</p>
<h4 id="为什么推荐采用数组表征二叉堆？"><a href="#为什么推荐采用数组表征二叉堆？" class="headerlink" title="为什么推荐采用数组表征二叉堆？"></a>为什么推荐采用数组表征二叉堆？</h4><p>增时需要在最底层的最右侧添加元素，删时需要在将根和最底层的最右侧元素交换，保持完全二叉树的结构。这两种操作都需要<strong>频繁地访问最底层的最右侧元素，采用数组表征二叉堆可以在<code>O(1)</code>的时间复杂度内访问到该元素，而采用链式存储结构则需要<code>O(N)</code>的时间复杂度。</strong></p>
<h4 id="数组表征二叉堆的实现"><a href="#数组表征二叉堆的实现" class="headerlink" title="数组表征二叉堆的实现"></a>数组表征二叉堆的实现</h4><p>当且仅当完全二叉树才能用数组表征，完全二叉树的数组表征如下图：<br><img src="/../images/image-8.png" alt="alt text"><br>对于node.val &#x3D; arr[i]，以<code>arr[2] = R</code>为例</p>
<ul>
<li>左子节点的索引为<code>2*i+1 = 5</code> 为O </li>
<li>右子节点的索引为<code>2*i+2 = 6</code> 为A</li>
<li>父节点的索引为<code>(i-1)//2 = 0</code> 为T</li>
</ul>
<h3 id="线段树核心原理及可视化"><a href="#线段树核心原理及可视化" class="headerlink" title="线段树核心原理及可视化"></a><a href="https://labuladong.online/algo/data-structure-basic/segment-tree-basic/">线段树核心原理及可视化</a></h3><blockquote>
<p>C++和Python中都没有原生的支持线段树的实现，</p>
</blockquote>
<p>现在有一个数组<code>arr = [1, 3, 5, 7, 9, 11]</code>，我们需要实现如下的功能</p>
<ul>
<li><ol>
<li>查询区间<code>merge（i, j）</code>的值，其中<code>merge（i, j）</code>是一个聚合函数，表示对区间<code>[i, j]</code>的元素进行某种操作，比如求和、求最小值、求最大值等</li>
</ol>
</li>
<li><ol start="2">
<li>更新区间<code>arr[i] = x</code>的值</li>
</ol>
</li>
</ul>
<p>自然的，我们可以朴素的用数组实现一个<code>VanillaSegmentTree</code>，如下所示</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">VanillaSegmentTree</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, arr, merge</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :param arr: 原始数组</span></span><br><span class="line"><span class="string">        :param merge: 聚合函数</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="variable language_">self</span>.arr = arr </span><br><span class="line">        <span class="variable language_">self</span>.merge = merge</span><br><span class="line">    <span class="comment"># 查询区间[i, j]的值, 复杂度为O(N)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">query</span>(<span class="params">self, i,j</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.merge(<span class="variable language_">self</span>.arr[i:j+<span class="number">1</span>])</span><br><span class="line">    <span class="comment"># 更新区间arr[i] = val, 复杂度为O(1)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">update</span>(<span class="params">self, i, val</span>):</span><br><span class="line">        <span class="variable language_">self</span>.arr[i] = val</span><br></pre></td></tr></table></figure>
<p>现在的问题是，我们可以舍弃一部分<code>update</code>的时间复杂度来换取<code>query</code>的时间复杂度，换言之，这个数组我们不太经常更新，但我们经常查询。有什么好的方法吗？<strong>可以采用线段树来实现，其接口如下</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SegmentTree</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SegmentTree</span>(vector&lt;<span class="type">int</span>&gt;&amp; arr, function&lt;<span class="built_in">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; merge); <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span></span>; <span class="comment">// 查询区间[i, j]的值，复杂度为O(logN)</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> val)</span></span>; <span class="comment">// 更新区间arr[i] = val，复杂度为O(logN)</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这种数据结构就是线段树，其牺牲了<code>update</code>的时间复杂度来换取<code>query</code>一个数组闭区间[i, j]上的merge值的时间复杂度为<code>O(logN)</code>，而不是<code>O(N)</code>。</p>
<h2 id="图论数据结构及遍历"><a href="#图论数据结构及遍历" class="headerlink" title="图论数据结构及遍历"></a><a href="https://labuladong.online/algo/menu/graph-theory/">图论数据结构及遍历</a></h2><h3 id="图结构基础及通用代码实现"><a href="#图结构基础及通用代码实现" class="headerlink" title="图结构基础及通用代码实现"></a><a href="https://labuladong.online/algo/data-structure-basic/graph-basic/">图结构基础及通用代码实现</a></h3><h4 id="图的逻辑结构"><a href="#图的逻辑结构" class="headerlink" title="图的逻辑结构"></a>图的逻辑结构</h4><p>如下是图的逻辑结构</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Vertex</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> val; <span class="comment">// 节点值</span></span><br><span class="line">    vector&lt;Vertex*&gt; neighbors; <span class="comment">// 邻接表指针</span></span><br><span class="line">    <span class="built_in">GraphNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x) &#123;&#125; <span class="comment">// 构造函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上述是图的逻辑表述，具体实现可能不采用如上的数据结构。图的逻辑结构和多叉树是类似的，但是较为松弛，图的节点是可以任意指向的，而多叉树的节点是只能指向子节点的。</p>
<p>入度和出度是有向图的概念，入度是指有多少条边指向该节点，出度是指该节点指向多少条边。对于无向图来说，入度和出度是相同的。</p>
<h4 id="邻接表和邻接矩阵实现图结构"><a href="#邻接表和邻接矩阵实现图结构" class="headerlink" title="邻接表和邻接矩阵实现图结构"></a>邻接表和邻接矩阵实现图结构</h4><p>对于如下的图的邻接表和邻接矩阵的实现，可视化为：<br><img src="/../images/image-9.png" alt="alt text"></p>
<p>在代码结构层面上，上述无权图的邻接表和邻接矩阵的实现如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 邻接表,空间复杂度为O(V+E),V为节点数，E为边数，适合稀疏图</span></span><br><span class="line"><span class="comment">// 优势：空间复杂度低，适合稀疏图</span></span><br><span class="line"><span class="comment">// 劣势：需要拓展结构体（如下所示，加入权重等属性)后才能实现有权图</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; graph = &#123;</span><br><span class="line">    &#123;<span class="number">4</span>,<span class="number">3</span>,<span class="number">1</span>&#125;, <span class="comment">// 节点0的邻接节点</span></span><br><span class="line">    &#123;<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>&#125;, <span class="comment">// 节点1的邻接节点</span></span><br><span class="line">    &#123;<span class="number">3</span>&#125;, <span class="comment">// 节点2的邻接节点</span></span><br><span class="line">    &#123;<span class="number">4</span>&#125;,  <span class="comment">// 节点3的邻接节点</span></span><br><span class="line">    &#123;&#125; <span class="comment">// 节点4的邻接节点</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 邻接矩阵，空间复杂度为O(V^2),V为节点数，适合稠密图</span></span><br><span class="line"><span class="comment">// 优势：天然是个矩阵，可以采用矩阵运算来实现部分算法；天然支持有权图</span></span><br><span class="line"><span class="comment">// 劣势：空间复杂度高，适合稠密图</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; graph = &#123;</span><br><span class="line">    &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>&#125;, <span class="comment">// 节点0的邻接节点</span></span><br><span class="line">    &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;, <span class="comment">// 节点1的邻接节点</span></span><br><span class="line">    &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;, <span class="comment">// 节点2的邻接节点</span></span><br><span class="line">    &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>&#125;, <span class="comment">// 节点3的邻接节点</span></span><br><span class="line">    &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;  <span class="comment">// 节点4的邻接节点</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如果是有权图，则邻接表和邻接矩阵的实现如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 邻接表</span></span><br><span class="line"><span class="comment">// graph[x] 存储 x 的所有邻居节点以及对应的权重</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">    <span class="type">int</span> to; <span class="comment">// 目标节点,destnation</span></span><br><span class="line">    <span class="type">int</span> weight;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;Edge&gt;&gt; graph;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 邻接矩阵</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; matrix;</span><br></pre></td></tr></table></figure>




<blockquote>
<p>如果节点不是int类型，而是例如<code>string</code>类型的等的，可以使用哈希表来把节点值映射到索引上，或者使用<code>unordered_map</code>来实现邻接表。</p>
</blockquote>
<h4 id="图结构的通用代码实现"><a href="#图结构的通用代码实现" class="headerlink" title="图结构的通用代码实现"></a>图结构的通用代码实现</h4><p>无论采用那种实现（邻接表还是邻接矩阵），还是表征那种图（有向图还是无向图，有权图还是无权图），图的通用API都可以如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Graph</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 添加一条边（带权重）</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">addEdge</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to, <span class="type">int</span> weight)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 删除一条边</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">removeEdge</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 判断两个节点是否相邻</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">hasEdge</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 返回一条边的权重</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">weight</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 返回某个节点的所有邻居节点和对应权重</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::vector&lt;Edge&gt; <span class="title">neighbors</span><span class="params">(<span class="type">int</span> v)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 返回节点总数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">size</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 虚拟析构函数，确保子类正确释放资源</span></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Graph</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h5 id="无向图（Undirected-Graph）"><a href="#无向图（Undirected-Graph）" class="headerlink" title="无向图（Undirected Graph）"></a>无向图（Undirected Graph）</h5><h6 id="无向无权图（Undirected-Unweighted-Graph）"><a href="#无向无权图（Undirected-Unweighted-Graph）" class="headerlink" title="无向无权图（Undirected Unweighted Graph）"></a>无向无权图（Undirected Unweighted Graph）</h6><h6 id="无向加权图（Undirected-Weighted-Graph）"><a href="#无向加权图（Undirected-Weighted-Graph）" class="headerlink" title="无向加权图（Undirected Weighted Graph）"></a>无向加权图（Undirected Weighted Graph）</h6><h5 id="有向图（Directed-Graph）"><a href="#有向图（Directed-Graph）" class="headerlink" title="有向图（Directed Graph）"></a>有向图（Directed Graph）</h5><h6 id="有向无权图（Directed-Unweighted-Graph）"><a href="#有向无权图（Directed-Unweighted-Graph）" class="headerlink" title="有向无权图（Directed Unweighted Graph）"></a>有向无权图（Directed Unweighted Graph）</h6><h6 id="有向加权图（Directed-Weighted-Graph）"><a href="#有向加权图（Directed-Weighted-Graph）" class="headerlink" title="有向加权图（Directed Weighted Graph）"></a>有向加权图（Directed Weighted Graph）</h6><p>无向图和无权图都可以通过有向加权图退化而来，在这里只实现有向加权图API即可，其他的图的实现可以通过有向加权图的实现来实现。</p>
<ul>
<li>有向图加权图的邻接矩阵实现</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DirectedWeightedGraph</span> : <span class="keyword">public</span> Graph &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="type">int</span> to; <span class="comment">// 目标节点</span></span><br><span class="line">        <span class="type">int</span> weight; <span class="comment">// 权重</span></span><br><span class="line">        <span class="built_in">Edge</span>(<span class="type">int</span> f, <span class="type">int</span> t, <span class="type">int</span> w) :, <span class="built_in">to</span>(t), <span class="built_in">weight</span>(w) &#123;&#125; <span class="comment">// 构造函数</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">DirectedWeightedGraph</span>(<span class="type">int</span> n)  &#123;</span><br><span class="line">        matrix = vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">0</span>)); <span class="comment">// 初始化邻接矩阵</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 添加一条边</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addEdge</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to, <span class="type">int</span> weight)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        matrix[from][to] = weight; <span class="comment">// 添加边</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 删除一条边</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">removeEdge</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        matrix[from][to] = <span class="number">0</span>; <span class="comment">// 删除边</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断两个节点是否相邻</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasEdge</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> matrix[from][to] != <span class="number">0</span>; <span class="comment">// 判断是否相邻</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回一条边的权重</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">weight</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> matrix[from][to]; <span class="comment">// 返回权重</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回某个节点的所有邻居节点和对应权重</span></span><br><span class="line">    <span class="function">vector&lt;Edge&gt; <span class="title">neighbors</span><span class="params">(<span class="type">int</span> v)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        vector&lt;Edge&gt; edges; <span class="comment">// 邻接节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> to = <span class="number">0</span>; to &lt; matrix[v].<span class="built_in">size</span>(); to++) &#123; <span class="comment">// 遍历邻接矩阵</span></span><br><span class="line">            <span class="keyword">if</span> (matrix[v][to] != <span class="number">0</span>) &#123; <span class="comment">// 如果有边</span></span><br><span class="line">                edges.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(to, matrix[v][to])); <span class="comment">// 添加边</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> edges; <span class="comment">// 返回邻接节点</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回节点总数</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> matrix.<span class="built_in">size</span>(); <span class="comment">// 返回节点总数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; matrix; <span class="comment">// 邻接矩阵</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>有向图加权图的邻接表实现</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DirectedWeightedGraph</span> : <span class="keyword">public</span> Graph &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="type">int</span> to; <span class="comment">// 目标节点</span></span><br><span class="line">        <span class="type">int</span> weight; <span class="comment">// 权重</span></span><br><span class="line">        <span class="built_in">Edge</span>(<span class="type">int</span> f, <span class="type">int</span> t, <span class="type">int</span> w) :, <span class="built_in">to</span>(t), <span class="built_in">weight</span>(w) &#123;&#125; <span class="comment">// 构造函数</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">DirectedWeightedGraph</span>(<span class="type">int</span> n)  &#123;</span><br><span class="line">        graph = vector&lt;vector&lt;Edge&gt;&gt;(n); <span class="comment">// 初始化邻接表</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 添加一条边</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addEdge</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to, <span class="type">int</span> weight)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        graph[from].<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(to, weight)); <span class="comment">// 添加边</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 删除一条边</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">removeEdge</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; graph[from].<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 遍历邻接表</span></span><br><span class="line">            <span class="keyword">if</span> (graph[from][i].to == to) &#123; <span class="comment">// 如果有边</span></span><br><span class="line">                graph[from].<span class="built_in">erase</span>(graph[from].<span class="built_in">begin</span>() + i); <span class="comment">// 删除边</span></span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">// 退出循环</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断两个节点是否相邻</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasEdge</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; graph[from].<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 遍历邻接表</span></span><br><span class="line">            <span class="keyword">if</span> (graph[from][i].to == to) &#123; <span class="comment">// 如果有边</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 返回true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 返回false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回一条边的权重</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">weight</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; graph[from].<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 遍历邻接表</span></span><br><span class="line">            <span class="keyword">if</span> (graph[from][i].to == to) &#123; <span class="comment">// 如果有边</span></span><br><span class="line">                <span class="keyword">return</span> graph[from][i].weight; <span class="comment">// 返回权重</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 返回0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回某个节点的所有邻居节点和对应权重</span></span><br><span class="line">    <span class="function">vector&lt;Edge&gt; <span class="title">neighbors</span><span class="params">(<span class="type">int</span> v)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> graph[v]; <span class="comment">// 返回邻接节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回节点总数</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> graph.<span class="built_in">size</span>(); <span class="comment">// 返回节点总数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;Edge&gt;&gt; graph; <span class="comment">// 邻接表</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="图结构的-DFS-BFS-遍历"><a href="#图结构的-DFS-BFS-遍历" class="headerlink" title="图结构的 DFS&#x2F;BFS 遍历"></a><a href="https://labuladong.online/algo/data-structure-basic/graph-traverse-basic/">图结构的 DFS&#x2F;BFS 遍历</a></h3><blockquote>
<p>一句话总结：图的遍历和多叉树的遍历十分类似，都可以DFS&#x2F;BFS遍历。</p>
<blockquote>
<p>图的遍历和多叉树的遍历十分类似，但有两点不同：</p>
<blockquote>
<p>1.图的遍历可能出现环。遍历节点时需要维护一个<code>visited</code>数组来标记节点是否被访问过。<br>2.多叉树遍历点等价于遍历路径，因为根节点到叶子节点的路径是唯一的，而图的遍历点不等价于遍历路径，因为图的遍历点可能有多条路径。遍历路径时需要维护一个<code>onPath</code>数组来标记节点是否在路径上。之所以遍历路径时不能采用<code>visited</code>数组，from-&gt;to的可行路径不止一条（即便是DAG），所以要采用<code>onPath</code>数组来标记，最重要的是<code>onPath</code>要在后序位置处撤销。</p>
</blockquote>
</blockquote>
</blockquote>
<p>图的数据结构有三种，分别是前面说到的链式存储，十分类似多叉树的<code>Vertex</code>、 邻接表和邻接矩阵(这两个API一样，放在一起说)。由于<code>Vertex</code>与多叉树最为类似，我们先从<code>Vertex</code>开始说起，在这里的<code>Vertex</code>类稍有不同，我们引入了<code>id</code>来标记节点的唯一性。邻接表和邻接矩阵很好从<code>Vertex</code>类中推导出来，邻接表和邻接矩阵的实现可以参考前面的图的实现。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Vertex</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> id; <span class="comment">// 节点id,唯一标识，防止死循环</span></span><br><span class="line">    <span class="type">int</span> val; <span class="comment">// 节点值</span></span><br><span class="line">    vector&lt;Vertex*&gt; neighbors; <span class="comment">// 邻接表指针</span></span><br><span class="line">    <span class="built_in">Vertex</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x) &#123;&#125; <span class="comment">// 构造函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="图的DFS-BFS遍历实现"><a href="#图的DFS-BFS遍历实现" class="headerlink" title="图的DFS&#x2F;BFS遍历实现"></a>图的DFS&#x2F;BFS遍历实现</h4><h4 id="DFS遍历实现"><a href="#DFS遍历实现" class="headerlink" title="DFS遍历实现"></a>DFS遍历实现</h4><h5 id="DFS遍历所有节点（Visited数组）"><a href="#DFS遍历所有节点（Visited数组）" class="headerlink" title="DFS遍历所有节点（Visited数组）"></a>DFS遍历所有节点（Visited数组）</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">(Vertex* root,vector&lt;<span class="type">bool</span>&gt;&amp; visited)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span>; <span class="comment">// 如果节点为空，返回</span></span><br><span class="line">    <span class="keyword">if</span> (visited[root.id]) <span class="keyword">return</span>; <span class="comment">// 如果节点已经访问过，返回</span></span><br><span class="line">    visited[root.id] = <span class="literal">true</span>; <span class="comment">// 标记节点为已访问</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 时间点1： 前序位置</span></span><br><span class="line">    <span class="comment">// do something with root, e.g. cout &lt;&lt; root.val &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> neighbor : root.neighbors) &#123; <span class="comment">// 遍历邻接表</span></span><br><span class="line">        <span class="built_in">traverse</span>(neighbor, visited); <span class="comment">// 递归遍历邻接节点</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 时间点2： 后序位置</span></span><br><span class="line">    <span class="comment">// do something with root e.g. cout &lt;&lt; root.val &lt;&lt; endl;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="DFS遍历所有路径（OnPath数组）"><a href="#DFS遍历所有路径（OnPath数组）" class="headerlink" title="DFS遍历所有路径（OnPath数组）"></a>DFS遍历所有路径（OnPath数组）</h5><p>首先考虑最简单的多叉树的<code>src-&gt;dest</code>路径，假设我们有如下的多叉树</p>
<pre class="mermaid">graph TB
   0((0,src)) --> 3
    0 --> 1
    0 --> 2
    3 --> 4((4,dest))</pre>
<p>很简单，只需要遍历所有节点到达<code>dest</code>节点的路径即可，且可行路径最多有一条，这是因为多叉树的性质决定的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">path = [] <span class="comment"># 存储路径</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">traverse</span>(<span class="params">src,dest</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> src: <span class="keyword">return</span> <span class="comment"># 如果节点为空，返回</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 时间点1： 前序位置</span></span><br><span class="line">    path.append(src) </span><br><span class="line">    <span class="keyword">if</span> src == dest: <span class="comment"># 如果节点是目标节点，返回</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;找到路径：&quot;</span>, path) <span class="comment"># 找到路径，打印路径</span></span><br><span class="line">        <span class="keyword">return</span> <span class="comment"># 找到了，不用再遍历了</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> neighbor <span class="keyword">in</span> src.neighbors: <span class="comment"># 遍历邻接表</span></span><br><span class="line">        traverse(neighbor, dest) <span class="comment"># 递归遍历邻接节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 时间点2： 后序位置</span></span><br><span class="line">    path.pop() <span class="comment"># 撤销路径</span></span><br><span class="line"></span><br><span class="line">traverse(src = <span class="number">0</span>, dest = <span class="number">4</span>) <span class="comment"># 遍历路径</span></span><br></pre></td></tr></table></figure>
<p>搜索的树为：</p>
<pre class="mermaid">graph TB
   0(("traverse( 0,  4)")) --> 1(("traverse( 1,  4)"))
   0(("traverse( 0,  4)")) --> 2(("traverse( 2,  4)"))
   0(("traverse( 0,  4)")) --> 3(("traverse( 3,  4)"))
   1(("traverse( 1,  4)")) --> 4(("traverse(None,  4)"))
   2(("traverse( 2,  4)")) --> 5(("traverse(None,  4)"))
    3(("traverse( 3,  4)")) --> 6(("found！traverse(4,4),"))</pre>





<p>但是如果是图呢？我们可以用<code>onPath</code>数组来标记路径上的节点，<code>onPath</code>数组的作用是标记当前节点是否在路径上。<code>onPath</code>的引入是为了防止死循环的发生，如下图所示，可以避免类似于<code>0(from)-&gt;(1-&gt;2-&gt;3)*n-&gt;4(dest)</code>的产生，避免节点的重复访问。但是没有采用前面的<code>visited</code>数组是因为这样不会漏掉<code>0-&gt;3-&gt;1-&gt;4</code>的可行路径,因为采用visited再搜索完成<code>0-&gt;1-&gt;??</code>后，1会被标记为已访问，导致<code>0-&gt;3-&gt;1-&gt;4</code>的路径无法被访问到。</p>
<pre class="mermaid">graph TB
   0((0,src)) --> 3
    0 --> 1
    1 --> 2
    1 --> 4
    2 --> 3
    3 --> 1
    3 --> 4
    4((4,dest)) --> 0</pre>

<p>上述图的<code>src-&gt;dest</code>路径的实现如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">path = [] <span class="comment"># 存储路径</span></span><br><span class="line">onPath = [false] * n</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">traverse</span>(<span class="params">src,dest</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> src: <span class="keyword">return</span> <span class="comment"># 如果节点为空，返回</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> onPath[src]: <span class="keyword">return</span> <span class="comment"># 如果节点已经在路径上，返回,避免死循环</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 时间点1： 前序位置</span></span><br><span class="line">    path.append(src) </span><br><span class="line">    onPath[src] = true <span class="comment"># 标记路径上的节点为true</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> src == dest: <span class="comment"># 如果节点是目标节点，返回</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;找到路径：&quot;</span>, path) <span class="comment"># 找到路径，打印路径</span></span><br><span class="line">        <span class="comment"># return 这里不return，如果非要return的话，下面的onPath[src] = false和path.pop()就会被跳过</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> neighbor <span class="keyword">in</span> src.neighbors: <span class="comment"># 遍历邻接表</span></span><br><span class="line">        traverse(neighbor, dest) <span class="comment"># 递归遍历邻接节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 时间点2： 后序位置</span></span><br><span class="line">    path.pop() <span class="comment"># 撤销路径</span></span><br><span class="line">    onPath[src] = false <span class="comment"># 撤销路径上的节点为false</span></span><br></pre></td></tr></table></figure>
<p>他的搜索树为：</p>
<pre class="mermaid">graph TB
   0(("traverse( 0,  4)")) --> 1(("traverse( 1,  4)"))
   0(("traverse( 0,  4)")) --> 2(("traverse( 3,  4)"))
   1(("traverse( 1,  4)")) --> 3(("traverse( 2,  4)"))
   1(("traverse( 1,  4)")) --> 4(("traverse( 4,  4),OK!"))
    2(("traverse( 3,  4)")) --> 5(("traverse( 1,  4)"))
    2(("traverse( 3,  4)")) --> 6(("traverse( 4,  4),OK!"))
    3(("traverse( 2,  4)")) --> 7(("traverse( 3,  4)"))
    5(("traverse( 1,  4)")) --> 9(("traverse( 4,  4),OK!"))
    7(("traverse( 3,  4)")) --> 8(("traverse( 4,  4),OK!"))</pre>


<h5 id="同时使用onPath和visited数组"><a href="#同时使用onPath和visited数组" class="headerlink" title="同时使用onPath和visited数组"></a>同时使用onPath和visited数组</h5><p>在一些较为复杂的图的遍历中，需要同时使用<code>onPath</code>和<code>visited</code>数组来标记节点是否被访问过，<strong>用来减枝</strong>，降低复杂度。例如在后面的<a href="https://labuladong.online/algo/data-structure/topological-sort/">拓扑排序和成环检测中</a>我们需要同时使用<code>onPath</code>和<code>visited</code>数组来标记节点是否被访问过，<code>onPath</code>数组用来标记当前节点是否在路径上，<code>visited</code>数组用来标记当前节点是否被访问过。</p>
<h5 id="同时都不使用visited和onPath数组"><a href="#同时都不使用visited和onPath数组" class="headerlink" title="同时都不使用visited和onPath数组"></a>同时都不使用visited和onPath数组</h5><p>对于一些性质比较好的图，例如DAG(Directed Acyclic Graph)，我们可以不使用<code>visited</code>和<code>onPath</code>数组来标记节点是否被访问过，直接遍历即可,这事因为DAG的性质决定的，不会走回头路。如题目<a href="https://leetcode.cn/problems/all-paths-from-source-to-target/description/">Leetcode 797</a>所示，DAG的性质决定了不会走回头路，所以我们可以直接遍历即可。</p>
<h4 id="BFS遍历实现"><a href="#BFS遍历实现" class="headerlink" title="BFS遍历实现"></a>BFS遍历实现</h4><h5 id="写法1-不记录步数"><a href="#写法1-不记录步数" class="headerlink" title="写法1 不记录步数"></a>写法1 不记录步数</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bfs</span>(<span class="params">graph, src</span>):</span><br><span class="line">    queue = deque() <span class="comment"># 队列</span></span><br><span class="line">    visited = [<span class="literal">False</span>] * graph.size() <span class="comment"># 访问数组,也可以用set来实现</span></span><br><span class="line"></span><br><span class="line">    queue.append(src) <span class="comment"># 入队</span></span><br><span class="line">    visited[src] = <span class="literal">True</span> <span class="comment"># 标记节点为已访问</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> queue: <span class="comment"># 队列不为空</span></span><br><span class="line">        node = queue.popleft() <span class="comment"># 出队</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># do something with node, e.g. cout &lt;&lt; node.val &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> neighbor <span class="keyword">in</span> graph.neighbors(node): <span class="comment"># 遍历邻接表</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> visited[neighbor]: <span class="comment"># 如果节点没有被访问过</span></span><br><span class="line">                queue.append(neighbor) <span class="comment"># 入队</span></span><br><span class="line">                visited[neighbor] = <span class="literal">True</span> <span class="comment"># 标记节点为已访问</span></span><br></pre></td></tr></table></figure>


<h5 id="写法2-记录等长步数"><a href="#写法2-记录等长步数" class="headerlink" title="写法2 记录等长步数"></a>写法2 记录等长步数</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">bfs</span>(<span class="params">graph, src</span>):</span><br><span class="line">    queue = deque() <span class="comment"># 队列</span></span><br><span class="line">    visited = [<span class="literal">False</span>] * graph.size() <span class="comment"># 访问数组,也可以用set来实现</span></span><br><span class="line"></span><br><span class="line">    queue.append(src) <span class="comment"># 入队</span></span><br><span class="line">    visited[src] = <span class="literal">True</span> <span class="comment"># 标记节点为已访问</span></span><br><span class="line"></span><br><span class="line">    step = <span class="number">0</span> <span class="comment"># 步数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> queue: <span class="comment"># 队列不为空</span></span><br><span class="line">        sz = <span class="built_in">len</span>(queue) <span class="comment"># 队列长度</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(sz):</span><br><span class="line">            node = queue.popleft() <span class="comment"># 出队</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># do something with node and step</span></span><br><span class="line">            <span class="comment"># e.g. cout &lt;&lt; &quot;src-&gt;&quot; &lt;&lt; node.val &lt;&lt; &quot; step:&quot; &lt;&lt; step &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> neighbor <span class="keyword">in</span> graph.neighbors(node): <span class="comment"># 遍历邻接表</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> visited[neighbor]: <span class="comment"># 如果节点没有被访问过</span></span><br><span class="line">                    queue.append(neighbor) <span class="comment"># 入队</span></span><br><span class="line">                    visited[neighbor] = <span class="literal">True</span> <span class="comment"># 标记节点为已访问</span></span><br><span class="line">        step += <span class="number">1</span> <span class="comment"># 步数加1</span></span><br></pre></td></tr></table></figure>



<h5 id="写法3-记录变长步数"><a href="#写法3-记录变长步数" class="headerlink" title="写法3 记录变长步数"></a>写法3 记录变长步数</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">State</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, vertex, step</span>):</span><br><span class="line">        <span class="variable language_">self</span>.vertex = vertex <span class="comment"># 节点</span></span><br><span class="line">        <span class="variable language_">self</span>.step = step <span class="comment"># 步数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bfs</span>(<span class="params">graph, src</span>):</span><br><span class="line">    queue = deque() <span class="comment"># 队列</span></span><br><span class="line">    visited = [<span class="literal">False</span>] * graph.size() <span class="comment"># 访问数组,也可以用set来实现</span></span><br><span class="line"></span><br><span class="line">    queue.append(State(src, <span class="number">0</span>)) <span class="comment"># 入队</span></span><br><span class="line">    visited[src] = <span class="literal">True</span> <span class="comment"># 标记节点为已访问</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> queue: <span class="comment"># 队列不为空</span></span><br><span class="line">        state = queue.popleft() <span class="comment"># 出队</span></span><br><span class="line">        node = state.vertex <span class="comment"># 节点</span></span><br><span class="line">        step = state.step <span class="comment"># 步数</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># do something with node and step</span></span><br><span class="line">        <span class="comment"># e.g. cout &lt;&lt; &quot;src-&gt;&quot; &lt;&lt; node.val &lt;&lt; &quot; step:&quot; &lt;&lt; step &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> neighbor <span class="keyword">in</span> graph.neighbors(node): <span class="comment"># 遍历邻接表</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> visited[neighbor]: <span class="comment"># 如果节点没有被访问过</span></span><br><span class="line">                queue.append(State(neighbor, step + <span class="number">1</span>)) <span class="comment"># 入队</span></span><br><span class="line">                visited[neighbor] = <span class="literal">True</span> <span class="comment"># 标记节点为已访问</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>







<h3 id="Union-Find-并查集原理"><a href="#Union-Find-并查集原理" class="headerlink" title="Union Find 并查集原理"></a><a href="https://labuladong.online/algo/data-structure-basic/union-find-basic/">Union Find 并查集原理</a></h3><h4 id="Union-Find-并查集的核心原理"><a href="#Union-Find-并查集的核心原理" class="headerlink" title="Union Find 并查集的核心原理"></a>Union Find 并查集的核心原理</h4><p>对于如下的无向图，我们关心:</p>
<ul>
<li>有几个连通分量，i.e. 有几个岛屿,如下图有4个连通分量</li>
<li>判断两个节点是否在同一个连通分量中，e.g. <code>connected(0, 1)=true</code>，<code>connected(0, 4)=false</code></li>
<li>合并两个连通分量，e.g. <code>union(0,4)</code>合并之后<code>0-1-2-4-5-9</code>连成一个大岛屿</li>
</ul>
<p><img src="/../images/image-10.png" alt="alt text"></p>
<p>针对上述功能需求，并查集的API如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UF</span> &#123;</span><br><span class="line">    <span class="comment">// 初始化并查集，包含 n 个节点，时间复杂度 O(n)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UF</span><span class="params">(<span class="type">int</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接节点 p 和节点 q，时间复杂度 O(1)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">void</span> <span class="title">union</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询节点 p 和节点 q 是否连通（是否在同一个连通分量内），时间复杂度 O(1)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">bool</span> <span class="title">connected</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询当前的连通分量数量，时间复杂度 O(1)</span></span><br><span class="line">    <span class="comment">// 由于并查集没有deunion操作，所以count不可能增加，只可能减少</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">int</span> <span class="title">count</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如何实现上述功能呢？考虑到每一个分量都是一个树的结构：</p>
<ul>
<li><code>union</code>操作可以看成是将两棵树合并成一棵树，把一个树的root指向另一个树的root即可。</li>
<li><code>connected</code>操作可以看成是判断两个节点各自的root是否相同即可。</li>
<li><code>count</code>操作可以看成是统计有多少个root节点即可。</li>
</ul>
<h3 id="Union-Find-并查集的底层数据结构"><a href="#Union-Find-并查集的底层数据结构" class="headerlink" title="Union Find 并查集的底层数据结构"></a>Union Find 并查集的底层数据结构</h3><p><strong>核心：Union Ford中每一个分量都是一棵树的结构，每一个Union Ford就是一个树的集合，或者说是一个森林</strong> 上面的并查集的森林为：</p>
<p><img src="/../images/image-11.png" alt="alt text"></p>
<p>注意我们只关心每个节点的父节点，不关心每个节点的子节点，且<code>root.parent = root</code>。<strong>我们可以用一个数组来表征这个森林，定义这个数组为parent，且<code>parent[node]=node.parent</code>,则找<code>node.root = parent[parent[parent[....[node]]]]</code></strong> 且则上述的并查集森林可以表示为<code>parent = [1, 1, 1, 3, 4, 4, 6, 6, 7, 9]</code>。</p>
<h3 id="可视化并查集的实现及优化"><a href="#可视化并查集的实现及优化" class="headerlink" title="可视化并查集的实现及优化"></a>可视化并查集的实现及优化</h3><h4 id="未优化的版本"><a href="#未优化的版本" class="headerlink" title="未优化的版本"></a>未优化的版本</h4><p>最朴素的版本，咱也啥也不管，就规定<code>p.root = q.root</code>，即<code>p</code>的父节点指向<code>q</code>的父节点。这会导致<code>大树</code>的<code>root</code>指向<code>小树</code>的<code>root</code>，导致树的高度过高，查询的时间复杂度为O(N)，而不是O(logN)。如下图所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">p-&gt;0-&gt;1-&gt;2-&gt;3-&gt;4-&gt;5&lt;=&gt;6</span><br><span class="line">q-&gt;7</span><br></pre></td></tr></table></figure>
<h4 id="权重数组优化"><a href="#权重数组优化" class="headerlink" title="权重数组优化"></a>权重数组优化</h4><p>我们可以维护一个权重数组<code>size</code>，用来记录每个节点的权重，<code>size[node]</code>表示以<code>node</code>为根节点的树的大小。我们在合并的时候，将小树的根节点指向大树的根节点，这样可以保证树的高度不会过高。但这种方法还是达不到O(1)的时间复杂度，无法满足前面API的要求。</p>
<h4 id="路径压缩优化的版本"><a href="#路径压缩优化的版本" class="headerlink" title="路径压缩优化的版本"></a>路径压缩优化的版本</h4><p>对于Union Find的<code>find</code>操作，i.e. 查找root的操作，朴素的为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UnionFind</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, n</span>):</span><br><span class="line">        <span class="variable language_">self</span>.parent = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)] <span class="comment"># 初始化parent数组</span></span><br><span class="line">        <span class="variable language_">self</span>.size = [<span class="number">1</span>] * n <span class="comment"># 初始化size数组</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># ... 其余方法</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">find</span>(<span class="params">self, p</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.parent[p] != p: <span class="comment"># 如果p不是根节点</span></span><br><span class="line">            p = <span class="variable language_">self</span>.parent[p]</span><br><span class="line">        <span class="keyword">return</span> p</span><br></pre></td></tr></table></figure>

<p>对于<code>find</code>操作，我们可以采用路径压缩的方法来优化。<strong>路径压缩的核心思想是将每个节点的父节点指向根节点</strong>，这样可以大大减少树的高度，使树高度趋近于1。路径压缩的实现如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UnionFind</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, n</span>):</span><br><span class="line">        <span class="variable language_">self</span>.parent = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)] <span class="comment"># 初始化parent数组</span></span><br><span class="line">        <span class="variable language_">self</span>.size = [<span class="number">1</span>] * n <span class="comment"># 初始化size数组</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># ... 其余方法</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">find</span>(<span class="params">self, p</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.parent[p] != p:</span><br><span class="line">            <span class="comment"># 路径压缩的核心思想是将每个节点的父节点&#123;self.parent[p]&#125;指向根节点&#123;self.find(self.parent[p])&#125;   </span></span><br><span class="line">            <span class="variable language_">self</span>.parent[p] = <span class="variable language_">self</span>.find(<span class="variable language_">self</span>.parent[p]) </span><br><span class="line">            p = <span class="variable language_">self</span>.parent[p] </span><br><span class="line">        <span class="keyword">return</span> p</span><br></pre></td></tr></table></figure>


<h2 id="十大排序算法原理及可视化"><a href="#十大排序算法原理及可视化" class="headerlink" title="十大排序算法原理及可视化"></a><a href="https://labuladong.online/algo/menu/sorting/">十大排序算法原理及可视化</a></h2><h3 id="本章导读"><a href="#本章导读" class="headerlink" title="本章导读"></a><a href="https://labuladong.online/algo/intro/sorting/">本章导读</a></h3><p>虽然很少有面试和算法题会考排序算法，但是排序算法是数据结构和算法的基础，很多数据结构和算法都是基于排序算法的，所以还是要了解一下排序算法的原理和实现。首先最重要的是，了解内置排序算法的调用。</p>
<p>C++ STL的sort函数是基于std::sort 不采用单一固定算法，而是根据不同的数据规模和类型选择混合排序策略，通常结合了快速排序（Quicksort）、堆排序（Heapsort）和插入排序（Insertion Sort）。</p>
<ul>
<li>默认情况下，std::sort使用快速排序算法，平均时间复杂度为O(NlogN)，最坏时间复杂度为O(N^2)，空间复杂度为O(logN)，不稳定。</li>
<li>当数据规模较小时，std::sort会切换到插入排序算法，平均时间复杂度为O(N^2)，最坏时间复杂度为O(N^2)，空间复杂度为O(1)，稳定。</li>
<li>当数据规模较大时，std::sort会切换到堆排序算法，平均时间复杂度为O(NlogN)，最坏时间复杂度为O(NlogN)，空间复杂度为O(1)，不稳定。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C++ STL的sort函数</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 排序vector&lt;int&gt; nums</span></span><br><span class="line">std::<span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>()); <span class="comment">// 升序排序</span></span><br><span class="line">std::<span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), std::<span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;()); <span class="comment">// 降序排序</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 排序list&lt;int&gt; nums</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::list&lt;<span class="type">int</span>&gt; nums = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">nums.<span class="built_in">sort</span>(); <span class="comment">// 升序排序</span></span><br><span class="line">nums.<span class="built_in">sort</span>(std::<span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;()); <span class="comment">// 降序排序</span></span><br></pre></td></tr></table></figure>


<p>Python的内置排序函数是timsort，时间复杂度为O(NlogN)，空间复杂度为O(N)，稳定。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># sort() 与 sorted() 的区别</span></span><br><span class="line"><span class="comment"># sort() 是list对象的方法，sorted() 是内置函数</span></span><br><span class="line"><span class="comment"># sort() 会修改原列表，sorted() 不会修改原列表，返回一个新的列表</span></span><br><span class="line"><span class="comment"># sort() 只能用于list，sorted() 可以用于任何可迭代对象</span></span><br><span class="line"></span><br><span class="line">arr = [<span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">arr.sort() <span class="comment"># 升序排序</span></span><br><span class="line">arr.sort(reverse=<span class="literal">True</span>) <span class="comment"># 降序排序</span></span><br><span class="line"></span><br><span class="line">_ = <span class="built_in">sorted</span>(arr) <span class="comment"># 升序排序</span></span><br></pre></td></tr></table></figure>

<h3 id="排序算法的关键指标"><a href="#排序算法的关键指标" class="headerlink" title="排序算法的关键指标"></a><a href="https://labuladong.online/algo/data-structure-basic/sort-basic/">排序算法的关键指标</a></h3><p>时间复杂度、空间复杂度自不必说了，稳定性也是排序算法的一个重要指标。稳定性是指在排序过程中，如果两个元素相等，它们在排序后的相对位置不变，则称该排序算法是稳定的。为什么要考虑稳定性呢？例如：已经按照Date升序排列的用户数据，假设我们要按照UserID升序排列，如果排序算法不稳定，则可能会导致Date相同的用户的相对位置发生变化，这样就会导致数据的混乱。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   Date    UserID</span><br><span class="line">2020-01-01  9999</span><br><span class="line">2020-01-02  9999</span><br><span class="line">2020-01-03  9999</span><br><span class="line">2020-02-01  1001</span><br><span class="line">2020-02-02  1001</span><br><span class="line">2020-02-03  1001</span><br></pre></td></tr></table></figure>


<p>对如下10种排序算法，就时间复杂度、空间复杂度、稳定性、适用场景、局限性、核心思想等进行总结：</p>
<table>
<thead>
<tr>
<th>排序算法</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
<th>稳定性</th>
<th>适用场景</th>
<th>局限性</th>
<th>核心思想</th>
<th>是否原地排序</th>
</tr>
</thead>
<tbody><tr>
<td>选择排序</td>
<td>todo</td>
<td>todo</td>
<td>todo</td>
<td>todo</td>
<td>todo</td>
<td>todo</td>
<td>todo</td>
</tr>
<tr>
<td>冒泡排序</td>
<td>todo</td>
<td>todo</td>
<td>todo</td>
<td>todo</td>
<td>todo</td>
<td>todo</td>
<td>todo</td>
</tr>
<tr>
<td>插入排序</td>
<td>todo</td>
<td>todo</td>
<td>todo</td>
<td>todo</td>
<td>todo</td>
<td>todo</td>
<td>todo</td>
</tr>
<tr>
<td>希尔排序</td>
<td>todo</td>
<td>todo</td>
<td>todo</td>
<td>todo</td>
<td>todo</td>
<td>todo</td>
<td>todo</td>
</tr>
<tr>
<td>快速排序</td>
<td>todo</td>
<td>todo</td>
<td>todo</td>
<td>todo</td>
<td>todo</td>
<td>todo</td>
<td>todo</td>
</tr>
<tr>
<td>归并排序</td>
<td>todo</td>
<td>todo</td>
<td>todo</td>
<td>todo</td>
<td>todo</td>
<td>todo</td>
<td>todo</td>
</tr>
<tr>
<td>堆排序</td>
<td>todo</td>
<td>todo</td>
<td>todo</td>
<td>todo</td>
<td>todo</td>
<td>todo</td>
<td>todo</td>
</tr>
<tr>
<td>计数排序</td>
<td>todo</td>
<td>todo</td>
<td>todo</td>
<td>todo</td>
<td>todo</td>
<td>todo</td>
<td>todo</td>
</tr>
<tr>
<td>桶排序</td>
<td>todo</td>
<td>todo</td>
<td>todo</td>
<td>todo</td>
<td>todo</td>
<td>todo</td>
<td>todo</td>
</tr>
<tr>
<td>基数排序</td>
<td>todo</td>
<td>todo</td>
<td>todo</td>
<td>todo</td>
<td>todo</td>
<td>todo</td>
<td>todo</td>
</tr>
</tbody></table>
<h3 id="选择排序所面临的问题"><a href="#选择排序所面临的问题" class="headerlink" title="选择排序所面临的问题"></a><a href="https://labuladong.online/algo/data-structure-basic/select-sort/">选择排序所面临的问题</a></h3><p>todo</p>
<h3 id="拥有稳定性：冒泡排序"><a href="#拥有稳定性：冒泡排序" class="headerlink" title="拥有稳定性：冒泡排序"></a><a href="https://labuladong.online/algo/data-structure-basic/bubble-sort/">拥有稳定性：冒泡排序</a></h3><p>todo</p>
<h3 id="运用逆向思维：插入排序"><a href="#运用逆向思维：插入排序" class="headerlink" title="运用逆向思维：插入排序"></a><a href="https://labuladong.online/algo/data-structure-basic/insertion-sort/">运用逆向思维：插入排序</a></h3><p>todo</p>
<h3 id="突破-O-N-2-：希尔排序"><a href="#突破-O-N-2-：希尔排序" class="headerlink" title="突破 O(N^2)：希尔排序"></a><a href="https://labuladong.online/algo/data-structure-basic/shell-sort/">突破 O(N^2)：希尔排序</a></h3><p>todo</p>
<h3 id="妙用二叉树前序位置：快速排序"><a href="#妙用二叉树前序位置：快速排序" class="headerlink" title="妙用二叉树前序位置：快速排序"></a><a href="https://labuladong.online/algo/data-structure-basic/quick-sort/">妙用二叉树前序位置：快速排序</a></h3><p>todo</p>
<h3 id="妙用二叉树后序位置：归并排序"><a href="#妙用二叉树后序位置：归并排序" class="headerlink" title="妙用二叉树后序位置：归并排序"></a><a href="https://labuladong.online/algo/data-structure-basic/merge-sort/">妙用二叉树后序位置：归并排序</a></h3><p>todo</p>
<h3 id="二叉堆结构的运用：堆排序"><a href="#二叉堆结构的运用：堆排序" class="headerlink" title="二叉堆结构的运用：堆排序"></a><a href="https://labuladong.online/algo/data-structure-basic/heap-sort/">二叉堆结构的运用：堆排序</a></h3><p>todo</p>
<h3 id="全新的排序原理：计数排序"><a href="#全新的排序原理：计数排序" class="headerlink" title="全新的排序原理：计数排序"></a><a href="https://labuladong.online/algo/data-structure-basic/counting-sort/">全新的排序原理：计数排序</a></h3><p>todo</p>
<h3 id="博采众长：桶排序"><a href="#博采众长：桶排序" class="headerlink" title="博采众长：桶排序"></a><a href="https://labuladong.online/algo/data-structure-basic/bucket-sort/">博采众长：桶排序</a></h3><p>todo</p>
<h3 id="基数排序（Radix-Sort）"><a href="#基数排序（Radix-Sort）" class="headerlink" title="基数排序（Radix Sort）"></a><a href="https://labuladong.online/algo/data-structure-basic/radix-sort/">基数排序（Radix Sort）</a></h3><p>todo</p>
]]></content>
      <categories>
        <category>labuladong算法笔记</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>排序算法</tag>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>labuladong-第零章-核心刷题框架汇总</title>
    <url>/2025/04/23/labuladong-%E7%AC%AC%E9%9B%B6%E7%AB%A0-%E6%A0%B8%E5%BF%83%E5%88%B7%E9%A2%98%E6%A1%86%E6%9E%B6%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<h1 id="第零章、核心刷题框架汇总"><a href="#第零章、核心刷题框架汇总" class="headerlink" title="第零章、核心刷题框架汇总"></a><a href="https://labuladong.online/algo/menu/core/">第零章、核心刷题框架汇总</a></h1><h2 id="本章导读"><a href="#本章导读" class="headerlink" title="本章导读"></a><a href="https://labuladong.online/algo/intro/core-intro/">本章导读</a></h2><h2 id="学习数据结构和算法的框架思维"><a href="#学习数据结构和算法的框架思维" class="headerlink" title="学习数据结构和算法的框架思维"></a><a href="https://labuladong.online/algo/essential-technique/algorithm-summary/">学习数据结构和算法的框架思维</a></h2><blockquote>
<p>这一部分不要dfs,后面刷够题了，回顾再看。大概说了几个观点，但是目前感触不是很深，可能是做的题目太少了。</p>
<ul>
<li>观点1：种种数据结构，皆为数组（顺序存储）和链表（链式存储）的变换。</li>
<li>观点2：数据结构的关键点在于遍历和访问，即增删查改等基本操作。</li>
<li>观点3：种种算法，皆为穷举。穷举的关键点在于无遗漏和无冗余。<ul>
<li>熟练掌握算法框架，可以做到无遗漏</li>
<li>充分利用信息，可以做到无冗余。</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="双指针技巧秒杀七道链表题目"><a href="#双指针技巧秒杀七道链表题目" class="headerlink" title="双指针技巧秒杀七道链表题目"></a><a href="https://labuladong.online/algo/essential-technique/linked-list-skills-summary/">双指针技巧秒杀七道链表题目</a></h2><ul>
<li><p><a href="https://leetcode.cn/problems/merge-two-sorted-lists/">Leetcode 21</a> 合并两个有序链表<br>当你需要创造一条新链表的时候，可以使用虚拟头结点简化边界情况的处理。比如说，让你把两条有序链表合并成一条新的有序链表，是不是要创造一条新链表？再比你想把一条链表分解成两条链表，是不是也在创造新链表？这些情况都可以使用虚拟头结点简化边界情况的处理。</p>
</li>
<li><p><a href="https://leetcode.cn/problems/partition-list/description/">Leetcode 86</a> 分隔链表<br>同样是要创造一条新链表，使用虚拟头结点简化边界情况的处理。同时，遍历给定链表的时候需要注意搞一个<code>tmp</code>把节点从原链表中摘下来。如果不这么搞会TLE，会成环，遍历不完。</p>
</li>
<li><p><a href="https://leetcode.cn/problems/merge-k-sorted-lists/">Leetcode 23*</a> 合并K个升序链表<br>注意优先队列在python中的调用：</p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line">lls = [list1, list2, list3, ...] <span class="comment"># K个链表组成的动态数组</span></span><br><span class="line">heap = [ (l.val,,idx,l) <span class="keyword">for</span> l,idx <span class="keyword">in</span> <span class="built_in">enumerate</span>(lls) <span class="keyword">if</span> ll ] <span class="comment"># 只把非空链表入队</span></span><br><span class="line">heapq.heapify(heap) <span class="comment"># 堆化,先比较val,再比较idx,最后比较l，</span></span><br><span class="line"><span class="comment"># l的比较没实现，需要重载__lt__方法,但是Leetcode不支持，所以直接用idx来比较</span></span><br></pre></td></tr></table></figure>

<p>  在C++中</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;ListNode*&gt; lists; <span class="comment">// K个链表组成的动态数组</span></span><br><span class="line"><span class="keyword">auto</span> cmp = [](ListNode* a, ListNode* b) &#123; <span class="keyword">return</span> a-&gt;val &gt; b-&gt;val; &#125;;</span><br><span class="line">priority_queue&lt;ListNode*, vector&lt;ListNode*&gt;, <span class="keyword">decltype</span>(cmp)&gt; <span class="built_in">pq</span>(cmp);</span><br><span class="line"><span class="comment">// C++中默认是大顶堆，所以提供一个比较函数cmp来实现小顶堆</span></span><br><span class="line"><span class="comment">// 这里cmp是一个lambda表达式，比较两个ListNode的val大小</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><a href="https://leetcode.cn/problems/kth-node-from-end-of-list-lcci/description/">链表中倒数第k个节点</a><br>快慢指针的应用，快指针先走k步，然后快慢指针一起走，直到快指针走到链表尾部，慢指针就是倒数第k个节点。</p>
</li>
<li><p><a href="https://leetcode.cn/problems/middle-of-the-linked-list/">Leetcode 876</a> 链表的中间结点<br>快慢指针，快的指针走两步，慢的指针走一步，快指针到达链表尾部的时候，慢指针就是链表的中间节点。框架如下：</p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> fast <span class="keyword">and</span> fast.<span class="built_in">next</span>:</span><br><span class="line">    slow = slow.<span class="built_in">next</span></span><br><span class="line">    fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>

</li>
<li><p><a href="https://leetcode.cn/problems/linked-list-cycle/">Leetcode 141</a> 环形链表<br>判断链表是否有环，快慢指针，快的指针走两步，慢的指针走一步，如果有环，快指针和慢指针会相遇。如果 fast 走着走着竟然和 slow 相遇了，那肯定是 fast 在链表中转圈了，说明链表中含有环。</p>
</li>
<li><p><a href="https://leetcode.cn/problems/linked-list-cycle-ii/">Leetcode 142*</a> 环形链表 II<br>最简单的过法就是用hash表，但是这样的空间复杂度就不为O(1)了。<strong>但是快慢指针向撞的位置不是入环的节点</strong><br><img src="/../images/image-12.png" alt="alt text"><br>在slow走了k步之后，fast也走了2k步子，两个相撞了，相撞点到入环点的距离为m，fast和slow距离head的距离为k，距离入环点的距离为m，这个时候把slow放在head上，两个一起走。两个再次相撞的时候，slow就是入环的节点。</p>
</li>
<li><p><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists/">Leetcode 160*</a> 相交链表<br>最简单的过法就是用hash表，但是这样的空间复杂度就不为O(1)了。维护p,q。p遍历A-B，q遍历B-A。p和q都走完了链表A和链表B，p和q相遇的地方就是相交的节点,如果没有相交点，两个指针会同时到达链表尾部，返回null。<br><img src="/../images/image-13.png" alt="alt text"></p>
</li>
</ul>
<h2 id="双指针技巧秒杀七道数组题目"><a href="#双指针技巧秒杀七道数组题目" class="headerlink" title="双指针技巧秒杀七道数组题目"></a><a href="https://labuladong.online/algo/essential-technique/array-two-pointers-summary/">双指针技巧秒杀七道数组题目</a></h2><blockquote>
<p>左右指针:就是两个指针相向而行或者<strong>相背而行</strong><br>快慢指针，就是两个指针<strong>同向而行</strong>，一快一慢（两个的方向是一样的）<br>对于数组问题，再具体点总结：</p>
<ul>
<li>求满足条件的子数组，一般是前缀和、滑动窗口，经常结合哈希表；</li>
<li>区间操作元素，一般是前缀和、差分数组、线段树；</li>
<li>数组有序，主要是双指针技巧，更大概率会用到二分搜索。</li>
</ul>
</blockquote>
<h3 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h3><h4 id="原地修改"><a href="#原地修改" class="headerlink" title="原地修改"></a>原地修改</h4><blockquote>
<p>快慢指针的指针的初始化一般是<code>slow=0, fast=0</code>，然后根据题目的要求来移动指针。</p>
</blockquote>
<ul>
<li><p><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array/">Leetcode 26*</a> 删除排序数组中的重复项<br>不是真删除啊，真删除搞不到O(1)的空间复杂度。只要把不重复的元素放在前面就行了，返回长度就行了，这个和下面的<a href="https://leetcode.cn/problems/remove-element/">Leetcode 27*</a>是一样的。我们维护快慢指针，其中<code>nums[0,1,..slow)</code>是没有重复的元素。由于<code>nums</code>是有序的，所以只要<code>nums[slow] != nums[fast]</code>，就把<code>nums[fast]</code>放到<code>nums[slow]</code>上，然后<code>slow++</code>。最后返回<code>slow</code>就行了。</p>
</li>
<li><p><a href="https://leetcode.cn/problems/remove-element/">Leetcode 27*</a> 移除元素<br>和上面类似</p>
</li>
</ul>
<h4 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 滑动窗口算法框架伪码</span></span><br><span class="line"><span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (right &lt; nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">    <span class="comment">// 增大窗口</span></span><br><span class="line">    window.<span class="built_in">addLast</span>(nums[right]);</span><br><span class="line">    right++;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (window needs shrink) &#123;</span><br><span class="line">        <span class="comment">// 缩小窗口</span></span><br><span class="line">        window.<span class="built_in">removeFirst</span>(nums[left]);</span><br><span class="line">        left++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请查看下文档的<a href="##%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%AE%97%E6%B3%95%E6%A0%B8%E5%BF%83%E4%BB%A3%E7%A0%81%E6%A8%A1%E6%9D%BF">滑动窗口算法核心代码模板</a>。</p>
<h3 id="左右指针"><a href="#左右指针" class="headerlink" title="左右指针"></a>左右指针</h3><blockquote>
<p>左右指针的初始化一般是<code>left=0, right=nums.size()-1</code>，然后根据题目的要求来移动指针。</p>
</blockquote>
<h4 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h4><p>对于有序的数组，我们可以使用二分查找来快速定位目标元素的位置。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">binarySearch</span>(<span class="params">nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="comment"># 一左一右两个指针相向而行</span></span><br><span class="line">    left, right = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">        mid = (right + left) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        <span class="keyword">elif</span> nums[mid] &lt; target:</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> nums[mid] &gt; target:</span><br><span class="line">            right = mid - <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>


<h4 id="n数之和"><a href="#n数之和" class="headerlink" title="n数之和"></a>n数之和</h4><ul>
<li><a href="https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/">Leetcode 167*</a> 两数之和 II - 输入有序数组<br>只要数组有序，就应该想到双指针技巧。通过调节 left 和 right 就可以调整 nums[left] + nums[right] 的值。将left&#x3D;0,right&#x3D;nums.size()-1，nums[left] + nums[right] &lt; target，说明left指针需要向右移动，nums[left] + nums[right] &gt; target，说明right指针需要向左移动。</li>
</ul>
<h4 id="原地反转"><a href="#原地反转" class="headerlink" title="原地反转"></a>原地反转</h4><ul>
<li><a href="https://leetcode.cn/problems/reverse-string/">Leetcode 344</a> 反转字符串<br>L，R两个指针分别指向字符串的首尾，L++，R–，交换L和R指向的字符。</li>
</ul>
<h4 id="回文串判断"><a href="#回文串判断" class="headerlink" title="回文串判断"></a>回文串判断</h4><ul>
<li><a href="https://leetcode.cn/problems/longest-palindromic-substring/">Leetcode 5*</a> 最长回文子串<br>首先，最简单的判断一个字符串是不是回文串的方法就是用双指针</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">isPalindrome</span>(<span class="params">s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">    left, right = <span class="number">0</span>, <span class="built_in">len</span>(s) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> left &lt; right:</span><br><span class="line">        <span class="keyword">if</span> s[left] != s[right]:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        left += <span class="number">1</span></span><br><span class="line">        right -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p>对于这个题目，我们需要查找最长的回文子串。我们可以使用中心扩展法来解决这个问题。对于每一个字符，我们都可以将它作为回文串的中心，然后向两边扩展，直到不能扩展为止。我们需要考虑两种情况：</p>
<ul>
<li>奇数长度的回文串，中心是一个字符，比如<code>aba</code>，<code>a</code>就是中心。</li>
<li>偶数长度的回文串，中心是两个字符，比如<code>abba</code>，<code>ab</code>就是中心。</li>
</ul>
<p>针对这个特殊需求，我们重新设置一个基于左右指针的判断是不是回文串的函数<code>expandAroundCenter</code>，然后在主函数中遍历每一个字符，调用这个函数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">expandAroundCenter</span>(<span class="params">s: <span class="built_in">str</span>, left: <span class="built_in">int</span>, right: <span class="built_in">int</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">    <span class="keyword">while</span> left &gt;= <span class="number">0</span> <span class="keyword">and</span> right &lt; <span class="built_in">len</span>(s) <span class="keyword">and</span> s[left] == s[right]:</span><br><span class="line">        left -= <span class="number">1</span></span><br><span class="line">        right += <span class="number">1</span></span><br><span class="line">    <span class="comment"># 此时：left &lt; 0 or right = len(s) or s[left] != s[right]</span></span><br><span class="line">    <span class="keyword">return</span> s[left + <span class="number">1</span>:right]</span><br></pre></td></tr></table></figure>
<h2 id="滑动窗口算法核心代码模板"><a href="#滑动窗口算法核心代码模板" class="headerlink" title="滑动窗口算法核心代码模板"></a><a href="https://labuladong.online/algo/essential-technique/sliding-window-framework/">滑动窗口算法核心代码模板</a></h2><p>滑动窗口可以归为快慢双指针，一快一慢两个指针前后相随，中间的部分就是窗口。滑动窗口算法技巧主要用来解决子数组问题，比如让你寻找符合某个条件的最长&#x2F;最短子数组。 如果没有滑动窗口，最为简单的办法就是暴力破解，O(N^2)的时间复杂度。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> l <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">    <span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(l, <span class="built_in">len</span>(nums)):</span><br><span class="line">        <span class="comment"># 处理 nums[l:r+1] 这个子数组</span></span><br><span class="line">        <span class="keyword">if</span> check(nums[l:r+<span class="number">1</span>]):</span><br><span class="line">            <span class="comment"># 满足条件，做一些操作</span></span><br></pre></td></tr></table></figure>

<p>而滑动窗口的可以做到O(N)的时间复杂度, 之所以是两层while循环还是复杂度为O(N)，是因为每个指针不会回退。<strong>如下的框架并没有枚举所有的子数组，滑动窗口做到了合理的剪枝。这个方法有点像，先找个可行解，再在可行解上优化</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 滑动窗口算法伪码框架</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">slidingWindow</span>(<span class="params">s: <span class="built_in">str</span></span>):</span><br><span class="line">    <span class="comment"># 用合适的数据结构记录窗口中的数据，根据具体场景变通</span></span><br><span class="line">    <span class="comment"># 比如说，我想记录窗口中元素出现的次数，就用 map</span></span><br><span class="line">    <span class="comment"># 如果我想记录窗口中的元素和，就可以只用一个 int</span></span><br><span class="line">    window = ...</span><br><span class="line"></span><br><span class="line">    left, right = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> right &lt; <span class="built_in">len</span>(s):</span><br><span class="line">        <span class="comment"># c 是将移入窗口的字符</span></span><br><span class="line">        c = s[right]</span><br><span class="line">        window.add(c)</span><br><span class="line">        <span class="comment"># 增大窗口</span></span><br><span class="line">        right += <span class="number">1</span></span><br><span class="line">        <span class="comment"># 进行窗口内数据的一系列更新</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Your code here 1</span></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="comment"># *** debug 输出的位置 ***</span></span><br><span class="line">        <span class="comment"># 注意在最终的解法代码中不要 print</span></span><br><span class="line">        <span class="comment"># 因为 IO 操作很耗时，可能导致超时</span></span><br><span class="line">        <span class="comment"># print(f&quot;window: [&#123;left&#125;, &#123;right&#125;)&quot;)</span></span><br><span class="line">        <span class="comment"># ***********************</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 判断左侧窗口是否要收缩</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> window needs shrink:</span><br><span class="line">            <span class="comment"># d 是将移出窗口的字符</span></span><br><span class="line">            d = s[left]</span><br><span class="line">            window.remove(d)</span><br><span class="line">            <span class="comment"># 缩小窗口</span></span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 进行窗口内数据的一系列更新</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment"># Your code here 2</span></span><br><span class="line">            ...</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Your code here 3</span></span><br><span class="line">        ...</span><br></pre></td></tr></table></figure>
<p>上述三处<code>Your code here</code>的地方是需要根据题目的要求来进行修改的。回顾一下，遇到子数组&#x2F;子串相关的问题，你只要能回答出来以下几个问题，就能运用滑动窗口算法：</p>
<ul>
<li>1、什么时候应该扩大窗口？</li>
<li>2、什么时候应该缩小窗口？</li>
<li>3、什么时候应该更新答案？</li>
</ul>
<h3 id="最小覆盖字串"><a href="#最小覆盖字串" class="headerlink" title="最小覆盖字串"></a>最小覆盖字串</h3><ul>
<li><a href="https://leetcode.cn/problems/minimum-window-substring/">Leetcode 76*</a> 最小覆盖子串<br>需要有<code>need</code>和<code>window</code>两个<code>Counter</code>，<code>need</code>用来记录需要的字符和数量，<code>window</code>用来记录当前窗口中的字符和数量。在<code>your code here 2</code>的地方，一定满足覆盖，在这里判断当前的窗口是不是最小。</li>
</ul>
<h3 id="字符串排列"><a href="#字符串排列" class="headerlink" title="字符串排列"></a>字符串排列</h3><ul>
<li><a href="https://leetcode.cn/problems/permutation-in-string/">Leetcode 567*</a> 字符串的排列<br>这个是简化版本的滑动窗口，窗口的大小是固定的，等于<code>p</code>的长度。</li>
</ul>
<h3 id="找所有字母异位词"><a href="#找所有字母异位词" class="headerlink" title="找所有字母异位词"></a>找所有字母异位词</h3><ul>
<li><a href="https://leetcode.cn/problems/find-all-anagrams-in-a-string/">Leetcode 438</a> 找到字符串中所有字母异位词<br>和<a href="https://leetcode.cn/problems/permutation-in-string/">Leetcode 567*</a> 本质上一样，但是这个需要有个list把所有的结果存起来。</li>
</ul>
<h3 id="最长重复字符"><a href="#最长重复字符" class="headerlink" title="最长重复字符"></a>最长重复字符</h3><ul>
<li><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">Leetcode 3*</a> 无重复字符的最长子串<br>在<code>your code here 3</code>的地方，判断当前窗口是不是最优解。</li>
</ul>
<h2 id="一个视角-两种思维模式搞定递归"><a href="#一个视角-两种思维模式搞定递归" class="headerlink" title="一个视角 + 两种思维模式搞定递归"></a><a href="https://labuladong.online/algo/essential-technique/understand-recursion/">一个视角 + 两种思维模式搞定递归</a></h2><h3 id="一个视角"><a href="#一个视角" class="headerlink" title="一个视角"></a>一个视角</h3><p>**任何递归都可以从树的角度来看，**算法的本质是穷举，递归是一种重要的穷举手段，递归的正确理解方法是从「树」的角度理解。</p>
<h3 id="两种思维"><a href="#两种思维" class="headerlink" title="两种思维"></a>两种思维</h3><h4 id="分解问题的思维"><a href="#分解问题的思维" class="headerlink" title="分解问题的思维"></a>分解问题的思维</h4><blockquote>
<p>如果你想用「分解问题」的思维模式来写递归算法，那么这个递归函数一定要有一个清晰的定义，说明这个函数参数的含义是什么，返回什么结果。</p>
</blockquote>
<p>例如：对于斐波那契数列的求解，递归函数的定义就是：输入一个非负整数 n，返回斐波那契数列中的第 n 个数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> fib(<span class="built_in">int</span> n) &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">    // 利用定义，计算前两个斐波那契数（子问题）</span><br><span class="line">    <span class="built_in">int</span> fib_n_1 = fib(n - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">int</span> fib_n_2 = fib(n - <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    // 通过子问题的解，计算原问题的解</span><br><span class="line">    <span class="keyword">return</span> fib_n_1 + fib_n_2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例如：对于求一个树的最大深度，递归函数的定义就是：输入一个树的根节点，返回这个树的最大深度。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> max_depth(TreeNode* root) &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == nullptr) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    // 计算子树的最大深度</span><br><span class="line">    <span class="built_in">int</span> left_depth = max_depth(root.left);</span><br><span class="line">    <span class="built_in">int</span> right_depth = max_depth(root.right);</span><br><span class="line"></span><br><span class="line">    // 通过子问题的解，计算原问题的解</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(left_depth, right_depth) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="遍历的思维"><a href="#遍历的思维" class="headerlink" title="遍历的思维"></a>遍历的思维</h4><blockquote>
<p>如果你想用「遍历」的思维模式来写递归算法，那么你需要一个无返回值的遍历函数，在遍历的过程中收集结果。</p>
</blockquote>
<p>例如：对于全排列问题, 本质上就是一个多叉树的遍历问题。我们可以使用一个无返回值的递归函数来遍历这个多叉树，在遍历的过程中收集结果。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">permute</span>(<span class="params">nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">    res = []</span><br><span class="line">    track = []</span><br><span class="line">    used = [<span class="literal">False</span>] * <span class="built_in">len</span>(nums)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backtrack</span>():</span><br><span class="line">        <span class="comment"># 终止条件</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(track) == <span class="built_in">len</span>(nums):</span><br><span class="line">            res.append(track[:])</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="comment"># 排除不合法的选择</span></span><br><span class="line">            <span class="keyword">if</span> used[i]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 做选择</span></span><br><span class="line">            track.append(nums[i])</span><br><span class="line">            used[i] = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 进入下一层决策树</span></span><br><span class="line">            backtrack()</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 撤销选择</span></span><br><span class="line">            track.pop()</span><br><span class="line">            used[i] = <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line">    backtrack(nums, res, track, used)</span><br></pre></td></tr></table></figure>


<p>例如，同样的对于求一个树的最大深度，我们可以使用一个无返回值的递归函数来遍历这个树，在遍历的过程中收集结果。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">max_depth</span>(<span class="params">root: TreeNode</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    depth = <span class="number">0</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">travel</span>(<span class="params">node: TreeNode</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 前序遍历位置（进入节点）增加深度</span></span><br><span class="line">        depth += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 遍历到叶子节点时记录最大深度</span></span><br><span class="line">        <span class="keyword">if</span> node.left <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> node.right <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            res = <span class="built_in">max</span>(res, depth)</span><br><span class="line"></span><br><span class="line">        travel(node.left, depth + <span class="number">1</span>)</span><br><span class="line">        travel(node.right, depth + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 后序遍历位置（离开节点）减少深度</span></span><br><span class="line">        depth -= <span class="number">1</span></span><br></pre></td></tr></table></figure>









<h2 id="动态规划解题套路框架"><a href="#动态规划解题套路框架" class="headerlink" title="动态规划解题套路框架"></a><a href="https://labuladong.online/algo/essential-technique/dynamic-programming-framework/">动态规划解题套路框架</a></h2><blockquote>
<p>动态规划问题的一般形式就是求最值，求方案数量</p>
</blockquote>
<ul>
<li>只有列出正确的「<strong>状态转移方程</strong>」，才能正确地穷举</li>
<li>而且，你需要判断算法问题是否具备「<strong>最优子结构</strong>」，是否能够通过子问题的最值得到原问题的最值<ul>
<li><em>要符合「最优子结构」，子问题间必须互相独立。啥叫相互独立？你肯定不想看数学证明，我用一个直观的例子来讲解。比如说，假设你考试，每门科目的成绩都是互相独立的。你的原问题是考出最高的总成绩，那么你的子问题就是要把语文考到最高，数学考到最高…… 为了每门课考到最高，你要把每门课相应的选择题分数拿到最高，填空题分数拿到最高…… 当然，最终就是你每门课都是满分，这就是最高的总成绩。得到了正确的结果：最高的总成绩就是总分。因为这个过程符合最优子结构，「每门科目考到最高」这些子问题是互相独立，互不干扰的。但是，如果加一个条件：你的语文成绩和数学成绩会互相制约，不能同时达到满分，数学分数高，语文分数就会降低，反之亦然。这样的话，显然你能考到的最高总成绩就达不到总分了，按刚才那个思路就会得到错误的结果。因为「每门科目考到最高」的子问题并不独立，语文数学成绩户互相影响，无法同时最优，所以最优子结构被破坏。</em></li>
</ul>
</li>
<li>动态规划问题存在「<strong>重叠子问题</strong>」，如果暴力穷举的话效率会很低，<strong>所以需要你使用「memo」或者「DP table」来优化穷举过程，避免不必要的计算</strong></li>
</ul>
<p>其一般的流程为：</p>
<ul>
<li><ol>
<li>明确「状态」</li>
</ol>
</li>
<li><ol start="2">
<li>明确「选择」</li>
</ol>
</li>
<li><ol start="3">
<li>定义 dp 数组&#x2F;函数的含义</li>
</ol>
</li>
</ul>
<p>动态规划的问题，按照笨蛋到聪明的顺序，可以有如下几种不同的解决方法：</p>
<ul>
<li><ol>
<li><strong>暴力递归</strong>，很多子问题会重复计算，时间复杂度高</li>
</ol>
</li>
<li><ol start="2">
<li><strong>记忆化搜索or带memo的递归</strong>，避免了重复计算,先问问memo有没有答案，如果有就直接返回，没有就计算，计算完了存到memo中，以空间换时间</li>
</ol>
</li>
<li><ol start="3">
<li><strong>自底向上的动态规划</strong>，使用 dp 数组来存储子问题的解，避免了重复计算 ，以空间换时间</li>
</ol>
</li>
<li><ol start="4">
<li><strong>自底向上的动态规划+空间优化</strong>，使用 dp 数组来存储子问题的解，避免了重复计算，并且使用滚动数组来优化空间复杂度</li>
</ol>
</li>
</ul>
<p>上述1，2的方法是自顶向下的动态规划，3，4的方法是自底向上的动态规划，4是尽可能把不要的子问题的答案给drop掉，从而达到空间复杂度的优化。</p>
<p>下面说两个具体题目，用上面4种方法来解决。</p>
<ul>
<li><p><a href="https://leetcode.cn/problems/fibonacci-number/">Leetcode 509</a> 斐波那契数</p>
<ul>
<li><ol>
<li><strong>暴力递归</strong></li>
</ol>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fib</span>(<span class="params">n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    <span class="keyword">return</span> fib(n - <span class="number">1</span>) + fib(n - <span class="number">2</span>)</span><br></pre></td></tr></table></figure></li>
<li><ol start="2">
<li><strong>记忆化搜索or带memo的递归</strong></li>
</ol>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">memo = &#123;&#125;</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fib</span>(<span class="params">n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="keyword">if</span> n <span class="keyword">in</span> memo:</span><br><span class="line">        <span class="keyword">return</span> memo[n]</span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    memo[n] = fib(n - <span class="number">1</span>) + fib(n - <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> memo[n]</span><br></pre></td></tr></table></figure></li>
<li><ol start="3">
<li><strong>自底向上的动态规划</strong></li>
</ol>
<ul>
<li>明确「状态」：<code>dp[i]</code>表示第i个斐波那契数</li>
<li>明确「选择」：只有一个选择，就是<code>dp[i] = dp[i-1] + dp[i-2]</code></li>
<li>定义 dp 数组&#x2F;函数的含义：<code>dp = [0] * (n + 1)</code>，<code>dp[0] = 0, dp[1] = 1</code><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fib</span>(<span class="params">n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    dp = [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line">    dp[<span class="number">0</span>], dp[<span class="number">1</span>] = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">        dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>]</span><br><span class="line">    <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><ol start="4">
<li><strong>自底向上的动态规划+空间优化</strong></li>
</ol>
<ul>
<li>只需要知道最后两个状态，所以只需要两个变量来存储前两个状态，<code>a, b = 0, 1</code>，<code>a, b = b, a + b</code>。<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fib</span>(<span class="params">n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    a, b = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">        a, b = b, a + b</span><br><span class="line">    <span class="keyword">return</span> b</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><a href="https://leetcode.cn/problems/coin-change/">Leetcode 322</a> 零钱兑换</p>
<ul>
<li><ol>
<li><strong>暴力递归</strong></li>
</ol>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">waysOfcoinChange</span>(<span class="params">self, coins, amount</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        返回coins可以凑成amount所需的最少的硬币个数</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> amount &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> amount == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">elif</span> amount <span class="keyword">in</span> coins:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            ress = []</span><br><span class="line">            <span class="keyword">for</span> coin <span class="keyword">in</span> coins:</span><br><span class="line">                res = <span class="variable language_">self</span>.waysOfcoinChange(coins,amount - coin)</span><br><span class="line">                <span class="keyword">if</span> res != -<span class="number">1</span>:</span><br><span class="line">                    ress.append(res + <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span> <span class="keyword">if</span> ress == [] <span class="keyword">else</span> <span class="built_in">min</span>(ress)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">coinChange</span>(<span class="params">self, coins, amount</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type coins: List[int]</span></span><br><span class="line"><span class="string">        :type amount: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.waysOfcoinChange(coins,amount)</span><br></pre></td></tr></table></figure>
</li>
<li><ol start="2">
<li><strong>记忆化搜索or带memo的递归</strong></li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.memo = &#123;&#125;</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">waysOfcoinChange</span>(<span class="params">self, coins, amount</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        返回coins可以凑成amount所需的最少的硬币个数</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> amount <span class="keyword">in</span> <span class="variable language_">self</span>.memo:</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">self</span>.memo[amount]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> amount &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="variable language_">self</span>.memo[amount] = -<span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> amount == <span class="number">0</span>:</span><br><span class="line">            <span class="variable language_">self</span>.memo[amount] = <span class="number">0</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">elif</span> amount <span class="keyword">in</span> coins:</span><br><span class="line">            <span class="variable language_">self</span>.memo[amount] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            ress = []</span><br><span class="line">            <span class="keyword">for</span> coin <span class="keyword">in</span> coins:</span><br><span class="line">                res = <span class="variable language_">self</span>.waysOfcoinChange(coins,amount - coin)</span><br><span class="line">                <span class="keyword">if</span> res != -<span class="number">1</span>:</span><br><span class="line">                    ress.append(res + <span class="number">1</span>)</span><br><span class="line">            <span class="variable language_">self</span>.memo[amount] = -<span class="number">1</span> <span class="keyword">if</span> ress == [] <span class="keyword">else</span> <span class="built_in">min</span>(ress)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span> <span class="keyword">if</span> ress == [] <span class="keyword">else</span> <span class="built_in">min</span>(ress)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">coinChange</span>(<span class="params">self, coins, amount</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type coins: List[int]</span></span><br><span class="line"><span class="string">        :type amount: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.waysOfcoinChange(coins,amount)</span><br></pre></td></tr></table></figure>
</li>
<li><ol start="3">
<li><strong>自底向上的动态规划</strong></li>
</ol>
<ul>
<li><ol>
<li>明确「状态」：<code>dp[i]</code>表示凑成金额i所需的最少的硬币个数</li>
</ol>
</li>
<li><ol start="2">
<li>明确「选择」：有<code>len(coins)</code>个选择，<code>dp[i] = min(dp[i - coins[j]]) + 1</code>，<code>j = 0, 1, ..., len(coins) - 1</code></li>
</ol>
</li>
<li><ol start="3">
<li>定义 dp 数组&#x2F;函数的含义：<code>dp = [0] * (amount + 1)</code>，<code>dp[0] = 0</code></li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">coinChange</span>(<span class="params">self, coins, amount</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :type coins: List[int]</span></span><br><span class="line"><span class="string">    :type amount: int</span></span><br><span class="line"><span class="string">    :rtype: int</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    dp = [<span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>)]*(amount + <span class="number">1</span>)</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(dp)):</span><br><span class="line">        ress = []</span><br><span class="line">        <span class="keyword">for</span> coin <span class="keyword">in</span> coins:</span><br><span class="line">            <span class="keyword">if</span> i &lt; coin:</span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line">            <span class="keyword">elif</span> i == coin:</span><br><span class="line">                ress.append(<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># i &gt; coin</span></span><br><span class="line">                ress.append(dp[i-coin] + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> ress != []:</span><br><span class="line">            dp[i] = <span class="built_in">min</span>(ress)</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span> <span class="keyword">if</span> dp[amount] == <span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>) <span class="keyword">else</span> dp[amount]</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><ol start="4">
<li><strong>自底向上的动态规划+空间优化</strong>, 该题目没有空间优化的必要，因为<code>dp</code>数组的大小是<code>amount + 1</code>，而且<code>coins</code>的大小是<code>len(coins)</code></li>
</ol>
</li>
<li><p><a href="https://leetcode.cn/problems/climbing-stairs/">Leetcode 70</a> 爬楼梯</p>
<ul>
<li><ol>
<li><strong>暴力递归</strong></li>
</ol>
</li>
<li><ol start="2">
<li><strong>记忆化搜索or带memo的递归</strong></li>
</ol>
</li>
<li><ol start="3">
<li><strong>自底向上的动态规划</strong></li>
</ol>
<ul>
<li><ol>
<li>明确「状态」：<code>dp[i]</code>表示第i阶楼梯的走法</li>
</ol>
</li>
<li><ol start="2">
<li>明确「选择」：有<code>1</code>个选择，<code>dp[i] = dp[i - 1] + dp[i - 2]</code></li>
</ol>
</li>
<li><ol start="3">
<li>定义 dp 数组&#x2F;函数的含义：<code>dp = [0] * (n + 1)</code>，<code>dp[0] = 1, dp[1] = 1</code></li>
</ol>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">climbStairs</span>(<span class="params">self, n</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        dp = [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>], dp[<span class="number">1</span>] = <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>]</span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><ol start="4">
<li><strong>自底向上的动态规划+空间优化</strong></li>
</ol>
<ul>
<li>只需要知道最后两个状态，所以只需要两个变量来存储前两个状态，<code>a, b = 1, 1</code>，<code>a, b = b, a + b</code>。</li>
</ul>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">climbStairs</span>(<span class="params">self, n</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        a, b = <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">            a, b = b, a + b</span><br><span class="line">        <span class="keyword">return</span> b</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="回溯算法解题套路框架"><a href="#回溯算法解题套路框架" class="headerlink" title="回溯算法解题套路框架"></a><a href="https://labuladong.online/algo/essential-technique/backtrack-framework/">回溯算法解题套路框架</a></h2><blockquote>
<p>其实<strong>回溯算法和我们常说的 DFS 算法基本可以认为是同一种算法</strong>, 抽象地说，<strong>解决一个回溯问题，实际上就是遍历一棵决策树的过程</strong>，树的每个叶子节点存放着一个合法答案。你把整棵树遍历一遍，把叶子节点上的答案都收集起来，就能得到所有的合法答案。下面的框架可以确保结果没有漏，但是<strong>回溯的难点往往是是如何剪枝，减少重复计算。</strong></p>
</blockquote>
<p>站在回溯树的一个节点上，你只需要思考 3 个问题：</p>
<ul>
<li>1、路径：也就是已经做出的选择。</li>
<li>2、选择列表：也就是你当前可以做的选择。</li>
<li>3、结束条件：也就是到达决策树底层，无法再做选择的条件。</li>
</ul>
<p>其一般的算法框架为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">res = []</span><br><span class="line">path = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">路径, 选择列表</span>):</span><br><span class="line">    <span class="comment"># 触发结束条件，收集结果</span></span><br><span class="line">    <span class="keyword">if</span> 结束条件:</span><br><span class="line">        res.append(path[:])</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> 选择 <span class="keyword">in</span> 选择列表:</span><br><span class="line">        <span class="comment"># 做选择</span></span><br><span class="line">        path.append(选择)</span><br><span class="line">        <span class="comment"># 进入下一层决策树</span></span><br><span class="line">        backtrack(路径, 选择列表)</span><br><span class="line">        <span class="comment"># 撤销选择</span></span><br><span class="line">        path.pop()</span><br></pre></td></tr></table></figure>




<p>考虑到<a href="###%E5%A4%9A%E5%8F%89%E6%A0%91%E7%9A%84%E9%80%92%E5%BD%92/%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86">多叉树的遍历</a>,他是没有中序遍历的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">(NTreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span>; <span class="comment">// 递归终止条件</span></span><br><span class="line">    <span class="comment">//时机点1 do something with root-&gt;val; e.g. arr.push_back(root-&gt;val); </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> child : root-&gt;children) &#123; <span class="comment">// 遍历子节点</span></span><br><span class="line">        <span class="built_in">traverse</span>(child); <span class="comment">// 遍历子节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//时机点2 do something with root-&gt;val; e.g. arr.push_back(root-&gt;val);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是前序和后续的位置在for的外面，而回溯是在for的里面，这是为什么？详见如下图的解释：<br><img src="/../images/image-14.png" alt="alt text"></p>
<p><strong>回溯的算法复杂度不会低于O(N!)，因为你必须遍历所有的节点,不像动态规划存在重叠子问题可以优化，回溯算法就是纯暴力穷举，复杂度一般都很高</strong></p>
<h3 id="回溯算法的例题："><a href="#回溯算法的例题：" class="headerlink" title="回溯算法的例题："></a>回溯算法的例题：</h3><ul>
<li><p><a href="https://leetcode.cn/problems/permutations/">Leetcode 46</a> 全排列<br>之前写过</p>
</li>
<li><p><a href="https://leetcode.cn/problems/permutations-ii/">Leetcode 47*</a> 全排列 II<br>  和下面的39题目类似，都是不会剪枝，用哈希表来去重，非常慢但是可以AC。</p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.res = []</span><br><span class="line">        <span class="variable language_">self</span>.path = []</span><br><span class="line">        <span class="variable language_">self</span>.aux = <span class="built_in">set</span>()</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">self,choices</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(choices) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">str</span>(<span class="variable language_">self</span>.path) <span class="keyword">not</span> <span class="keyword">in</span> <span class="variable language_">self</span>.aux:</span><br><span class="line">                <span class="variable language_">self</span>.aux.add(<span class="built_in">str</span>(<span class="variable language_">self</span>.path))</span><br><span class="line">                <span class="variable language_">self</span>.res.append(<span class="variable language_">self</span>.path[:])</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        <span class="keyword">for</span> idx,choice <span class="keyword">in</span> <span class="built_in">enumerate</span>(choices):</span><br><span class="line">            <span class="variable language_">self</span>.path.append(choice)</span><br><span class="line">            <span class="variable language_">self</span>.backtrack(choices[:idx] +choices[idx+<span class="number">1</span>:])</span><br><span class="line">            <span class="variable language_">self</span>.path.pop()</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">permuteUnique</span>(<span class="params">self, nums</span>):</span><br><span class="line">        <span class="variable language_">self</span>.backtrack(nums)</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.res</span><br></pre></td></tr></table></figure>
</li>
<li><p><a href="https://leetcode.cn/problems/combination-sum/">Leetcode 39*</a> 组合总和<br>这个题目可以直接套用上面的框架，但是结果是有重复的，个人觉得要剪枝，但是不会剪枝，用了<code>Counter</code>在加如res的时候去重。</p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        </span><br><span class="line">        <span class="variable language_">self</span>.res = []</span><br><span class="line">        <span class="variable language_">self</span>.aux_for_drop_same = []</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">self</span>.path = []</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">self,candidates,target</span>):</span><br><span class="line">        path_sum = <span class="built_in">sum</span>(<span class="variable language_">self</span>.path)</span><br><span class="line">        <span class="keyword">if</span> path_sum &gt; target:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">elif</span> path_sum == target:</span><br><span class="line">            <span class="keyword">if</span> Counter(<span class="variable language_">self</span>.path) <span class="keyword">not</span> <span class="keyword">in</span> <span class="variable language_">self</span>.aux_for_drop_same:</span><br><span class="line">                <span class="variable language_">self</span>.aux_for_drop_same.append( Counter(<span class="variable language_">self</span>.path))</span><br><span class="line">                <span class="variable language_">self</span>.res.append(<span class="variable language_">self</span>.path[:])</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">for</span> choice <span class="keyword">in</span> candidates:</span><br><span class="line">                <span class="variable language_">self</span>.path.append(choice)</span><br><span class="line">                <span class="variable language_">self</span>.backtrack(candidates,target)</span><br><span class="line">                <span class="variable language_">self</span>.path.pop()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">combinationSum</span>(<span class="params">self, candidates, target</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type candidates: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="variable language_">self</span>.backtrack(candidates,target)</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.res</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="BFS-算法解题套路框架"><a href="#BFS-算法解题套路框架" class="headerlink" title="BFS 算法解题套路框架"></a><a href="https://labuladong.online/algo/essential-technique/bfs-framework/">BFS 算法解题套路框架</a></h2><blockquote>
<p>DFS&#x2F;回溯&#x2F;BFS 这类算法，本质上就是把具体的问题抽象成树结构，然后遍历这棵树进行暴力穷举，所以这些穷举算法的代码本质上就是树的遍历代码。在真实的面试笔试题目中，一般不是直接让你遍历树&#x2F;图这种标准数据结构，而是给你一个具体的场景题，<strong>你需要把具体的场景抽象成一个标准的图&#x2F;树结构，然后利用 BFS 算法穷举得出答案。抽象往往是问题的难点</strong></p>
</blockquote>
<p>为啥 BFS 算法经常用来求解最短路径问题？其实所谓的最短路径，都可以类比成二叉树最小深度这类问题（寻找距离根节点最近的叶子节点），<strong>递归遍历必须要遍历整棵树的所有节点才能找到目标节点，而层序遍历不需要遍历所有节点就能搞定</strong>，所以层序遍历适合解决这类最短路径问题。</p>
<p>回忆到之前的<a href="####BFS%E9%81%8D%E5%8E%86%E5%AE%9E%E7%8E%B0">BFS遍历实现</a>,我们总共提到了3种遍历方式：</p>
<ul>
<li><ol>
<li>vinila BFS 最为简单的BFS，无法知道当前的层数</li>
</ol>
</li>
<li><ol start="2">
<li>知道层数的BFS，使用一个队列来存储当前层的节点，遍历完当前层的节点后，增加层数</li>
</ol>
</li>
<li><ol start="3">
<li>知道变长层数的BFS，使用<code>state</code>来存储当前层的节点以及其层数，队列中是state，遍历完当前层的节点后，增加变长层数</li>
</ol>
</li>
</ul>
<h3 id="下面介绍几个BFS的例题："><a href="#下面介绍几个BFS的例题：" class="headerlink" title="下面介绍几个BFS的例题："></a>下面介绍几个BFS的例题：</h3><ul>
<li><p><a href="https://leetcode.cn/problems/sliding-puzzle/">Leetcode 773*</a> 滑动谜题<br>  非常经典的BFS题目，如何抽象成图结构？每个Node其实就是一种<code>board</code>的状态，<code>board</code>的每个状态可以看成是一个节点，<code>board</code>的邻节点就是<code>board</code>的每个状态可以变成的状态，具体可以抽象为：</p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Myboard</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, board</span>):</span><br><span class="line">        <span class="variable language_">self</span>.m = <span class="built_in">len</span>(board)</span><br><span class="line">        <span class="variable language_">self</span>.n = <span class="built_in">len</span>(board[<span class="number">0</span>])</span><br><span class="line">        <span class="variable language_">self</span>.board = copy.deepcopy(board)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">uuid</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">str</span>(<span class="variable language_">self</span>.board)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">str</span>(<span class="variable language_">self</span>.board)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.__str__()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__eq__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.uuid() == other.uuid()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">neighbors</span>(<span class="params">self</span>):</span><br><span class="line">        res = []</span><br><span class="line">        idx0, idy = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="variable language_">self</span>.m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="variable language_">self</span>.n):</span><br><span class="line">                <span class="keyword">if</span> <span class="variable language_">self</span>.board[i][j] == <span class="number">0</span>:</span><br><span class="line">                    idx0, idy = i, j</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i, j <span class="keyword">in</span> [(<span class="number">0</span>, <span class="number">1</span>), (<span class="number">0</span>, -<span class="number">1</span>), (<span class="number">1</span>, <span class="number">0</span>), (-<span class="number">1</span>, <span class="number">0</span>)]:</span><br><span class="line">            <span class="keyword">if</span> <span class="number">0</span> &lt;= idx0 + i &lt; <span class="variable language_">self</span>.m <span class="keyword">and</span> <span class="number">0</span> &lt;= idy + j &lt; <span class="variable language_">self</span>.n:</span><br><span class="line">                new_board = copy.deepcopy(<span class="variable language_">self</span>.board)</span><br><span class="line">                new_board[idx0][idy], new_board[idx0 + i][idy + j] = new_board[idx0 + i][idy + j], new_board[idx0][idy]</span><br><span class="line">                res.append(Myboard(new_board))</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p>  有了上述抽象的数据结构，直接套用BFS的框架就可以了，<strong>注意python中二维数据的深度拷贝。</strong></p>
</li>
<li><p><a href="https://leetcode.cn/problems/open-the-lock/">Leetcode 752*</a> 打开转盘锁<br>  将🔒抽象为：</p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Lock</span>:</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, init_lock</span>):</span><br><span class="line">    <span class="variable language_">self</span>.lock = init_lock</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="string">f&quot;Lock:(<span class="subst">&#123;self.lock&#125;</span>)&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__eq__</span>(<span class="params">self, other</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">self</span>.lock == other.lock</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">uuid</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">self</span>.lock</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">neighbors</span>(<span class="params">self</span>):</span><br><span class="line">    neighbors = []</span><br><span class="line">    <span class="keyword">for</span> idx, digit <span class="keyword">in</span> <span class="built_in">enumerate</span>(<span class="variable language_">self</span>.lock):</span><br><span class="line">        <span class="keyword">for</span> delta <span class="keyword">in</span> [-<span class="number">1</span>, <span class="number">1</span>]:</span><br><span class="line">            new_digit = (<span class="built_in">int</span>(digit) + delta) % <span class="number">10</span></span><br><span class="line">            new_lock = <span class="variable language_">self</span>.lock[:idx] + <span class="built_in">str</span>(new_digit) + <span class="variable language_">self</span>.lock[idx + <span class="number">1</span>:]</span><br><span class="line">            neighbors.append(Lock(new_lock))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> neighbors</span><br></pre></td></tr></table></figure>
<p>  对于deadends的处理可以直接加到<code>visited</code>中，这样不会影响整体的逻辑。</p>
</li>
</ul>
<h3 id="BFS优化：双向BFS"><a href="#BFS优化：双向BFS" class="headerlink" title="BFS优化：双向BFS"></a>BFS优化：双向BFS</h3><blockquote>
<p>双向 BFS 的思路是从起点和终点同时开始搜索，直到两者相遇。传统的 BFS 框架是从起点开始向四周扩散，遇到终点时停止；而双向 BFS 则是从起点和终点同时开始扩散，当两边有交集的时候停止。为什么这样能够能够提升效率呢？ 就好比有 A 和 B 两个人，传统 BFS 就相当于 A 出发去找 B，而 B 待在原地不动；双向 BFS 则是 A 和 B 一起出发，双向奔赴。那当然第二种情况下 A 和 B 可以更快相遇。</p>
</blockquote>
<p><strong>无论是单向还是双向算法的复杂度都是O(N)，所以在实际应用中，双向BFS的效率会更高。<strong>但</strong>双向BFS需要你知道destination的状态</strong>，单向BFS不需要你知道destination的状态，如果不知道就没有办法从两端同时开始扩散。可以看如下图：</p>
<p><img src="/../images/image-15.png" alt="alt text"></p>
<p>针对<a href="https://leetcode.cn/problems/open-the-lock/">Leetcode 752</a> 打开转盘锁，我们可以使用双向BFS来优化，代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Lock</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, init_lock</span>):</span><br><span class="line">        <span class="variable language_">self</span>.lock = init_lock</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;Lock:(<span class="subst">&#123;self.lock&#125;</span>)&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__eq__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(other, Lock):</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">self</span>.lock == other.lock</span><br><span class="line">        <span class="keyword">elif</span> <span class="built_in">isinstance</span>(other, <span class="built_in">str</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">self</span>.lock == other</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> TypeError(<span class="string">&quot;Invalid type&quot;</span>)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__hash__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">hash</span>(<span class="variable language_">self</span>.lock)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">neighbors</span>(<span class="params">self</span>):</span><br><span class="line">        neighbors = []</span><br><span class="line">        <span class="keyword">for</span> idx, digit <span class="keyword">in</span> <span class="built_in">enumerate</span>(<span class="variable language_">self</span>.lock):</span><br><span class="line">            <span class="keyword">for</span> delta <span class="keyword">in</span> [-<span class="number">1</span>, <span class="number">1</span>]:</span><br><span class="line">                new_digit = (<span class="built_in">int</span>(digit) + delta) % <span class="number">10</span></span><br><span class="line">                new_lock = <span class="variable language_">self</span>.lock[:idx] + <span class="built_in">str</span>(new_digit) + <span class="variable language_">self</span>.lock[idx + <span class="number">1</span>:]</span><br><span class="line">                neighbors.append(Lock(new_lock))</span><br><span class="line">        <span class="keyword">return</span> neighbors</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">openLock</span>(<span class="params">self, deadends, target</span>):</span><br><span class="line">        begin = Lock(init_lock=<span class="string">&quot;0000&quot;</span>)</span><br><span class="line">        target = Lock(init_lock=target)</span><br><span class="line">        <span class="keyword">if</span> begin == target:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> begin <span class="keyword">in</span> deadends:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        deadends = <span class="built_in">set</span>([Lock(_) <span class="keyword">for</span> _ <span class="keyword">in</span> deadends])</span><br><span class="line">        b2t_visited = &#123;begin&#125;</span><br><span class="line">        b2t_q = deque([begin])</span><br><span class="line"></span><br><span class="line">        t2b_visited = &#123;target&#125;</span><br><span class="line">        t2b_q = deque([target])</span><br><span class="line"></span><br><span class="line">        depth = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> b2t_q <span class="keyword">and</span> t2b_q:</span><br><span class="line">            depth += <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(b2t_q)):</span><br><span class="line">                curr = b2t_q.popleft()</span><br><span class="line">                <span class="keyword">for</span> neighbor <span class="keyword">in</span> curr.neighbors():</span><br><span class="line">                    <span class="keyword">if</span> neighbor <span class="keyword">in</span> deadends:</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    <span class="keyword">if</span> neighbor <span class="keyword">in</span> t2b_visited:</span><br><span class="line">                        <span class="keyword">return</span> depth</span><br><span class="line">                    <span class="keyword">if</span> neighbor <span class="keyword">not</span> <span class="keyword">in</span> b2t_visited:</span><br><span class="line">                        b2t_q.append(neighbor)</span><br><span class="line">                        b2t_visited.add(neighbor)</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            depth += <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(t2b_q)):</span><br><span class="line">                curr = t2b_q.popleft()</span><br><span class="line">                <span class="keyword">for</span> neighbor <span class="keyword">in</span> curr.neighbors():</span><br><span class="line">                    <span class="keyword">if</span> neighbor <span class="keyword">in</span> deadends:</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    <span class="keyword">if</span> neighbor <span class="keyword">in</span> b2t_visited:</span><br><span class="line">                        <span class="keyword">return</span> depth</span><br><span class="line">                    <span class="keyword">if</span> neighbor <span class="keyword">not</span> <span class="keyword">in</span> t2b_visited:</span><br><span class="line">                        t2b_q.append(neighbor)</span><br><span class="line">                        t2b_visited.add(neighbor)</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>确实是要比单项BFS快很多，<strong>但是双向BFS的实现会比单向BFS复杂很多</strong>。</p>
<h2 id="二叉树系列算法核心纲领"><a href="#二叉树系列算法核心纲领" class="headerlink" title="二叉树系列算法核心纲领"></a><a href="https://labuladong.online/algo/essential-technique/binary-tree-summary/">二叉树系列算法核心纲领</a></h2><h3 id="二叉树的重要性"><a href="#二叉树的重要性" class="headerlink" title="二叉树的重要性"></a>二叉树的重要性</h3><p>对于如下<code>quicksort</code>和<code>mergesort</code>的实现，我可以说<code>quicksort</code>是二叉树的前序遍历，<code>mergesort</code>是二叉树的后序遍历</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">quick_sort</span>(<span class="params">arr</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(arr) &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> arr</span><br><span class="line">    <span class="comment"># 前序遍历时机点</span></span><br><span class="line">    pivot = arr[<span class="built_in">len</span>(arr) // <span class="number">2</span>]</span><br><span class="line">    left = [x <span class="keyword">for</span> x <span class="keyword">in</span> arr <span class="keyword">if</span> x &lt; pivot]</span><br><span class="line">    middle = [x <span class="keyword">for</span> x <span class="keyword">in</span> arr <span class="keyword">if</span> x == pivot]</span><br><span class="line">    right = [x <span class="keyword">for</span> x <span class="keyword">in</span> arr <span class="keyword">if</span> x &gt; pivot]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 递归调用</span></span><br><span class="line">    <span class="keyword">return</span> quick_sort(left) + middle + quick_sort(right)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">merge_sort</span>(<span class="params">arr</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(arr) &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> arr</span><br><span class="line">    mid = <span class="built_in">len</span>(arr) // <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 递归调用</span></span><br><span class="line">    left = merge_sort(arr[:mid])</span><br><span class="line">    right = merge_sort(arr[mid:])</span><br><span class="line">    <span class="comment"># 后序遍历的时机点</span></span><br><span class="line">    result = []</span><br><span class="line">    i = j = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(left) <span class="keyword">and</span> j &lt; <span class="built_in">len</span>(right):</span><br><span class="line">        <span class="keyword">if</span> left[i] &lt; right[j]:</span><br><span class="line">            result.append(left[i])</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            result.append(right[j])</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">    result.extend(left[i:])</span><br><span class="line">    result.extend(right[j:])</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

<h3 id="深入理解前中后序遍历"><a href="#深入理解前中后序遍历" class="headerlink" title="深入理解前中后序遍历"></a>深入理解前中后序遍历</h3><p>在此之前有个更基本的问题，什么是遍历,什么是<code>traverse</code>？ </p>
<p>遍历就是把数据结构中的每个节点都访问一遍，遍历按照实现的方式可以分为两类：</p>
<ul>
<li><ol>
<li>递归遍历：使用递归函数来遍历数据结构，递归函数的参数是当前节点，返回值是当前节点的值。</li>
</ol>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 递归遍历数组</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">traverse_recursive</span>(<span class="params">arr: <span class="type">List</span>[<span class="built_in">int</span>], i: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">    <span class="keyword">if</span> i == <span class="built_in">len</span>(arr):</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="comment"># 前序位置</span></span><br><span class="line">    traverse_recursive(arr, i + <span class="number">1</span>)</span><br><span class="line">    <span class="comment"># 后序位置</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 递归遍历链表</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">traverse_recursive</span>(<span class="params">head: ListNode</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">    <span class="keyword">if</span> head <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="comment"># 前序位置</span></span><br><span class="line">    traverse_recursive(head.<span class="built_in">next</span>)</span><br><span class="line">    <span class="comment"># 后序位置</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 递归遍历树</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">traverse_recursive</span>(<span class="params">root: TreeNode</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="comment"># 前序位置</span></span><br><span class="line">    traverse_recursive(root.left)</span><br><span class="line">    <span class="comment"># 中序位置，只有二叉搜索树有意义</span></span><br><span class="line">    traverse_recursive(root.right)</span><br><span class="line">    <span class="comment"># 后序位置</span></span><br></pre></td></tr></table></figure></li>
<li><ol start="2">
<li>迭代遍历：不通过调用自身来遍历数据结构，而是使用循环结构来遍历数据结构，迭代遍历的实现方式有很多种，最常见的就是使用栈来模拟递归的过程。</li>
</ol>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 迭代遍历数组</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">traverse_iterative</span>(<span class="params">arr: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(arr)):</span><br><span class="line">        <span class="comment"># do something with arr[i]</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 迭代遍历链表</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">traverse_iterative</span>(<span class="params">head: ListNode</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">    <span class="keyword">while</span> head <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="comment"># do something with head.val</span></span><br><span class="line">        head = head.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 迭代遍历树，如下是dfs的前序遍历实现，迭代的中序和后序遍历一般不用，过于复杂！</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">traverse_iterative</span>(<span class="params">root: TreeNode</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">    stack = [root]</span><br><span class="line">    <span class="keyword">while</span> stack:</span><br><span class="line">        node = stack.pop()</span><br><span class="line">        <span class="comment"># do something with node.val</span></span><br><span class="line">        <span class="keyword">if</span> node.right:</span><br><span class="line">            stack.append(node.right)</span><br><span class="line">        <span class="keyword">if</span> node.left:</span><br><span class="line">            stack.append(node.left)</span><br><span class="line"><span class="comment"># 迭代遍历树，如下是bfs的实现，最常用</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">traverse_iterative</span>(<span class="params">root: TreeNode</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">    queue = [root]</span><br><span class="line">    <span class="keyword">while</span> queue:</span><br><span class="line">        node = queue.pop(<span class="number">0</span>)</span><br><span class="line">        <span class="comment"># do something with node.val</span></span><br><span class="line">        <span class="keyword">if</span> node.left:</span><br><span class="line">            queue.append(node.left)</span><br><span class="line">        <span class="keyword">if</span> node.right:</span><br><span class="line">            queue.append(node.right)</span><br></pre></td></tr></table></figure></li>
</ul>
<table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>递归</strong></th>
<th><strong>迭代</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>实现方式</strong></td>
<td>函数调用自身</td>
<td>使用循环结构</td>
</tr>
<tr>
<td><strong>终止条件</strong></td>
<td>必须显式定义 Base Case</td>
<td>通过循环条件控制</td>
</tr>
<tr>
<td><strong>性能</strong></td>
<td>可能有额外的函数调用开销（栈空间）</td>
<td>通常更高效（无函数调用开销）</td>
</tr>
<tr>
<td><strong>代码可读性</strong></td>
<td>更简洁（对符合递归思维的问题）</td>
<td>可能更直观（线性流程）</td>
</tr>
<tr>
<td><strong>适用问题</strong></td>
<td>问题可分解为同类子问题（如分治）</td>
<td>线性或简单的重复操作</td>
</tr>
<tr>
<td><strong>空间复杂度</strong></td>
<td>可能占用更多栈空间（栈溢出风险）</td>
<td>通常空间效率更高</td>
</tr>
<tr>
<td><strong>缺点</strong></td>
<td>可能导致栈溢出（深度递归）</td>
<td>树结构遍历复杂时代码较长</td>
</tr>
</tbody></table>
<p>说到递归遍历的缺点，如下代码，深度为2128的递归遍历会导致栈溢出，python的默认递归深度为1000，超过这个深度就需要谨慎了。如下的这个例子可以注释不同的print语句来观察前序遍历和后序遍历的区别，非常好的例子。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">traverse_recursive</span>(<span class="params">arr, idx</span>):</span><br><span class="line">    <span class="keyword">if</span> idx == <span class="built_in">len</span>(arr):</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="comment"># print(arr[idx])</span></span><br><span class="line">    traverse_recursive(arr, idx + <span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(arr[idx])</span><br><span class="line">traverse_recursive(<span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">2129</span>)), <span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<hr>
<p>当我们在说前序&#x2F;后序遍历的时候，我们实际上在说什么？</p>
<p>首先前序&#x2F;后序遍历只存在递归遍历中（迭代遍历需要需要使用栈来模拟递归的过程），前序&#x2F;后序遍历是指在递归函数中，当前节点的值在什么时机点被访问。在调用自身之前访问当前节点的值叫做前序遍历，在调用自身之后访问当前节点的值叫做后序遍历。 或者说就是刚进入一个节点（元素）的时候，后序位置就是即将离开一个节点（元素）的时候。总结为：</p>
<ul>
<li>前序遍历：在进入一个节点之前访问它的值&#x2F;递归函数调用自身之前访问它的值</li>
<li>后序遍历：在离开一个节点之前访问它的值&#x2F;递归函数调用自身之后访问它的值</li>
</ul>
<p>具体的图示如下：<br><img src="/../images/image-16.png" alt="alt text"></p>
<p>链表和数组的好好的迭代遍历不用，为什么要用递归遍历？<br>递归遍历可以倒序遍历链表和数组，其实是没啥卵用，而且还容易栈溢出。</p>
<p>多叉树没有中序遍历嘛？<br>准确来说是没有唯一的中序遍历，因为<strong>n叉树的有n-1种中序遍历方式，n叉树的中序遍历是没有意义的。</strong></p>
<hr>
<p>二叉树的所有问题，就是让你在前中后序位置注入巧妙的代码逻辑，去达到自己的目的，你只需要单独思考每一个节点应该做什么，其他的不用你管，抛给二叉树遍历框架，递归会在所有节点上做相同的操作</p>
<h3 id="两种解题思路"><a href="#两种解题思路" class="headerlink" title="两种解题思路"></a>两种解题思路</h3><p>在之前的<a href="https://labuladong.online/algo/essential-technique/understand-recursion/">一个视角 + 两种思维模式搞定递归</a>中已经提到过，<strong>二叉树解题的思维模式分两类：</strong></p>
<p>1、是否可以通过遍历一遍二叉树得到答案？如果可以，用一个 traverse 函数配合外部变量来实现，这叫「遍历」的思维模式。其函数签名为 <code>void traverse(TreeNode root, ...)</code>，无返回值，遍历过程中修改外部变量。</p>
<blockquote>
<p>遍历这种思维对应这<strong>回溯</strong>，回溯的函数签名为 <code>void backtrack(TreeNode root, ...)</code>，无返回值，遍历过程中修改外部变量。但两者也存在区别<br><code>void backtrack(TreeNode root, ...)</code> 需要在for内部做选择与撤销，重点关注树枝</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">res = []</span><br><span class="line">&gt;path = []</span><br><span class="line">&gt;<span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">路径, 选择列表</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">   <span class="comment"># 触发结束条件，收集结果</span></span><br><span class="line">   <span class="keyword">if</span> 结束条件:</span><br><span class="line">       res.append(path[:])</span><br><span class="line">       <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> 选择 <span class="keyword">in</span> 选择列表:</span><br><span class="line">       <span class="comment"># 做选择</span></span><br><span class="line">       path.append(选择)</span><br><span class="line">       <span class="comment"># 进入下一层决策树</span></span><br><span class="line">       backtrack(路径, 选择列表)</span><br><span class="line">       <span class="comment"># 撤销选择</span></span><br><span class="line">       path.pop()</span><br></pre></td></tr></table></figure>
<p><code>void traverse(TreeNode root, ...)</code> 不需要在for内部做选择与撤销，重点关注树的节点</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">res = []</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">traverse</span>(<span class="params">root, ...</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="comment"># 前序遍历时机点</span></span><br><span class="line">    <span class="keyword">for</span> child <span class="keyword">in</span> root.children:</span><br><span class="line">        traverse(child, ...)</span><br><span class="line">    <span class="comment"># 后序遍历时机点</span></span><br></pre></td></tr></table></figure></blockquote>
<p>2、是否可以定义一个递归函数，通过子问题（子树）的答案推导出原问题的答案？如果可以，写出这个递归函数的定义，并充分利用这个函数的返回值，这叫「分解问题」的思维模式。 其函数签名为 <code>T func(TreeNode root, ...)</code> ，存在返回值，函数的返回值就是原问题的答案，常见的有<code>int fibonacci(int n)</code>、<code>int maxDepth(TreeNode root)</code>等。</p>
<blockquote>
<p>分解问题这种思维对应着<strong>动态规划</strong>，都是devide and conquer 的思维模式。不同的是，动态规划是自底向上的思维模式，<strong>而递归是自顶向下的思维模式</strong>。</p>
</blockquote>
<hr>
<p><strong>上述的两种思维模式不是互斥的</strong>，有的问题可以都从这两种思维模式来解决。<code>void traverse(...)</code>得到前序，中序，后序的时候非常简单，只用决策将<code>self.res.append(root.val)</code>放在不同的位置就可以了,同样的递归也可以实现上述的功能。但为什么很少看到这种写法呢？原因是这个方法依赖<code>list.addAll</code>,由于list是连续的内存空间，所以<code>list.addAll</code>的时间复杂度是O(N)，而递归的时间复杂度是O(1)，所以递归的时间复杂度更低。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">pre</span>/<span class="keyword">in</span>/post_order_traversal(root) -&gt; <span class="type">List</span>:</span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="comment"># pre</span></span><br><span class="line">    <span class="keyword">return</span> [root.val] + pre/<span class="keyword">in</span>/post_order_traversal(root.left) + pre/<span class="keyword">in</span>/post_order_traversal(root.right)</span><br><span class="line">    <span class="comment"># in</span></span><br><span class="line">    <span class="keyword">return</span>  pre/<span class="keyword">in</span>/post_order_traversal(root.left)+[root.val] + pre/<span class="keyword">in</span>/post_order_traversal(root.right)</span><br><span class="line">    <span class="comment"># post</span></span><br><span class="line">    <span class="keyword">return</span> pre/<span class="keyword">in</span>/post_order_traversal(root.left) + pre/<span class="keyword">in</span>/post_order_traversal(root.right)+[root.val]</span><br></pre></td></tr></table></figure>


<p>**其次思维2也可以融合思维1，**思维2的递归也是在遍历，可以在遍历的过程中，更新外部变量，达到遍历的效果。例如<a href="https://leetcode.cn/problems/diameter-of-binary-tree/">二叉树直径</a>就是一个思维1和2的融合</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 思维1,全局变量</span></span><br><span class="line">diameter = <span class="number">0</span></span><br><span class="line"><span class="comment"># 思维2</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">maxDepth</span>(<span class="params">root</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    left = maxDepth(root.left)</span><br><span class="line">    right = maxDepth(root.right)</span><br><span class="line">    <span class="comment"># 思维1,更新全局变量</span></span><br><span class="line">    diameter = <span class="built_in">max</span>(diameter, left + right)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(left, right) + <span class="number">1</span></span><br></pre></td></tr></table></figure>





<h3 id="后序遍历的特殊之处"><a href="#后序遍历的特殊之处" class="headerlink" title="后序遍历的特殊之处"></a>后序遍历的特殊之处</h3><p>对于<code>void traverse(...)</code>来说,其三个时间点</p>
<ul>
<li>前序遍历时机点：第一次进入这个节点，只知道其父节点的信息</li>
<li>中序遍历时机点：第二次进入这个节点，知道其父节点的信息 + 部分子树的信息</li>
<li>后序遍历时机点：第三次进入这个节点，知道其父节点的信息 + 所有子树的信息</li>
</ul>
<p>前序遍历是最朴素的</p>
<p>中序遍历只知道部分子树的信息，其的特殊点是在BST中可输出有序结果，但在多叉树中没有意义。</p>
<p>后序遍历是威力最大的，因为其知道的信息是最多的，如下两个问题：</p>
<ul>
<li>Q1:如何打印出每一个节点所在的层数？</li>
<li>Q2:如何打印出每个节点的左右子树各有多少节点？</li>
</ul>
<table>
<thead>
<tr>
<th><strong>问题</strong></th>
<th><strong>前序遍历</strong></th>
<th><strong>中序遍历</strong></th>
<th><strong>后序遍历</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Q1</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>Q2</td>
<td>×</td>
<td>x</td>
<td>√</td>
</tr>
</tbody></table>
<h3 id="以树的视角看动归-回溯-DFS算法的区别和联系"><a href="#以树的视角看动归-回溯-DFS算法的区别和联系" class="headerlink" title="以树的视角看动归&#x2F;回溯&#x2F;DFS算法的区别和联系"></a>以树的视角看动归&#x2F;回溯&#x2F;DFS算法的区别和联系</h3><table>
<thead>
<tr>
<th>方法</th>
<th>以树的视角</th>
<th>特点</th>
<th>经典题目</th>
</tr>
</thead>
<tbody><tr>
<td>(树形)动规</td>
<td>根节点是原问题，<strong>子树是子问题</strong></td>
<td>将树分解为重叠子问题，通过记忆化或自底向上</td>
<td><a href="https://leetcode.cn/problems/house-robber/">打家劫舍</a><br>  <a href="https://leetcode.cn/problems/coin-change/">找零钱</a> <br></td>
</tr>
<tr>
<td>DFS</td>
<td>从根节点出发，尽可能深地访问子节点，直到叶子<strong>节点</strong></td>
<td>无状态性：不关心子问题的合并或路径的选择，仅完成对节点的遍历或简单操作</td>
<td><a href="https://leetcode.cn/problems/binary-tree-preorder-traversal/">二叉树的前序遍历</a> <br> <a href="https://leetcode.cn/problems/number-of-islands/">岛屿数量</a> <br></td>
</tr>
<tr>
<td>回溯</td>
<td>回溯是DFS在解空间树上的应用，关注<strong>树枝(i.e.选择)的收集</strong></td>
<td>状态管理：需要维护和回撤路径状态（如移除已选元素）。<br>剪枝优化：提前终止不符合条件的路径（如组合总和问题）。</td>
<td><a href="https://leetcode.cn/problems/permutations/">全排列</a> <br> <a href="https://leetcode.cn/problems/combination-sum/">组合总和</a> <br></td>
</tr>
</tbody></table>
<p>关于<code>void traverse(...)</code> 中的前序，后序时机，以及<code>void backtrack(...)</code>中的选择和撤销时机，如下的代码很好反应的上述的区别：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># traverse 把「做选择」「撤销选择」的逻辑放在 for 循环外面</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">traverse</span>(<span class="params">root</span>):</span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="comment"># 做选择</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;enter node %s&quot;</span> % root)</span><br><span class="line">    <span class="keyword">for</span> child <span class="keyword">in</span> root.children:</span><br><span class="line">        traverse(child)</span><br><span class="line">    <span class="comment"># 撤销选择</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;leave node %s&quot;</span> % root)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 回溯算法把「做选择」「撤销选择」的逻辑放在 for 循环里面</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">root</span>):</span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">for</span> child <span class="keyword">in</span> root.children:</span><br><span class="line">        <span class="comment"># 做选择</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;I&#x27;m on the branch from %s to %s&quot;</span> % (root, child))</span><br><span class="line">        backtrack(child)</span><br><span class="line">        <span class="comment"># 撤销选择</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;I&#x27;ll leave the branch from %s to %s&quot;</span> % (child, root))</span><br></pre></td></tr></table></figure>






<h3 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h3><p>除了队列实现的3种层序遍历，还有不用队列的方法,这个方法是我之前老爱用的方法，最为直观。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">level_traverse</span>(<span class="params">root</span>):</span><br><span class="line">    level = <span class="number">0</span></span><br><span class="line">    curr_level = [root]</span><br><span class="line">    next_level = []</span><br><span class="line">    <span class="keyword">while</span> curr_level:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;level <span class="subst">&#123;level&#125;</span> with : <span class="subst">&#123;[node.val <span class="keyword">for</span> node <span class="keyword">in</span> curr_level]&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> curr_level:</span><br><span class="line">            <span class="comment"># do something with node.val</span></span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                next_level.append(node.left)</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                next_level.append(node.right)</span><br><span class="line">        curr_level = next_level</span><br><span class="line">        next_level = []</span><br><span class="line">        level += <span class="number">1</span></span><br></pre></td></tr></table></figure>




<h2 id="回溯算法秒杀所有排列-组合-子集问题"><a href="#回溯算法秒杀所有排列-组合-子集问题" class="headerlink" title="回溯算法秒杀所有排列&#x2F;组合&#x2F;子集问题"></a><a href="https://labuladong.online/algo/essential-technique/permutation-combination-subset-all-in-one/">回溯算法秒杀所有排列&#x2F;组合&#x2F;子集问题</a></h2><h3 id="什么是排列-组合-子集问题问题？"><a href="#什么是排列-组合-子集问题问题？" class="headerlink" title="什么是排列&#x2F;组合&#x2F;子集问题问题？"></a>什么是排列&#x2F;组合&#x2F;子集问题问题？</h3><p>最基础地，给定<code>nums=[1,2,3]</code>数组，我们定义<code>n= len(nums)</code>，</p>
<ul>
<li>排列问题就是输出<code>n!</code>个元素的所有排列组合，例如<code>[1,2,3]</code>的排列组合有<code>[[1,2,3]</code>、<code>[1,3,2]</code>、<code>[2,1,3]</code>、<code>[2,3,1]</code>、<code>[3,1,2]</code>、<code>[3,2,1]]</code></li>
<li>组合问题一般给定<code>k</code>，输出<code>C_n^k</code>个元素的所有组合，例如<code>[1,2,3]的k=2</code>的组合有<code>[[1,2]</code>、<code>[1,3]</code>、<code>[2,3]]</code></li>
<li>子集问题就是输出$C_n^0+C_n^1+C_n^2+…+C_n^n &#x3D; 2^n$个元素的所有子集，例如<code>[1,2,3]</code>的组合有<code>[],[1]</code>、<code>[2]</code>、<code>[3]</code>、<code>[1,2]</code>、<code>[1,3]</code>、<code>[2,3]</code>、<code>[1,2,3]</code>, 或者给定某种条件的子集，如给一个<code>target</code>，输出所有和为<code>target</code>的子集，例如<code>target=3</code>的子集有<code>[[1,2]</code>、<code>[3]]</code></li>
</ul>
<p><strong>可见组合和子集问题本质上就是一类问题，组合只不过是子集问题的一个特例，限制了长度的子集问题</strong>。 回溯算法十分适合解决这类问题，上述三种&#x2F;两类问题的决策树，详见下图。</p>
<h3 id="元素不重复不可复选"><a href="#元素不重复不可复选" class="headerlink" title="元素不重复不可复选"></a>元素不重复不可复选</h3><p>最简单的情况，上述已经讨论过了，直接套用回溯算法的框架就可以了，重点关注排列与组合&#x2F;子集在<code>candidates</code>更新上的区别。</p>
<p><img src="/../images/image-21.png" alt="alt text"></p>
<ul>
<li><a href="https://leetcode.cn/problems/permutations/">Leetcode 46</a> 全排列</li>
<li><a href="https://leetcode.cn/problems/subsets/">Leetcode 78</a> 子集</li>
<li><a href="https://leetcode.cn/problems/combinations/">Leetcode 77</a> 组合</li>
<li><a href="https://leetcode.cn/problems/combination-sum-iii/">Leetcode 216</a> 组合总和 III</li>
</ul>
<h3 id="元素重复不可复选"><a href="#元素重复不可复选" class="headerlink" title="元素重复不可复选"></a>元素重复不可复选</h3><p>最笨比的方法就是全部遍历，添加的时候用哈希表+字符串去重，也能过所有测试。比较聪明的方法是剪枝，下面用剪枝的方法：<br><img src="/../images/image-19.png" alt="alt text"></p>
<ul>
<li><a href="https://leetcode.cn/problems/permutations-ii/">Leetcode 47</a> 全排列 II</li>
<li><a href="https://leetcode.cn/problems/subsets-ii/">Leetcode 90</a> 子集 II</li>
<li><a href="https://leetcode.cn/problems/combination-sum-ii/">Leetcode 40</a> 组合总和 II</li>
</ul>
<h3 id="元素不重复可复选"><a href="#元素不重复可复选" class="headerlink" title="元素不重复可复选"></a>元素不重复可复选</h3><p>由于元素可以重复选，所以决策集不可能为空，树会一直长，所以找出排列是没有意义的，因为上述问题等价于<code>nums = [1,...1,2...2,3...3]</code>的元素重复不可复选问题，排列和子集有无穷多种，但是给定一个<code>target</code>的组合总和问题是有限的，所以我们可以用回溯算法来解决这个问题，重点注意的是<code>candidates</code>的更新方式，即<code>candidates</code>的更新方式是<code>candidates[i:]</code>，而不是<code>candidates[i+1:]</code>因为一个元素是可以重复选的。<br><img src="/../images/image-20.png" alt="alt text"></p>
<ul>
<li><a href="https://leetcode.cn/problems/combination-sum/">Leetcode 39</a> 组合总和</li>
</ul>
<h3 id="元素重复可复选"><a href="#元素重复可复选" class="headerlink" title="元素重复可复选"></a>元素重复可复选</h3><p>… 可复选了还在乎重复吗？等价于 <a href="###%E5%85%83%E7%B4%A0%E4%B8%8D%E9%87%8D%E5%A4%8D%E5%8F%AF%E5%A4%8D%E9%80%89">元素不重复可复选</a></p>
<h2 id="贪心算法解题套路框架"><a href="#贪心算法解题套路框架" class="headerlink" title="贪心算法解题套路框架"></a><a href="https://labuladong.online/algo/essential-technique/greedy/">贪心算法解题套路框架</a></h2><p>贪心算法是指在每一步选择中都采取在当前状态下最好或最优（即最有利）的选择，从而<strong>希望</strong>导致结果是一个全局最好或最优的解。但实际上，贪心算法并不一定能得到全局最优解，贪心算法得到最优解的条件是：<strong>贪心选择性质</strong>和<strong>最优子结构</strong>。</p>
<ul>
<li><strong>贪心选择性质(Greedy Choice Property)</strong>：局部最优解可以推导出全局最优解</li>
<li><strong>最优子结构(Optimal Substructure)</strong>：一个问题的最优解包含其子问题的最优解</li>
</ul>
<p>考虑如下4种情况：</p>
<h3 id="1-具备贪心选择性质和最优子结构"><a href="#1-具备贪心选择性质和最优子结构" class="headerlink" title="1.具备贪心选择性质和最优子结构"></a>1.具备贪心选择性质和最优子结构</h3><p>问题：<strong>[1，100]两种纸币，只能拿3次，求最多拿多少</strong></p>
<ul>
<li><strong>具备贪心选择性质：</strong> 每次最贪的拿，就是最优解为[100,100,100]</li>
<li><strong>具备最优子结构：</strong> 最优的[100,100,100]包含了拿2次的最优解[100,100]和拿1次的最优解[100]</li>
</ul>
<h3 id="2-具备贪心选择性质但不具备最优子结构"><a href="#2-具备贪心选择性质但不具备最优子结构" class="headerlink" title="2.具备贪心选择性质但不具备最优子结构"></a>2.具备贪心选择性质但不具备最优子结构</h3><p>不存在吧？感觉没有</p>
<h3 id="3-不具备贪心选择性质但具备最优子结构"><a href="#3-不具备贪心选择性质但具备最优子结构" class="headerlink" title="3.不具备贪心选择性质但具备最优子结构"></a>3.不具备贪心选择性质但具备最优子结构</h3><p>问题：<strong>DAG的最长路径问题</strong>，例如想计算<code>u</code>到<code>v</code>的最长路径, 如下图</p>
<pre class="mermaid">graph TB
   u --10--> A
   A --2--> B
   B --1--> v
   u --1--> C
   C --1--> D
   A--1-->D
   D --1000--> v</pre>
<ul>
<li><strong>不具备贪心选择性质：</strong> 按照贪心算法的思路，应该选择<code>u-&gt;A-&gt;B-&gt;v</code>，但是实际上<code>u-&gt;A-&gt;D-&gt;v</code>才是最长路径。</li>
<li><strong>具备最优子结构：</strong> <code>u-&gt;A-&gt;D-&gt;v</code>是最优解，包含了u到A的最优解<code>u-&gt;A</code>和u到D的最优解<code>u-&gt;A-&gt;D</code></li>
</ul>
<p><strong>不具备贪心选择性质但具备最优子结构的情况不能用贪心算法来解决</strong></p>
<h3 id="4-不具备贪心选择性质和最优子结构"><a href="#4-不具备贪心选择性质和最优子结构" class="headerlink" title="4.不具备贪心选择性质和最优子结构"></a>4.不具备贪心选择性质和最优子结构</h3><p>问题：TSP</p>
<ul>
<li><p><strong>不具备贪心选择性质：</strong> 每次找没有访问且离当前节点最近的节点不一定是最优解</p>
</li>
<li><p><strong>不具备最优子结构：</strong> 这是肯定的，如果<code>u-&gt;A-&gt;B-&gt;C-&gt;D-&gt;u</code>是最优解，删除D的子问题的最优解不一定为<code>u-&gt;A-&gt;B-&gt;C-&gt;u</code>，可能是<code>u-&gt;B-&gt;A-&gt;C-&gt;u</code>，所以不具备最优子结构</p>
</li>
</ul>
<hr>
<h3 id="贪心算法的解题步骤"><a href="#贪心算法的解题步骤" class="headerlink" title="贪心算法的解题步骤"></a>贪心算法的解题步骤</h3><ul>
<li>没有框架和套路</li>
<li>没必要刻意地识别一道题是否具备贪心选择性质</li>
<li>你只需时刻记住，算法的本质是穷举，遇到任何题目都要先想暴力穷举思路<ul>
<li><strong>超时</strong>说明穷举的过程中如果存在冗余计算，就用memo化来优化</li>
<li><strong>还是超时</strong> 说明穷举的过程中没有冗余计算，说明不需要穷举所有的解空间就能求出最优解，这种情况下肯定需要用到贪心算法。你可以仔细观察题目，是否可以提前排除掉一些不合理的选择，是否可以直接通过局部最优解推导全局最优解。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><ul>
<li><a href="https://leetcode.cn/problems/jump-game/">Leetcode 55*</a> 跳跃游戏<br>直接暴力枚举所有可能：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 暴力枚举</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.res = []</span><br><span class="line">        <span class="variable language_">self</span>.track = []</span><br><span class="line">        <span class="variable language_">self</span>.nums = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">sum</span>(<span class="variable language_">self</span>.track) &gt;= <span class="built_in">len</span>(<span class="variable language_">self</span>.nums) - <span class="number">1</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="variable language_">self</span>.track)</span><br><span class="line">            <span class="variable language_">self</span>.res.append(<span class="variable language_">self</span>.track[:])</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        candidates = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">1</span>, <span class="number">1</span> + <span class="variable language_">self</span>.nums[<span class="built_in">sum</span>(<span class="variable language_">self</span>.track)]))</span><br><span class="line">        <span class="keyword">for</span> candidate <span class="keyword">in</span> candidates:</span><br><span class="line">            <span class="variable language_">self</span>.track.append(candidate)</span><br><span class="line">            <span class="variable language_">self</span>.backtrack()</span><br><span class="line">            <span class="variable language_">self</span>.track.pop()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">canJump</span>(<span class="params">self, nums</span>):</span><br><span class="line">        <span class="variable language_">self</span>.nums = nums</span><br><span class="line">        <span class="variable language_">self</span>.backtrack()</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.res != []</span><br></pre></td></tr></table></figure>
<p>想法是对的，但是TLE，暴力枚举的时间复杂度是O(2^n)，所以我们需要用贪心算法来解决这个问题。</p>
<p>例如对于<code>nums = [2,3,1,1,4]</code>我们的贪心不是每一步都跳最大，i.e. 每一步就跳&#96;&#96;nums[i]<code>，而是我们关心，**别管我具体跳多少，而是我能达到最远的地方是什么，我们用</code>farthest&#96;来表示我们能到达的最远的地方**。 每次贪心前我们看看能不能贪，是不是已经G了</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 贪心算法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">canJump</span>(<span class="params">self, nums </span>)  :</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        farthest = <span class="number">0</span> + nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> idx, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            <span class="keyword">if</span> idx &lt;= farthest:</span><br><span class="line">                farthest = <span class="built_in">max</span>(farthest, idx + num)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<ul>
<li><a href="https://leetcode.cn/problems/jump-game-ii/">Leetcode 45*</a> 跳跃游戏 II<br>同理最为朴素的就是暴力枚举了，把所有的可行解都找出来：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 暴力枚举</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.res = []</span><br><span class="line">        <span class="variable language_">self</span>.track = [] <span class="comment"># 记录每次跳的步数</span></span><br><span class="line">        <span class="variable language_">self</span>.nums = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">sum</span>(<span class="variable language_">self</span>.track) &gt;= <span class="built_in">len</span>(<span class="variable language_">self</span>.nums) - <span class="number">1</span>:</span><br><span class="line">            <span class="variable language_">self</span>.res.append(<span class="variable language_">self</span>.track[:])</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="comment"># 所有可以跳的步数的集合</span></span><br><span class="line">        <span class="comment"># 这里倒序是因为想让他往原处跳，其实没啥用</span></span><br><span class="line">        <span class="comment"># 因为整个递归树都要被遍历</span></span><br><span class="line">        candidates = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">1</span>, <span class="number">1</span> + <span class="variable language_">self</span>.nums[<span class="built_in">sum</span>(<span class="variable language_">self</span>.track)]))[::-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> candidate <span class="keyword">in</span> candidates:</span><br><span class="line">            <span class="variable language_">self</span>.track.append(candidate)</span><br><span class="line">            <span class="variable language_">self</span>.backtrack()</span><br><span class="line">            <span class="variable language_">self</span>.track.pop()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">jump</span>(<span class="params">self, nums</span>):</span><br><span class="line">        <span class="variable language_">self</span>.nums = nums</span><br><span class="line">        <span class="variable language_">self</span>.backtrack()</span><br><span class="line">        <span class="built_in">print</span>(<span class="variable language_">self</span>.res)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>([<span class="built_in">len</span>(_) <span class="keyword">for</span> _ <span class="keyword">in</span>  <span class="variable language_">self</span>.res])</span><br></pre></td></tr></table></figure>
<p>上述方法暴力回溯了所有可能解，把所有的可行解都保存了下来，最后返回了长度最小的解，时间复杂度是O(2^n)，TLE了。不难观察到这个问题有重叠子问题的性质，我们定义<br>$$<br>dp[i] &#x3D; \text{从位置 i 到达最后一个位置所需的最少跳跃次数}<br>$$<br>对于问题给定的第一个测样例<code>nums = [2,3,1,1,4]</code>,不难看出，原问题的答案就是<code>dp[0]</code>,我们先看一下<code>dp[4] = 0</code>，因为已经到达了最后一个位置，所以<code>dp[4] = 0</code>。然后我们看<code>dp[3] = 1</code>，因为从<code>3-&gt;4</code>只需要跳一次，所以<code>dp[3] = 1</code>。接下来我们看<code>dp[2] = 1 + min(dp[3]) = 2</code>，因为2只能到达3，所以<code>dp[2] = 1 + min(dp[3]) = 2</code>。接下来我们看<code>dp[1] = 1 + min(dp[2], dp[3]，dp[4]) = 1 + min(2, 1, 0) = 1 + 0 = 1</code>。最后我们看<code>dp[0] = 1 + min(dp[1], dp[2]) = 1 + min(1, 2) = 1 + 1 = 2</code>。所以我们可以得到<code>dp[0] = 2</code>，即从<code>0-&gt;1-&gt;4</code>只需要跳两次。其状态转移方程为：<br>$$<br>dp[i] &#x3D; 1 + min(dp[i+1], dp[i+2], …, dp[i+nums[i]])<br>$$</p>
<p>基于上述dp的方法+memo的优化，我们可以得到如下的代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 动态规划+memo化</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.nums = <span class="literal">None</span></span><br><span class="line">        <span class="variable language_">self</span>.n = <span class="literal">None</span></span><br><span class="line">        <span class="variable language_">self</span>.memo = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dp</span>(<span class="params">self, idx</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        从idx跳到self.nums的末尾的步数</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> idx <span class="keyword">in</span> <span class="variable language_">self</span>.memo:</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">self</span>.memo[idx]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> idx &gt;= <span class="variable language_">self</span>.n - <span class="number">1</span>:</span><br><span class="line">            <span class="variable language_">self</span>.memo[idx] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># assert 0&lt;= idx &lt;self.n</span></span><br><span class="line">        <span class="keyword">elif</span> <span class="variable language_">self</span>.nums[idx] == <span class="number">0</span>:</span><br><span class="line">            <span class="variable language_">self</span>.memo[idx] = <span class="number">2</span> ** <span class="number">31</span> - <span class="number">1</span> <span class="comment"># 无解</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># assert self.nums[idx] &gt;= 1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="variable language_">self</span>.memo[idx] = <span class="number">1</span> + <span class="built_in">min</span>([<span class="variable language_">self</span>.dp(_) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(idx + <span class="number">1</span>, idx + <span class="variable language_">self</span>.nums[idx] + <span class="number">1</span>)])</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.memo[idx]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">jump</span>(<span class="params">self, nums</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="variable language_">self</span>.nums = nums</span><br><span class="line">        <span class="variable language_">self</span>.n = <span class="built_in">len</span>(<span class="variable language_">self</span>.nums)</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.dp(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p><img src="/../images/image-22.png" alt="alt text"><br>上图这种情况，我们站在索引 0 的位置，可以向前跳 1，2 或 3 步，你说应该选择跳多少呢？</p>
<p>你可以确定地说，<strong>应该跳 2 步调到索引 2，因为 nums[2] 的可跳跃区域涵盖了索引区间 [3..6]，比其他的都大。题目求最少的跳跃次数，那么往索引 2 跳必然是最优的选择。这就是贪心选择性质，</strong></p>
<p>我们不需要真的递归穷举出所有选择的具体结果来比较求最值，而只需要每次选择那个最有潜力的局部最优解，最终就能得到全局最优解。针对上述的贪心策略，我们可以得到如下的代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">jump</span>(<span class="params">self, nums</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        jumps_cnt, curr_pos = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> curr_pos &lt; n - <span class="number">1</span>:</span><br><span class="line">            <span class="comment"># 下一次可以跳到的位置</span></span><br><span class="line">            choices = [choice <span class="keyword">for</span> choice <span class="keyword">in</span> <span class="built_in">range</span>(curr_pos + <span class="number">1</span>, <span class="built_in">min</span>(curr_pos + nums[curr_pos] + <span class="number">1</span>, n))]</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 直接跳过去了，避免出现nums = [2,100000,1]第一下不跳过去，选择跳到1</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">max</span>(choices) &gt;= n - <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> jumps_cnt + <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 加上跳到c后可以最远跳到的位置</span></span><br><span class="line">            choices = [(c + nums[c], c) <span class="keyword">for</span> c <span class="keyword">in</span> choices]</span><br><span class="line">            choices.sort(reverse=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">            curr_pos = choices[<span class="number">0</span>][<span class="number">1</span>]</span><br><span class="line">            jumps_cnt += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> jumps_cnt</span><br></pre></td></tr></table></figure>






<h2 id="分治算法解题套路框架"><a href="#分治算法解题套路框架" class="headerlink" title="分治算法解题套路框架"></a><a href="https://labuladong.online/algo/essential-technique/divide-and-conquer/">分治算法解题套路框架</a></h2><h3 id="分治思想"><a href="#分治思想" class="headerlink" title="分治思想"></a>分治思想</h3><p>分治的思想广泛的存在算法当中：</p>
<ul>
<li>递归：将一个问题分解为多个子问题，递归地解决每个子问题，然后将它们的解合并起来，eg. fibonacci数列</li>
<li>动划：动态规划的递归形式自不必多说，自底向上的也是分治的思想，从base case开始，逐步向上推导出原问题的解</li>
<li>回溯：回溯似乎不算是某种分治思想，但是硬要说有分治也行，因为将整体解分了若干层，先选第一步，然后再选第二步，直到选完所有的步骤，最后再回溯到第一步，选第二步，直到选完所有的步骤，也算是分治的思想吧？</li>
</ul>
<p>有分治思想的算法很多，但不是分治算法，<strong>分治算法与上述有分治思想的算法有本质的区别！</strong></p>
<h3 id="分治算法"><a href="#分治算法" class="headerlink" title="分治算法"></a>分治算法</h3><p>一般分为三步：</p>
<ul>
<li><strong>分解</strong>：将原问题分解为若干个子问题，通常是相同类型的子问题</li>
<li><strong>解决</strong>：递归地解决每个子问题，直到子问题足够小，可以直接求解</li>
<li><strong>合并</strong>：将子问题的解合并成原问题的解</li>
</ul>
<p>伪代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">divide_conquer</span>(<span class="params">problem</span>):</span><br><span class="line">    <span class="comment"># 递归终止条件</span></span><br><span class="line">    <span class="keyword">if</span> problem <span class="keyword">is</span> small enough:</span><br><span class="line">        <span class="keyword">return</span> solution</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 分解子问题</span></span><br><span class="line">    subproblems = split_problem(problem)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 递归解决子问题</span></span><br><span class="line">    subresult1 = divide_conquer(subproblems[<span class="number">0</span>])</span><br><span class="line">    subresult2 = divide_conquer(subproblems[<span class="number">1</span>])</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 合并结果</span></span><br><span class="line">    result = merge(subresult1, subresult2)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<p>分治的子问题如果不独立，i.e. 存在重叠子问题的情况，那么这个时候用分治就有点低效了，要用动态规划或者memo递归了。</p>
<h4 id="无效的分治算法"><a href="#无效的分治算法" class="headerlink" title="无效的分治算法"></a>无效的分治算法</h4><p>基于上面有分治思想的的几个例子，我们发现</p>
<ul>
<li><strong>1.分治是广泛存在的</strong></li>
<li><strong>2. 分治思想不一定减小复杂度</strong> 例如：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 没有分治思想的算法，复杂度为O(n)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sum</span>(<span class="params">nums</span>)-&gt; <span class="built_in">int</span>:</span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">        res += num</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 有分治思想但不减小复杂度的算法，递归树的高度为n，宽度为1，遍历节点数量为n，复杂度为O(n)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sum</span>(<span class="params">nums</span>)-&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">return</span> nums[<span class="number">0</span>] + <span class="built_in">sum</span>(nums[<span class="number">1</span>:])</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 有分治思想但不减小复杂度的算法，加上二分的思想，递归树的高度为log(n)，宽度不为1，遍历节点数量为n，复杂度为O(nlog(n))</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sum</span>(<span class="params">nums</span>)-&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">    mid = <span class="built_in">len</span>(nums) // <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span>(nums[:mid]) + <span class="built_in">sum</span>(nums[mid:])</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>再者用二分的方式进行分治可以将递归树的深度从O(n)减少到O(logn)，但是宽度不为1，遍历节点数量为n，所以复杂度为O(N),而不是O(logn)</strong> 确实有优化效果。对于上面这个元素求和的例子，无论怎么分治都不如原解法高效，但可以看出二分的分治方式是确实有助于减少递归树的高度。</li>
</ul>
<h4 id="有效的分治"><a href="#有效的分治" class="headerlink" title="有效的分治"></a>有效的分治</h4><p>把递归算法抽象成递归树，<strong>如果递归树节点的时间复杂度和树的深度相关，那么使用分治思想对问题进行二分</strong>就可以使递归树尽可能平衡，进而优化总的时间复杂度。对于一个原复杂度为O(n^2)的算法，我们分成m个小问题<br>$$<br>n^2 &gt; (n&#x2F;m)^2 + … + (n&#x2F;m)^2 &#x3D; n^2&#x2F;m<br>$$<br>做一个如下的试验，插入排序的复杂度为O(n^2)，我们可以将其分成5个桶，确实要快一些：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">insertion_sort</span>(<span class="params">nums</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i, <span class="number">0</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> nums[j] &lt; nums[j - <span class="number">1</span>]:</span><br><span class="line">                nums[j], nums[j - <span class="number">1</span>] = nums[j - <span class="number">1</span>], nums[j]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bucket_sort</span>(<span class="params">arr, bucket_size=<span class="number">5</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;桶排序</span></span><br><span class="line"><span class="string">    :param arr: 输入数组</span></span><br><span class="line"><span class="string">    :param bucket_size: 每个桶的大小（默认5）</span></span><br><span class="line"><span class="string">    :return: 排序后的数组</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(arr) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> arr</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 确定数据的范围</span></span><br><span class="line">    min_val, max_val = <span class="built_in">min</span>(arr), <span class="built_in">max</span>(arr)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算需要的桶数量</span></span><br><span class="line">    bucket_count = (max_val - min_val) // bucket_size + <span class="number">1</span></span><br><span class="line">    buckets = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(bucket_count)]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将数据分配到各个桶中</span></span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> arr:</span><br><span class="line">        index = (num - min_val) // bucket_size</span><br><span class="line">        buckets[index].append(num)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 对每个桶进行插入排序，并合并结果</span></span><br><span class="line">    sorted_arr = []</span><br><span class="line">    <span class="keyword">for</span> bucket <span class="keyword">in</span> buckets:</span><br><span class="line">        insertion_sort(bucket)  <span class="comment"># 使用插入排序</span></span><br><span class="line">        sorted_arr.extend(bucket)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sorted_arr</span><br><span class="line"></span><br><span class="line">nums = [random.randint(<span class="number">0</span>, <span class="number">100</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10000</span>)]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">start = time.time()</span><br><span class="line">insertion_sort(nums[:])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;插入排序耗时：&quot;</span>, time.time() - start)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">start = time.time()</span><br><span class="line">bucket_sort(nums[:])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;桶排序耗时：&quot;</span>, time.time() - start)</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">插入排序耗时： <span class="number">4.030400514602661</span></span><br><span class="line">桶排序耗时： <span class="number">0.14693975448608398</span></span><br></pre></td></tr></table></figure>
<p>差了30倍，确实是有分治的效果。<strong>感觉就是多掏一些分解和合并的世界，减小求解的时间，从而整体上提高效率。</strong></p>
<h2 id="算法时空复杂度分析实用指南"><a href="#算法时空复杂度分析实用指南" class="headerlink" title="算法时空复杂度分析实用指南"></a><a href="https://labuladong.online/algo/essential-technique/complexity-analysis/">算法时空复杂度分析实用指南</a></h2><h3 id="借助复杂度反推解题思路"><a href="#借助复杂度反推解题思路" class="headerlink" title="借助复杂度反推解题思路"></a>借助复杂度反推解题思路</h3><blockquote>
<p>不要以为复杂度分析是专门用来难为你的，它其实是来帮你的，它是来偷偷告诉你解题思路的。</p>
</blockquote>
<p>你应该在开始写代码之前就留意题目给的数据规模,例如给定一个<code>n=10^6</code></p>
<ul>
<li>你给一个O(2^n)的算法，肯定会TLE，因为<code>2^10^6</code>是个天文数字</li>
<li>你给一个O(n^2)的算法，可能会TLE，因为<code>10^6*10^6=10^12</code>,实际上到<code>10^4</code>的问题规模就很可能要TLE了<ul>
<li>得提供一个O(nlogn)的算法，或者O(n)的算法,想想对数组进行排序处理、前缀和、双指针、一维 dp 等等，从这些思路切入就比较靠谱。</li>
<li>像嵌套 for 循环、二维 dp、回溯算法这些思路，基本可以直接排除掉了</li>
</ul>
</li>
</ul>
<p>如果给你的<strong>问题规模比较小则说明肯定是因为最优解就是指数&#x2F;阶乘级别的复杂度</strong>。你放心用回溯算法，不用想别的算法了。</p>
<h3 id="Big-O-Notation"><a href="#Big-O-Notation" class="headerlink" title="Big-O Notation"></a>Big-O Notation</h3><p>Big-O 的严格定义是：<br>$$<br>O(f(n)) &#x3D; {g(n) | \exists c&gt;0, n_0&gt;0, \forall n&gt;n_0, g(n) \leq c*f(n)}<br>$$<br>所以其实是一个集合，表示所有的函数 g(n) 都是 O(f(n)) 的，比如：<br>$$<br>sin(n) + log(n) +1000n^2 \in O(1+0.3n+0.5n^2+2^n)<br>$$<br>Big-O的只能表示上届，且这个上届是不是紧致的不知道，一个复杂度为$O(n^2)$的算法，我们可以说它是$O(2^n)$的算法，但是我们不能说它是O(nlogn)的算法, 但一般不会夸大其上届。对于递归算法的复杂度，估计起来比较困难，可能估算到一个非常宽松的上届，例如之前的找零钱的例子，定义amount为N，有K个硬币。最坏的条件：</p>
<ul>
<li>都是1块的硬币，树高为N</li>
<li>每次都是满叉树，每个节点都K个子节点<br>最终的复杂度为$O(K^N)$这显然是个非常宽松的上届</li>
</ul>
<h3 id="非递归算法的复杂度"><a href="#非递归算法的复杂度" class="headerlink" title="非递归算法的复杂度"></a>非递归算法的复杂度</h3><p>最朴素的算法复杂度分析，有k层循环就是$O(N^k)$，但也不一定，<strong>对于双指针（左右指针，快慢指针）等就不能数循环嵌套次数</strong></p>
<h3 id="递归算法的复杂度"><a href="#递归算法的复杂度" class="headerlink" title="递归算法的复杂度"></a>递归算法的复杂度</h3><blockquote>
<ul>
<li>递归算法的时间复杂度 &#x3D; 递归的次数 x 每次递归的时间复杂度 &#x3D; 递归树的节点个数 x 每个节点的时间复杂度</li>
<li>递归算法的空间复杂度 &#x3D; 递归树的高度 + 算法申请的存储空间</li>
</ul>
</blockquote>
<p>对于递归算法的空间复杂度之所以要考虑到递归树的高度，是因为函数递归的原理是操作系统维护的函数堆栈，所以递归栈的空间消耗也需要算在空间复杂度之内，如下图所示：</p>
<p><img src="/../images/image-23.png" alt="alt text"></p>
<hr>
<h4 id="递归算法复杂度分析：以凑硬币为例"><a href="#递归算法复杂度分析：以凑硬币为例" class="headerlink" title="递归算法复杂度分析：以凑硬币为例"></a>递归算法复杂度分析：以凑硬币为例</h4><p>接下来我们通过分析凑硬币的例子来分析递归算法的复杂度，我们从:</p>
<ul>
<li>自定向下的递归算法</li>
<li>自顶向下的递归算法+memo化</li>
<li>自底向上的动态规划算法</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 凑硬币,没有memo化的递归算法</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dp</span>(<span class="params">coins: <span class="type">List</span>[<span class="built_in">int</span>], amount: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="comment"># base case</span></span><br><span class="line">    <span class="keyword">if</span> amount == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> amount &lt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    res = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">    <span class="comment"># 时间 O(K)</span></span><br><span class="line">    <span class="keyword">for</span> coin <span class="keyword">in</span> coins:</span><br><span class="line">        sub_problem = dp(coins, amount - coin)</span><br><span class="line">        <span class="keyword">if</span> sub_problem == -<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        res = <span class="built_in">min</span>(res, sub_problem + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span> <span class="keyword">if</span> res == <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>) <span class="keyword">else</span> res</span><br></pre></td></tr></table></figure>
<p>首先看递归树高度的最差情况为$O(N)$，其中N为amount的大小，最差情况发生着coins都是1的情况。再者我们看递归树节点的数量，假设都是$K$满叉树，树的高度为$N$，所以节点的数量为$O(K^N)$。那么其空间与时间复杂度为：</p>
<ul>
<li>空间复杂度&#x3D;递归树的高度 + 算法申请的存储空间&#x3D;O(N) + O(1) &#x3D; O(N)</li>
<li>时间复杂度&#x3D;递归树的节点个数 x 每个节点的时间复杂度&#x3D;O(K^N) x O(K) &#x3D; O(K^(N+1))<ul>
<li>之所以每个节点的时间复杂度为O(K)是因为<code>for coin in coins:</code>这一行的时间复杂度为O(K)</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">self</span>.memo = &#123;<span class="number">0</span>: <span class="number">0</span>&#125; <span class="comment"># memo化</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dp</span>(<span class="params">coins: <span class="type">List</span>[<span class="built_in">int</span>], amount: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="keyword">if</span> amount <span class="keyword">in</span> <span class="variable language_">self</span>.memo:</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.memo[amount]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># base case</span></span><br><span class="line">    <span class="keyword">if</span> amount &lt; <span class="number">0</span>:</span><br><span class="line">        <span class="variable language_">self</span>.memo[amount] = -<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    res = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">    <span class="comment"># 时间 O(K)</span></span><br><span class="line">    <span class="keyword">for</span> coin <span class="keyword">in</span> coins:</span><br><span class="line">        sub_problem = dp(coins, amount - coin)</span><br><span class="line">        <span class="keyword">if</span> sub_problem == -<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        res = <span class="built_in">min</span>(res, sub_problem + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">self</span>.memo[amount] = -<span class="number">1</span> <span class="keyword">if</span> res == <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>) <span class="keyword">else</span> res</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">self</span>.memo[amount]</span><br></pre></td></tr></table></figure>
<p>首先看递归树高度的最差情况为$O(N)$。再者我们看递归树节点的数量，这种情况，最多递归$N$次，那么其空间与时间复杂度为：</p>
<ul>
<li>空间复杂度&#x3D;递归树的高度 + 算法申请的存储空间&#x3D;O(N) + O(N) &#x3D; O(N)<ul>
<li>递归树的高度为O(N)，coins都为1的情况，递归树的高度为N</li>
<li>算法申请的存储空间为O(N)，因为我们需要一个大小为N的memo的字典来存储中间结果</li>
</ul>
</li>
<li>时间复杂度&#x3D;递归树的节点个数 x 每个节点的时间复杂度&#x3D;O(N) x O(K) &#x3D; O(NK)<ul>
<li>之所以每个节点的时间复杂度为O(K)是因为<code>for coin in coins:</code>这一行的时间复杂度为O(K)</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 凑硬币,动态规划算法,自底向上</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">coinChange</span>(<span class="params">coins: <span class="type">List</span>[<span class="built_in">int</span>], amount: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="comment"># 空间 O(N)</span></span><br><span class="line">    dp = [amount + <span class="number">1</span>] * (amount + <span class="number">1</span>)</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 时间 O(KN)</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(dp)):</span><br><span class="line">        <span class="keyword">for</span> coin <span class="keyword">in</span> coins:</span><br><span class="line">            <span class="keyword">if</span> i - coin &lt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            dp[i] = <span class="built_in">min</span>(dp[i], <span class="number">1</span> + dp[i - coin])</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span> <span class="keyword">if</span> dp[amount] == amount + <span class="number">1</span> <span class="keyword">else</span> dp[amount]</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度&#x3D;O(KN)，其中K为coins的大小，N为amount的大小</li>
<li>空间复杂度&#x3D;O(N)，因为我们需要一个大小为N的dp的数组来存储中间结果，<strong>减小了空间复杂度，相较于递归</strong></li>
</ul>
<h4 id="递归算法复杂度分析：以全排列和子集为例"><a href="#递归算法复杂度分析：以全排列和子集为例" class="headerlink" title="递归算法复杂度分析：以全排列和子集为例"></a>递归算法复杂度分析：以全排列和子集为例</h4><p>在<a href="###%E5%85%83%E7%B4%A0%E4%B8%8D%E9%87%8D%E5%A4%8D%E4%B8%8D%E5%8F%AF%E5%A4%8D%E9%80%89">回溯算法解决全排列和子集问题的章节</a>中，我们详细介绍了回溯算法，下面探究一下其复杂度，如下图所示，我们定义N为<code>len(nums)</code>。</p>
<p><img src="/../images/image-21.png" alt="alt text"></p>
<h5 id="全排列的复杂度分析"><a href="#全排列的复杂度分析" class="headerlink" title="全排列的复杂度分析"></a>全排列的复杂度分析</h5><p>首先树的高度为N，递归树总的节点个数为$P(N, 0)+P(N, 1) + P(N, 2) + … + P(N, N)$，其中$P(N, k) &#x3D; \frac{N!}{(N-k)!}$表示从N个元素中选出k个元素的排列数。</p>
<ul>
<li>空间复杂度&#x3D;递归树的高度 + 算法申请的存储空间 &#x3D; $O(N) + O(N\times N!) &#x3D; O(N\times N!)$<ul>
<li>递归树的高度为$O(N)$，因为我们最多递归N次</li>
<li>算法申请的存储空间为 $O(N\times N!)$,每个结果为N，有N!个结果</li>
</ul>
</li>
<li>时间复杂度&#x3D;递归树的节点个数 x 每个节点的时间复杂度 &#x3D; $O(N) \times O(N\times N!) &#x3D; O(N^2\times N!)$<ul>
<li>每个节点的时间复杂度的上届为O(N)</li>
<li>递归树的节点个数为$P(N, 0)+P(N, 1) + P(N, 2) + … + P(N, N)&lt; N<em>P(N, N) &#x3D; N</em>N!$</li>
</ul>
</li>
</ul>
<h5 id="子集的复杂度分析"><a href="#子集的复杂度分析" class="headerlink" title="子集的复杂度分析"></a>子集的复杂度分析</h5><p>对于子集问题，递归树的高度为N，递归树的节点个数为$C(N, 0)+C(N, 1) + C(N, 2) + … + C(N, N)&#x3D;2^N$，其中$C(N, k) &#x3D; \frac{N!}{k!(N-k)!}$表示从N个元素中选出k个元素的组合数。</p>
<ul>
<li>空间复杂度&#x3D;递归树的高度 + 算法申请的存储空间 &#x3D; $O(N) + O(N\times 2^N) &#x3D; O(N\times 2^N)$<ul>
<li>递归树的高度为$O(N)$，因为我们最多递归N次</li>
<li>算法申请的存储空间为 $O(N\times 2^N)$,每个结果为N，有$2^N$个结果</li>
</ul>
</li>
<li>时间复杂度&#x3D;递归树的节点个数 x 每个节点的时间复杂度 &#x3D; $O(N) \times O(2^N) &#x3D; O(N\times 2^N)$<ul>
<li>每个节点的时间复杂度的上届为O(N)</li>
<li>递归树的节点个数为$C(N, 0)+C(N, 1) + C(N, 2) + … + C(N, N)&#x3D;2^N$</li>
</ul>
</li>
</ul>
<h3 id="数据结构的算法分析"><a href="#数据结构的算法分析" class="headerlink" title="数据结构的算法分析"></a>数据结构的算法分析</h3><p>分析数据结构 API 的时间复杂度和分析普通算法函数的时间复杂度稍微有一些区别，因为数据结构是会动态变化的。如动态数组的<code>push_back</code>操作，时间复杂度是 O(1)，但是如果动态数组的容量不够了，就需要扩容，时间复杂度就变成了 O(n)。哈希表的<code>put</code>操作，时间复杂度是 O(1)，但是如果哈希冲突了，需要rehash，时间复杂度就变成了 O(n)。</p>
<p>如果想衡量数据结构类中的某个方法的时间复杂度，<strong>不能简单地看最坏或者最好的时间复杂度，而应该看摊还（平均）时间复杂度</strong></p>
]]></content>
      <categories>
        <category>labuladong算法笔记</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>排序算法</tag>
        <tag>cpp</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>华为入职培训-现代cpp实战-2025</title>
    <url>/2025/04/29/%E5%8D%8E%E4%B8%BA%E5%85%A5%E8%81%8C%E5%9F%B9%E8%AE%AD-%E7%8E%B0%E4%BB%A3cpp%E5%AE%9E%E6%88%98-2025/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>软件雏鹰计划</category>
      </categories>
      <tags>
        <tag>cpp</tag>
        <tag>华为</tag>
      </tags>
  </entry>
  <entry>
    <title>labuladong-入门-编程语言基础及练习</title>
    <url>/2025/04/23/labuladong-%E5%85%A5%E9%97%A8-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%8F%8A%E7%BB%83%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>本笔记是主要通过学习<a href="https://labuladong.online/algo/">labuladong的算法笔记</a>, 开始时间是2025&#x2F;03&#x2F;31。</p>
<h1 id="入门：编程语言基础及练习"><a href="#入门：编程语言基础及练习" class="headerlink" title="入门：编程语言基础及练习"></a><a href="https://labuladong.online/algo/menu/">入门：编程语言基础及练习</a></h1><blockquote>
<p>本章就主要看了一下C++，刷了如下的题单<br><a href="https://leetcode.cn/problems/two-sum/">1.两数之和</a><br><a href="https://leetcode.cn/problems/contains-duplicate/">217.存在重复元素</a><br><a href="https://leetcode.cn/problems/single-number/">136.只出现一次的数字</a><br><a href="https://leetcode.cn/problems/valid-parentheses/">20.有效的括号</a><br><a href="https://leetcode.cn/problems/time-needed-to-buy-tickets/">2073. 买票需要的时间。</a></p>
</blockquote>
<h2 id="C-语言基础"><a href="#C-语言基础" class="headerlink" title="C++ 语言基础"></a><a href="https://labuladong.online/algo/programming-language-basic/cpp/">C++ 语言基础</a></h2><p>重点是看了一下C++的语法</p>
<h3 id="Vector-动态数组"><a href="#Vector-动态数组" class="headerlink" title="Vector 动态数组"></a>Vector 动态数组</h3><p>常见的方法汇总为表格，以<code>vector&lt;int&gt; nums&#123;0,1,2,3,4,5&#125;</code>为例：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
<th>复杂度</th>
</tr>
</thead>
<tbody><tr>
<td><code>nums.size()</code></td>
<td>获取数组大小</td>
<td>O(1)</td>
</tr>
<tr>
<td><code>nums.empty()</code></td>
<td>判断数组是否为空</td>
<td>O(1)</td>
</tr>
<tr>
<td><code>nums.push_back(6)</code></td>
<td>在末尾添加元素</td>
<td>O(1)</td>
</tr>
<tr>
<td><code>nums.pop_back()</code></td>
<td>删除末尾元素</td>
<td>O(1)</td>
</tr>
<tr>
<td><code>nums.front()</code></td>
<td>获取第一个元素</td>
<td>O(1)</td>
</tr>
<tr>
<td><code>nums.back()</code></td>
<td>获取最后一个元素</td>
<td>O(1)</td>
</tr>
<tr>
<td><code>nums.insert(nums.begin() + 2, 10)</code></td>
<td>在指定位置插入元素</td>
<td>O(n)</td>
</tr>
<tr>
<td><code>nums.erase(nums.begin() + 2)</code></td>
<td>删除指定位置元素</td>
<td>O(n)</td>
</tr>
<tr>
<td><code>swap(nums[0], nums[1])</code></td>
<td>交换两个元素</td>
<td>O(1)</td>
</tr>
<tr>
<td><code>nums.begin()</code></td>
<td>获取迭代器</td>
<td>O(1)</td>
</tr>
<tr>
<td><code>nums.end()</code></td>
<td>获取迭代器</td>
<td>O(1)</td>
</tr>
</tbody></table>
<p>对于数组的遍历</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 下角标遍历</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line"> cout &lt;&lt; nums[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代器遍历</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = nums.<span class="built_in">begin</span>(); it != nums.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line"> cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 范围for遍历, 类似于python的for num in nums</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> num : nums) &#123;</span><br><span class="line"> cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h3 id="双链表list"><a href="#双链表list" class="headerlink" title="双链表list"></a>双链表list</h3><p>常见的方法汇总为表格，以<code>list&lt;int&gt; lst&#123;0,1,2,3,4,5&#125;</code>为例：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
<th>复杂度</th>
</tr>
</thead>
<tbody><tr>
<td><code>lst.size()</code></td>
<td>获取链表大小</td>
<td>O(n)</td>
</tr>
<tr>
<td><code>lst.empty()</code></td>
<td>判断链表是否为空</td>
<td>O(1)</td>
</tr>
<tr>
<td><code>lst.push_back(6)</code></td>
<td>在末尾添加元素</td>
<td>O(1)</td>
</tr>
<tr>
<td><code>lst.push_front(6)</code></td>
<td>在头部添加元素</td>
<td>O(1)</td>
</tr>
<tr>
<td><code>lst.pop_back()</code></td>
<td>删除末尾元素</td>
<td>O(1)</td>
</tr>
<tr>
<td><code>lst.pop_front()</code></td>
<td>删除头部元素</td>
<td>O(1)</td>
</tr>
<tr>
<td><code>auto it = lst.begin();advance(it, 2); lst.insert(it, 10)</code></td>
<td>在指定位置插入元素</td>
<td>O(n)</td>
</tr>
<tr>
<td><code>auto it = lst.begin();advance(it, 2); lst.erase(it)</code></td>
<td>删除指定位置元素</td>
<td>O(n)</td>
</tr>
</tbody></table>
<p>对于链表的遍历</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 迭代器遍历</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = lst.<span class="built_in">begin</span>(); it != lst.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line"> cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 范围for遍历, 类似于python的for num in lst</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> val : lst) &#123;</span><br><span class="line"> cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h3 id="队列queue与栈stack"><a href="#队列queue与栈stack" class="headerlink" title="队列queue与栈stack"></a>队列queue与栈stack</h3><p>queue和stack都是基于双链表实现的，都支持push和pop操作，push都是从尾部添加元素，queue的pop是从头部删除元素，stack的pop是从尾部删除元素，且stack支持top操作，获取栈顶元素。两个的遍历方式是一样的，都是使用迭代器遍历。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 队列的遍历</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = que.<span class="built_in">begin</span>(); it != que.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line"> cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 栈的遍历</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = sta.<span class="built_in">begin</span>(); it != sta.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line"> cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="哈希表-unordered-map"><a href="#哈希表-unordered-map" class="headerlink" title="哈希表 unordered_map"></a>哈希表 unordered_map</h3><p>以<code>unordered_map&lt;int, string&gt; hashmap&#123;&#123;1, "one"&#125;, &#123;2, "two"&#125;, &#123;3, "three"&#125;&#125;;</code>为例：<br>常见的方法汇总为表格：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
<th>复杂度</th>
</tr>
</thead>
<tbody><tr>
<td><code>hashmap.size()</code></td>
<td>获取哈希表大小</td>
<td>O(1)</td>
</tr>
<tr>
<td><code>hashmap.empty()</code></td>
<td>判断哈希表是否为空</td>
<td>O(1)</td>
</tr>
<tr>
<td><code>hashmap[4]</code></td>
<td>获取指定key的值，此key不存在时会插入一个key为4，值为””的元素</td>
<td>O(1)</td>
</tr>
<tr>
<td><code>hashmap.contains(4)</code></td>
<td>判断key是否存在</td>
<td>O(1)</td>
</tr>
<tr>
<td><code>hashmap[&quot;5&quot;]=&quot;five&quot;</code></td>
<td>插入元素</td>
<td>O(1)</td>
</tr>
<tr>
<td><code>hashmap.erase(4)</code></td>
<td>删除指定key的元素</td>
<td>O(1)</td>
</tr>
</tbody></table>
<p>对于哈希表的遍历</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 键值对遍历，pair是一个pair类型的值，拷贝了一份，效率低</span></span><br><span class="line"><span class="keyword">for</span> （<span class="keyword">auto</span> pair : hashmap） &#123;</span><br><span class="line"> cout &lt;&lt; pair.first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; pair.second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 键值对遍历， &amp;pair是一个pair类型的引用，避免拷贝，推荐使用</span></span><br><span class="line"><span class="keyword">for</span> （<span class="keyword">auto</span> &amp;pair : hashmap） &#123;</span><br><span class="line"> cout &lt;&lt; pair.first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; pair.second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 键值对遍历， const auto &amp;pair是一个pair类型的引用，避免拷贝，且pair是常量，不能修改</span></span><br><span class="line"><span class="keyword">for</span> （<span class="type">const</span> <span class="keyword">auto</span> &amp;pair : hashmap） &#123;</span><br><span class="line"> cout &lt;&lt; pair.first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; pair.second &lt;&lt; endl;</span><br><span class="line"> <span class="comment">// pair.first = 4; // 错误，pair是常量，不能修改</span></span><br><span class="line"> <span class="comment">// pair.second = &quot;xour&quot;; // 错误，pair是常量，不能修改</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用结构化绑定</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [key, value] : umap) &#123;</span><br><span class="line"> std::cout &lt;&lt; <span class="string">&quot;Key: &quot;</span> &lt;&lt; key &lt;&lt; <span class="string">&quot;, Value: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用迭代器遍历</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = hashmap.<span class="built_in">begin</span>(); it != hashmap.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line"> cout &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="哈希集合unordered-set"><a href="#哈希集合unordered-set" class="headerlink" title="哈希集合unordered_set"></a>哈希集合unordered_set</h3><p>以<code>unordered_set&lt;int&gt; hashset&#123;1, 2, 3, 4, 5&#125;;</code>为例：<br>常见的方法汇总为表格：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
<th>复杂度</th>
</tr>
</thead>
<tbody><tr>
<td><code>hashset.size()</code></td>
<td>获取哈希表大小</td>
<td>O(1)</td>
</tr>
<tr>
<td><code>hashset.empty()</code></td>
<td>判断哈希表是否为空</td>
<td>O(1)</td>
</tr>
<tr>
<td><code> </code>hashset.contains(4)&#96;</td>
<td>判断key是否存在</td>
<td>O(1)</td>
</tr>
<tr>
<td><code>hashset.insert(6)</code></td>
<td>插入元素</td>
<td>O(1)</td>
</tr>
<tr>
<td><code>hashset.erase(4)</code></td>
<td>删除指定key的元素</td>
<td>O(1)</td>
</tr>
</tbody></table>
<p>利用vector构造unordered_set</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; nums&#123;<span class="number">1</span>,<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="function">unordered_set&lt;<span class="type">int</span>&gt; <span class="title">hashset</span><span class="params">(nums.begin(), nums.end())</span></span>;</span><br></pre></td></tr></table></figure>


<p>对于哈希集合的遍历</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;element : hashset) &#123;</span><br><span class="line"> cout &lt;&lt; element &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="字符串string"><a href="#字符串string" class="headerlink" title="字符串string"></a>字符串string</h3><p>C++中字符串本质上是一个动态数组，底层实现是一个字符数组，且字符串的长度是动态的，可以随时改变。<br>常见的方法汇总为表格：以<code>string str = &quot;hello world&quot;;</code>为例：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
<th>复杂度</th>
</tr>
</thead>
<tbody><tr>
<td><code>str.size()</code></td>
<td>获取字符串大小</td>
<td>O(1)</td>
</tr>
<tr>
<td><code>str[0]</code></td>
<td>获取第一个字符</td>
<td>O(1)</td>
</tr>
<tr>
<td><code>s1.insert(0, &quot;x&quot;)</code></td>
<td>在指定位置插入字符串</td>
<td>O(n)</td>
</tr>
<tr>
<td><code>s1.erase(1, 2)</code></td>
<td>从第1个位置开始删除2个字符</td>
<td>O(n)</td>
</tr>
<tr>
<td><code>s1.replace(0, 2, &quot;xx&quot;)</code></td>
<td>从第0个位置开始替换2个字符</td>
<td>O(n)</td>
</tr>
<tr>
<td><code>s1.find(&quot;lo&quot;)</code></td>
<td>查找字符串，返回第一个位置</td>
<td>O(n)</td>
</tr>
</tbody></table>
<p>遍历字符串</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 下标遍历</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line"> cout &lt;&lt; str[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代器遍历</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = str.<span class="built_in">begin</span>(); it != str.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line"> cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 范围for遍历</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> ch : str) &#123;</span><br><span class="line"> cout &lt;&lt; ch &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="Pass-by-value与pass-by-reference"><a href="#Pass-by-value与pass-by-reference" class="headerlink" title="Pass-by-value与pass-by-reference"></a>Pass-by-value与pass-by-reference</h3><p>值传递和引用传递。值传递是将参数的值复制一份传递给函数，函数内部对参数的修改不会影响外部变量；引用传递是将参数的地址传递给函数，函数内部对参数的修改会影响外部变量。<strong>如果是传递基本类型，比如 int、bool 等，用传值比较多，因为这类数据一般不需要在函数内部修改，而且复制的开销很小。如果是传递容器数据结构，比如 vector、unordered_map 等，用传引用比较多，因为可以避免复制数据副本的开销，而且容器一般需要在函数内部修改。</strong></p>
]]></content>
      <categories>
        <category>labuladong算法笔记</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>labuladong-第二章-经典暴力搜索算法</title>
    <url>/2025/04/23/labuladong-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E7%BB%8F%E5%85%B8%E6%9A%B4%E5%8A%9B%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<!-- # [第二章、经典暴力搜索算法](https://labuladong.online/algo/menu/braute-force-search/)
## [DFS/回溯算法](https://labuladong.online/algo/menu/dfs/)
### [回溯算法解题套路框架](https://labuladong.online/algo/essential-technique/backtrack-framework/)
### [回溯算法实践：数独和 N 皇后问题](https://labuladong.online/algo/practice-in-action/sudoku-nqueue/)
### [回溯算法秒杀所有排列/组合/子集问题](https://labuladong.online/algo/essential-technique/permutation-combination-subset-all-in-one/)
### [球盒模型：回溯算法穷举的两种视角](https://labuladong.online/algo/practice-in-action/two-views-of-backtrack/)
### [解答回溯算法/DFS算法的若干疑问](https://labuladong.online/algo/essential-technique/backtrack-vs-dfs/)
### [一文秒杀所有岛屿题目](https://labuladong.online/algo/frequency-interview/island-dfs-summary/)
### [回溯算法实践：括号生成](https://labuladong.online/algo/practice-in-action/generate-parentheses/)
### [回溯算法实践：集合划分](https://labuladong.online/algo/practice-in-action/partition-to-k-equal-sum-subsets/)
### [【强化练习】回溯算法经典习题 I](https://labuladong.online/algo/problem-set/backtrack-i/)
### [【强化练习】回溯算法经典习题 II](https://labuladong.online/algo/problem-set/backtrack-ii/)
### [【强化练习】回溯算法经典习题 III](https://labuladong.online/algo/problem-set/backtrack-iii/)

## [BFS 算法](https://labuladong.online/algo/menu/bfs/)
### [BFS 算法解题套路框架](https://labuladong.online/algo/essential-technique/bfs-framework/)
### [【强化练习】BFS 经典习题 I](https://labuladong.online/algo/problem-set/bfs/)
### [【强化练习】BFS 经典习题 II](https://labuladong.online/algo/problem-set/bfs-ii/)
### [正在更新 ing](https://labuladong.online/algo/intro/updating/) -->




<!-- 
# [第三章、经典动态规划算法](https://labuladong.online/algo/menu/dp/)
## [动态规划基本技巧](https://labuladong.online/algo/menu/dp-basic/)
### [动态规划解题套路框架](https://labuladong.online/algo/essential-technique/dynamic-programming-framework/)
### [动态规划设计：最长递增子序列](https://labuladong.online/algo/dynamic-programming/longest-increasing-subsequence/)
### [base case 和备忘录的初始值怎么定？](https://labuladong.online/algo/dynamic-programming/memo-fundamental/)
### [动态规划穷举的两种视角](https://labuladong.online/algo/dynamic-programming/two-views-of-dp/)
### [动态规划和回溯算法的思维转换](https://labuladong.online/algo/dynamic-programming/word-break/)
### [对动态规划进行降维打击](https://labuladong.online/algo/dynamic-programming/space-optimization/)
### [最优子结构原理和 dp 数组遍历方向](https://labuladong.online/algo/dynamic-programming/faq-summary/)

## [子序列类型问题](https://labuladong.online/algo/menu/subsequence/)
### [经典动态规划：编辑距离](https://labuladong.online/algo/dynamic-programming/edit-distance/)
### [动态规划设计：最大子数组](https://labuladong.online/algo/dynamic-programming/maximum-subarray/)
### [经典动态规划：最长公共子序列](https://labuladong.online/algo/dynamic-programming/longest-common-subsequence/)
### [动态规划之子序列问题解题模板](https://labuladong.online/algo/dynamic-programming/subsequence-problem/)

## [背包类型问题](https://labuladong.online/algo/menu/knapsack/)
### [经典动态规划：0-1 背包问题](https://labuladong.online/algo/dynamic-programming/knapsack1/)
### [经典动态规划：子集背包问题](https://labuladong.online/algo/dynamic-programming/knapsack2/)
### [经典动态规划：完全背包问题](https://labuladong.online/algo/dynamic-programming/knapsack3/)
### [背包问题的变体：目标和](https://labuladong.online/algo/dynamic-programming/target-sum/)

## [用动态规划玩游戏](https://labuladong.online/algo/menu/dp-game/)
### [动态规划之最小路径和](https://labuladong.online/algo/dynamic-programming/minimum-path-sum/)
### [动态规划帮我通关了《魔塔》](https://labuladong.online/algo/dynamic-programming/magic-tower/)
### [动态规划帮我通关了《辐射4》](https://labuladong.online/algo/dynamic-programming/freedom-trail/)
### [旅游省钱大法：加权最短路径](https://labuladong.online/algo/dynamic-programming/cheap-travel/)
### [经典动态规划：正则表达式](https://labuladong.online/algo/dynamic-programming/regular-expression-matching/)
### [经典动态规划：高楼扔鸡蛋](https://labuladong.online/algo/dynamic-programming/egg-drop/)
### [经典动态规划：戳气球](https://labuladong.online/algo/dynamic-programming/burst-balloons/)
### [经典动态规划：博弈问题](https://labuladong.online/algo/dynamic-programming/game-theory/)
### [一个方法团灭 LeetCode 打家劫舍问题](https://labuladong.online/algo/dynamic-programming/house-robber/)
### [一个方法团灭 LeetCode 股票买卖问题](https://labuladong.online/algo/dynamic-programming/stock-problem-summary/)

## [贪心类型问题](https://labuladong.online/algo/menu/greedy/)
### [贪心算法解题套路框架](https://labuladong.online/algo/essential-technique/greedy/)
### [老司机加油算法](https://labuladong.online/algo/frequency-interview/gas-station-greedy/)
### [贪心算法之区间调度问题](https://labuladong.online/algo/frequency-interview/interval-scheduling/)
### [扫描线技巧：安排会议室](https://labuladong.online/algo/frequency-interview/scan-line-technique/)
### [剪视频剪出一个贪心算法](https://labuladong.online/algo/frequency-interview/cut-video/) -->






<!-- # [第四章、其他常见算法技巧](https://labuladong.online/algo/menu/other/)
## [数学运算技巧](https://labuladong.online/algo/menu/math/)
### [一行代码就能解决的算法题](https://labuladong.online/algo/frequency-interview/one-line-solutions/)
### [常用的位操作](https://labuladong.online/algo/frequency-interview/bitwise-operation/)
### [谈谈游戏中的随机算法](https://labuladong.online/algo/frequency-interview/random-algorithm/)
### [讲两道常考的阶乘算法题](https://labuladong.online/algo/frequency-interview/factorial-problems/)
### [如何高效寻找素数](https://labuladong.online/algo/frequency-interview/print-prime-number/)
### [如何高效进行模幂运算](https://labuladong.online/algo/frequency-interview/quick-power/)
### [如何同时寻找缺失和重复的元素](https://labuladong.online/algo/frequency-interview/mismatch-set/)
### [几个反直觉的概率问题](https://labuladong.online/algo/frequency-interview/probability-problem/)
### [【强化练习】数学技巧相关习题](https://labuladong.online/algo/problem-set/math-tricks/)

## [经典面试题](https://labuladong.online/algo/menu/interview/)
### [算法笔试「骗分」套路](https://labuladong.online/algo/other-skills/tips-in-exam/)
### [如何高效解决接雨水问题](https://labuladong.online/algo/frequency-interview/trapping-rain-water/)
### [一文秒杀所有丑数系列问题](https://labuladong.online/algo/frequency-interview/ugly-number-summary/)
### [一个方法解决三道区间问题](https://labuladong.online/algo/practice-in-action/interval-problem-summary/)
### [谁能想到，斗地主也能玩出算法](https://labuladong.online/algo/practice-in-action/split-array-into-consecutive-subsequences/)
### [烧饼排序算法](https://labuladong.online/algo/frequency-interview/pancake-sorting/)
### [字符串乘法计算](https://labuladong.online/algo/practice-in-action/multiply-strings/)
### [如何判定完美矩形](https://labuladong.online/algo/frequency-interview/perfect-rectangle/) -->







































]]></content>
      <categories>
        <category>labuladong算法笔记</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>排序算法</tag>
        <tag>cpp</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>labuladong-第一章-经典数据结构算法</title>
    <url>/2025/04/23/labuladong-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E7%BB%8F%E5%85%B8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="第一章、经典数据结构算法"><a href="#第一章、经典数据结构算法" class="headerlink" title="第一章、经典数据结构算法"></a><a href="https://labuladong.online/algo/menu/ds/">第一章、经典数据结构算法</a></h1><h2 id="手把手刷链表算法"><a href="#手把手刷链表算法" class="headerlink" title="手把手刷链表算法"></a><a href="https://labuladong.online/algo/menu/linked-list/">手把手刷链表算法</a></h2><h3 id="双指针技巧秒杀七道链表题目"><a href="#双指针技巧秒杀七道链表题目" class="headerlink" title="双指针技巧秒杀七道链表题目"></a><a href="https://labuladong.online/algo/essential-technique/linked-list-skills-summary/">双指针技巧秒杀七道链表题目</a></h3><p>详见<a href="###%E5%8F%8C%E6%8C%87%E9%92%88%E6%8A%80%E5%B7%A7%E7%A7%92%E6%9D%80%E4%B8%83%E9%81%93%E9%93%BE%E8%A1%A8%E9%A2%98%E7%9B%AE">双指针技巧秒杀七道链表题目</a></p>
<h3 id="【强化练习】链表双指针经典习题"><a href="#【强化练习】链表双指针经典习题" class="headerlink" title="【强化练习】链表双指针经典习题"></a><a href="https://labuladong.online/algo/problem-set/linkedlist-two-pointers/">【强化练习】链表双指针经典习题</a></h3><ul>
<li><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/">Leetcode 82*</a><br>快慢指针，注意虚拟节点的加入</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deleteDuplicates</span>(<span class="params">self, head</span>):</span><br><span class="line">        dummy = ListNode(val=<span class="number">10086</span>)</span><br><span class="line">        slow, fast = dummy, head</span><br><span class="line"></span><br><span class="line">        <span class="comment"># dummy到slow就是去重的链表的左开右闭区间</span></span><br><span class="line">        <span class="comment"># 用arr表示就是[dummy.next.val,dummy.next.next.val,..,slow.val]</span></span><br><span class="line">        <span class="comment"># slow.next 一定是None</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># faster是待加入到dummy之后的链表的头</span></span><br><span class="line">        <span class="comment"># 当faster.next存在且fast.val == faster.next.val的时候</span></span><br><span class="line">        <span class="comment"># 我们跳过这段重复项为dup的串</span></span><br><span class="line">        <span class="comment"># 其余时间加入</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> fast:</span><br><span class="line">            <span class="keyword">if</span> fast.<span class="built_in">next</span> <span class="keyword">and</span> fast.<span class="built_in">next</span>.val == fast.val:</span><br><span class="line">                dup = fast.val</span><br><span class="line">                <span class="keyword">while</span> fast <span class="keyword">and</span> fast.val == dup:</span><br><span class="line">                    fast = fast.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                slow.<span class="built_in">next</span> = fast</span><br><span class="line">                slow = slow.<span class="built_in">next</span></span><br><span class="line">                fast = fast.<span class="built_in">next</span></span><br><span class="line">                slow.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>
<p>这个题目可以使用递归的方法，也是非常的优雅：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deleteDuplicates</span>(<span class="params">self, head</span>):</span><br><span class="line">        <span class="keyword">if</span> head <span class="keyword">is</span> <span class="literal">None</span>: <span class="comment">#给的链表be like[]</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span> </span><br><span class="line">        <span class="keyword">elif</span> head.<span class="built_in">next</span> <span class="keyword">is</span> <span class="literal">None</span>: <span class="comment">#给的链表be like[1]</span></span><br><span class="line">            <span class="keyword">return</span> head </span><br><span class="line">        <span class="keyword">elif</span> head.val != head.<span class="built_in">next</span>.val: <span class="comment">#给的链表be like[1,2,...]</span></span><br><span class="line">            head.<span class="built_in">next</span> =  <span class="variable language_">self</span>.deleteDuplicates(head.<span class="built_in">next</span>) </span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        <span class="keyword">else</span>: <span class="comment">#给的链表be like[1,1,2,...]</span></span><br><span class="line">            dup = head.val</span><br><span class="line">            <span class="keyword">while</span> head <span class="keyword">and</span> head.val == dup:</span><br><span class="line">                head = head.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">self</span>.deleteDuplicates(head)</span><br></pre></td></tr></table></figure>


<ul>
<li><a href="https://leetcode.cn/problems/ugly-number-ii/">Leetcode 264*</a><br>最笨逼的方法就是回溯，显然TLE</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">prod</span>(<span class="params">lst</span>):</span><br><span class="line">    product = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> lst:</span><br><span class="line">        product *= num</span><br><span class="line">    <span class="keyword">return</span> product</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.res = <span class="built_in">set</span>()</span><br><span class="line">        <span class="variable language_">self</span>.track = [<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">self,candidates = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>]</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(<span class="variable language_">self</span>.track) &gt;= <span class="number">12</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="variable language_">self</span>.res.add(prod(<span class="variable language_">self</span>.track))</span><br><span class="line">        <span class="keyword">for</span> candidate <span class="keyword">in</span> candidates:</span><br><span class="line">            <span class="variable language_">self</span>.track.append(candidate)</span><br><span class="line">            <span class="variable language_">self</span>.backtrack()</span><br><span class="line">            <span class="variable language_">self</span>.track.pop()</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">nthUglyNumber</span>(<span class="params">self, n</span>):</span><br><span class="line">        <span class="variable language_">self</span>.backtrack()</span><br><span class="line">        <span class="variable language_">self</span>.res = <span class="built_in">sorted</span>(<span class="built_in">list</span>(<span class="variable language_">self</span>.res))</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.res[n-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<p>最优解的方法十分巧妙，用到了一些技巧，如果一个数字是丑数，则其2、3、5的倍数也是丑数。假设<code>a</code>是致密的丑数链表：<br><code>a = 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6 -&gt; 7 -&gt; 8...</code><br>则<code>2a、3a、5a</code>也是丑数序列，但是可能不致密</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2a = 1*2 -&gt; 2*2 -&gt; 3*2 -&gt; 4*2 -&gt; 5*2 -&gt; 6*2 -&gt; 7*2 -&gt; 8*2...</span><br><span class="line">3a = 1*3 -&gt; 2*3 -&gt; 3*3 -&gt; 4*3 -&gt; 5*3 -&gt; 6*3 -&gt; 7*3 -&gt; 8*3...</span><br><span class="line">5a = 1*5 -&gt; 2*5 -&gt; 3*5 -&gt; 4*5 -&gt; 5*5 -&gt; 6*5 -&gt; 7*5 -&gt; 8*5...</span><br></pre></td></tr></table></figure>
<p>核心思想：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">nthUglyNumber</span>(<span class="params">self, n</span>):</span><br><span class="line">        a = [<span class="number">1</span>]</span><br><span class="line">        p2, p3, p5 = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 2 * a[p2] 表示2a链表的头</span></span><br><span class="line">        <span class="comment"># 3 * a[p3] 表示3a链表的头</span></span><br><span class="line">        <span class="comment"># 5 * a[p5] 表示5a链表的头</span></span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(a) &lt; n:</span><br><span class="line">            a.append(<span class="built_in">min</span>(<span class="number">2</span> * a[p2], <span class="number">3</span> * a[p3], <span class="number">5</span> * a[p5]))</span><br><span class="line">            <span class="comment"># 注意：如下的几个if是独立的，不能用elif</span></span><br><span class="line">            <span class="comment"># 不用elif是为了去重</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 表示2a链表的头加入了a，2a头刷新</span></span><br><span class="line">            <span class="keyword">if</span> a[-<span class="number">1</span>] == <span class="number">2</span> * a[p2]:</span><br><span class="line">                p2 += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 表示3a链表的头加入了a，3a头刷新</span></span><br><span class="line">            <span class="keyword">if</span> a[-<span class="number">1</span>] == <span class="number">3</span> * a[p3]:</span><br><span class="line">                p3 += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 表示5a链表的头加入了a，5a头刷新</span></span><br><span class="line">            <span class="keyword">if</span> a[-<span class="number">1</span>] == <span class="number">5</span> * a[p5]:</span><br><span class="line">                p5 += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> a[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<ul>
<li><a href="https://leetcode.cn/problems/kth-smallest-element-in-a-sorted-matrix/">Leetcode 378</a><br>可以直接flatten然后sort，或者直接优先队列也可以</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 先flatten后sort</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">kthSmallest</span>(<span class="params">self, matrix, k</span>):</span><br><span class="line">        flatten = []</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> matrix:</span><br><span class="line">            flatten += _</span><br><span class="line">        flatten.sort()</span><br><span class="line">        <span class="keyword">return</span> flatten[k-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 优先队列</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">kthSmallest</span>(<span class="params">self, matrix, k</span>):</span><br><span class="line">        <span class="keyword">import</span> heapq</span><br><span class="line">        hq = [(_[<span class="number">0</span>],_[<span class="number">1</span>:]) <span class="keyword">for</span> _ <span class="keyword">in</span> matrix]</span><br><span class="line">        heapq.heapify(hq)</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(k-<span class="number">1</span>):</span><br><span class="line">            _,tmp = heapq.heappop(hq)</span><br><span class="line">            <span class="keyword">if</span> tmp:</span><br><span class="line">                heapq.heappush(hq,(tmp[<span class="number">0</span>],tmp[<span class="number">1</span>:]))</span><br><span class="line">        <span class="keyword">return</span> heapq.heappop(hq)[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>


<p>-<a href="https://leetcode.cn/problems/find-k-pairs-with-smallest-sums/">Leetcode 373*</a><br>这个题目也是类似与<a href="https://leetcode.cn/problems/kth-smallest-element-in-a-sorted-matrix/">Leetcode 378</a>、<a href="https://leetcode.cn/problems/merge-k-sorted-lists/description/">Leetcode 23</a>本质上都是优先队列相关的题目，第一次提交MLE了：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 这个版本提交MLE了，原因是保留了大量的nums2_remain，导致内存消耗过大</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">kSmallestPairs</span>(<span class="params">self, nums1, nums2, k</span>):</span><br><span class="line">        <span class="keyword">import</span> heapq</span><br><span class="line">        res = []</span><br><span class="line">        <span class="comment"># 结构为(u+v,u,v,nums2_remain)</span></span><br><span class="line">        hq = [(_+nums2[<span class="number">0</span>],_,nums2[<span class="number">0</span>],nums2[<span class="number">1</span>:]) <span class="keyword">for</span> _ <span class="keyword">in</span> nums1]</span><br><span class="line">        heapq.heapify(hq)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">            _,u,v,remain = heapq.heappop(hq)</span><br><span class="line">            res.append([u,v])</span><br><span class="line">            <span class="keyword">if</span> remain:</span><br><span class="line">                heapq.heappush(hq,(u+remain[<span class="number">0</span>],u,remain[<span class="number">0</span>],remain[<span class="number">1</span>:]))</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用v_idx来表示nums2的索引</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">kSmallestPairs</span>(<span class="params">self, nums1, nums2, k</span>):</span><br><span class="line">        <span class="keyword">import</span> heapq</span><br><span class="line">        res = []</span><br><span class="line">        <span class="comment"># 结构为(u+v,u,v_idx)</span></span><br><span class="line">        hq = [(_ + nums2[<span class="number">0</span>], _, <span class="number">0</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> nums1]</span><br><span class="line">        heapq.heapify(hq)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">            _, u, v_idx = heapq.heappop(hq)</span><br><span class="line">            v = nums2[v_idx]</span><br><span class="line">            res.append([u, v])</span><br><span class="line">            <span class="keyword">if</span> v_idx + <span class="number">1</span> &lt; <span class="built_in">len</span>(nums2):</span><br><span class="line">                heapq.heappush(hq, (u + nums2[v_idx + <span class="number">1</span>], u, v_idx + <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>




<ul>
<li><a href="https://leetcode.cn/problems/add-two-numbers/">Leetcode 2</a><br>典型的双指针，需要搞一个虚拟头结点</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">addTwoNumbers</span>(<span class="params">self, l1, l2</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type l1: Optional[ListNode]</span></span><br><span class="line"><span class="string">        :type l2: Optional[ListNode]</span></span><br><span class="line"><span class="string">        :rtype: Optional[ListNode]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        dummy = ListNode(val=<span class="number">10086</span>,<span class="built_in">next</span>=<span class="literal">None</span>)</span><br><span class="line">        p = dummy</span><br><span class="line"></span><br><span class="line">        jingwei = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> l1 <span class="keyword">or</span> l2:</span><br><span class="line">            val = (l1.val <span class="keyword">if</span> l1 <span class="keyword">else</span> <span class="number">0</span>) + (l2.val <span class="keyword">if</span> l2 <span class="keyword">else</span> <span class="number">0</span>) + jingwei</span><br><span class="line"></span><br><span class="line">            p.<span class="built_in">next</span> = ListNode(val%<span class="number">10</span>)</span><br><span class="line">            jingwei = val // <span class="number">10</span></span><br><span class="line"></span><br><span class="line">            p = p.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> l1:</span><br><span class="line">                l1 = l1.<span class="built_in">next</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> l2:</span><br><span class="line">                l2 = l2.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> jingwei != <span class="number">0</span>:</span><br><span class="line">            p.<span class="built_in">next</span> = ListNode(jingwei)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>

<ul>
<li><a href="https://leetcode.cn/problems/add-two-numbers-ii/">Leetcode 445*</a><br>用递归翻转链表，然后调用上面题目的答案</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">addTwoNumbers_Leetcode2</span>(<span class="params">self, l1, l2</span>):</span><br><span class="line">        dummy = ListNode(val=<span class="number">10086</span>, <span class="built_in">next</span>=<span class="literal">None</span>)</span><br><span class="line">        p = dummy</span><br><span class="line"></span><br><span class="line">        jingwei = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> l1 <span class="keyword">or</span> l2:</span><br><span class="line">            val = (l1.val <span class="keyword">if</span> l1 <span class="keyword">else</span> <span class="number">0</span>) + (l2.val <span class="keyword">if</span> l2 <span class="keyword">else</span> <span class="number">0</span>) + jingwei</span><br><span class="line"></span><br><span class="line">            p.<span class="built_in">next</span> = ListNode(val % <span class="number">10</span>)</span><br><span class="line">            jingwei = val // <span class="number">10</span></span><br><span class="line"></span><br><span class="line">            p = p.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> l1:</span><br><span class="line">                l1 = l1.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> l2:</span><br><span class="line">                l2 = l2.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> jingwei != <span class="number">0</span>:</span><br><span class="line">            p.<span class="built_in">next</span> = ListNode(jingwei)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reversed_lst</span>(<span class="params">self, l</span>):</span><br><span class="line">        <span class="keyword">if</span> l <span class="keyword">is</span> <span class="literal">None</span>:  <span class="comment"># l be like []</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">elif</span> l.<span class="built_in">next</span> <span class="keyword">is</span> <span class="literal">None</span>:  <span class="comment"># l be like [1]</span></span><br><span class="line">            <span class="keyword">return</span> l</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># l be like [1,2,3,...]</span></span><br><span class="line">            <span class="comment"># split in p1 and p2</span></span><br><span class="line">            <span class="comment"># p1 = l[0]</span></span><br><span class="line">            <span class="comment"># p2 = l[1:]</span></span><br><span class="line">            <span class="comment"># reversed(l) = reversed(p2) + p1</span></span><br><span class="line">            dummy = ListNode()</span><br><span class="line"></span><br><span class="line">            p1 = l</span><br><span class="line">            p2 = l.<span class="built_in">next</span></span><br><span class="line">            p1.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">            dummy.<span class="built_in">next</span> = <span class="variable language_">self</span>.reversed_lst(p2)</span><br><span class="line">            p = dummy</span><br><span class="line">            <span class="keyword">while</span> p.<span class="built_in">next</span>:</span><br><span class="line">                p = p.<span class="built_in">next</span></span><br><span class="line">            p.<span class="built_in">next</span> = p1</span><br><span class="line">            <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">addTwoNumbers</span>(<span class="params">self, l1, l2</span>):</span><br><span class="line">        l1r = <span class="variable language_">self</span>.reversed_lst(l1)</span><br><span class="line">        l2r = <span class="variable language_">self</span>.reversed_lst(l2)</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.reversed_lst(<span class="variable language_">self</span>.addTwoNumbers_Leetcode2(l1r, l2r))</span><br></pre></td></tr></table></figure>


<h3 id="单链表的花式反转方法汇总"><a href="#单链表的花式反转方法汇总" class="headerlink" title="单链表的花式反转方法汇总"></a><a href="https://labuladong.online/algo/data-structure/reverse-linked-list-recursion/">单链表的花式反转方法汇总</a></h3><ul>
<li><a href="https://leetcode.cn/problems/reverse-linked-list/">Leetcode 206*</a> 反转链表</li>
</ul>
<p>这个题目非常非常经典，也是十分优雅的一个递归的写法的题目，在上面的Leetcode 445*中我们也用到了这个功能，下面就自己的递归版本，更加优雅的递归版本，以及迭代的的版本进行说明：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseList</span>(<span class="params">self, head</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        该版本是自己想的，非常的直观易懂，但是不够优雅</span></span><br><span class="line"><span class="string">        我们本可以不用遍历reverseList(p2)的尾巴</span></span><br><span class="line"><span class="string">        :type head: Optional[ListNode]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> head <span class="keyword">is</span> <span class="literal">None</span>:  <span class="comment"># l be like []</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">elif</span> head.<span class="built_in">next</span> <span class="keyword">is</span> <span class="literal">None</span>:  <span class="comment"># l be like [1]</span></span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># l be like [1,2,3,...]</span></span><br><span class="line">            <span class="comment"># split in p1 and p2</span></span><br><span class="line">            <span class="comment"># p1 = l[0]</span></span><br><span class="line">            <span class="comment"># p2 = l[1:]</span></span><br><span class="line">            <span class="comment"># reversed(l) = reversed(p2) + p1</span></span><br><span class="line">            dummy = ListNode()</span><br><span class="line"></span><br><span class="line">            p1 = head</span><br><span class="line">            p2 = head.<span class="built_in">next</span></span><br><span class="line">            p1.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">            dummy.<span class="built_in">next</span> = <span class="variable language_">self</span>.reverseList(p2)            </span><br><span class="line">            <span class="comment"># 此处用于找到reversed(p2)的尾巴</span></span><br><span class="line">            p = dummy</span><br><span class="line">            <span class="keyword">while</span> p.<span class="built_in">next</span>:</span><br><span class="line">                p = p.<span class="built_in">next</span></span><br><span class="line">            <span class="comment"># 这里将p1接到reversed(p2)的尾巴上，完成递归</span></span><br><span class="line">            p.<span class="built_in">next</span> = p1</span><br><span class="line">            <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseList</span>(<span class="params">self, head</span>):</span><br><span class="line">        <span class="keyword">if</span> head <span class="keyword">is</span> <span class="literal">None</span>:  <span class="comment"># l be like []</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">elif</span> head.<span class="built_in">next</span> <span class="keyword">is</span> <span class="literal">None</span>:  <span class="comment"># l be like [1]</span></span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># l be like [1,2,3,...]</span></span><br><span class="line">            <span class="comment"># split in p1 and p2</span></span><br><span class="line">            <span class="comment"># p1 = l</span></span><br><span class="line">            <span class="comment"># p2 = l.next</span></span><br><span class="line">            <span class="comment"># reversed(l) = reversed(p2) + p1</span></span><br><span class="line">            <span class="comment"># 核心想法：</span></span><br><span class="line">            <span class="comment"># reversed(p2)[-1] = p2.next = l.next.next</span></span><br><span class="line">            dummy = ListNode()</span><br><span class="line">            dummy.<span class="built_in">next</span> = <span class="variable language_">self</span>.reverseList(head.<span class="built_in">next</span>)</span><br><span class="line">            head.<span class="built_in">next</span>.<span class="built_in">next</span> = head</span><br><span class="line">            head.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">            <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>
<p>具体的优化版递归方法详见如图所示：<br><img src="/../images/image-24.png" alt="alt text"></p>
<p>下面介绍一个迭代的方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="comment"># 反转以 head 为起点的单链表</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseList</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span><br><span class="line">        <span class="keyword">if</span> head <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> head.<span class="built_in">next</span> <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        <span class="comment"># 由于单链表的结构，至少要用三个指针才能完成迭代反转</span></span><br><span class="line">        <span class="comment"># cur 是当前遍历的节点，pre 是 cur 的前驱结点，nxt 是 cur 的后继结点</span></span><br><span class="line">        pre, cur, nxt = <span class="literal">None</span>, head, head.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="comment"># 逐个结点反转</span></span><br><span class="line">            cur.<span class="built_in">next</span> = pre</span><br><span class="line">            <span class="comment"># 更新三个指针，都往后移动一步</span></span><br><span class="line">            pre = cur</span><br><span class="line">            cur = nxt</span><br><span class="line">            <span class="keyword">if</span> nxt <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                nxt = nxt.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 返回反转后的头结点</span></span><br><span class="line">        <span class="comment"># 此时cur和nxt都为None，pre为反转后的头结点</span></span><br><span class="line">        <span class="keyword">return</span> pre</span><br></pre></td></tr></table></figure>


<p>这个题目可以更进一步的复杂，要求只反转链表的前N个节点，后面的节点不变，比如说,我们有N&#x3D;3</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">head = 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;7-&gt;8-&gt;9-&gt;10</span><br><span class="line">reverseNodes(head, 3) = reverse(1-&gt;2-&gt;3)-&gt;4-&gt;5-&gt;6-&gt;7-&gt;8-&gt;9-&gt;10</span><br></pre></td></tr></table></figure>
<p>最直观的就是找到前N个节点，断开成p1,p2两段，然后反转p1，最后拼接p1和p2即可：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverse</span>(<span class="params">self, head</span>):</span><br><span class="line">        <span class="comment">#pass, 前面的代码已经写过了</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseN</span>(<span class="params">self, head, n</span>):</span><br><span class="line">        p1 = head</span><br><span class="line">        </span><br><span class="line">        p = head</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>):</span><br><span class="line">            p = p.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        p2 = p.<span class="built_in">next</span></span><br><span class="line">        p.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line">        p1 = <span class="variable language_">self</span>.reverse(p1)</span><br><span class="line">        dummy = ListNode()</span><br><span class="line">        dummy.<span class="built_in">next</span> = p1</span><br><span class="line"></span><br><span class="line">        p = dummy</span><br><span class="line">        <span class="keyword">while</span> p.<span class="built_in">next</span>:</span><br><span class="line">            p = p.<span class="built_in">next</span></span><br><span class="line">        p.<span class="built_in">next</span> = p2</span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>

<p>也可以直接用递归的方法来实现，下面是一个递归的版本：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">___init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.p2 = <span class="literal">None</span> <span class="comment"># 这个p2是全局变量，表示没有反转的链表的头结点，[head-&gt;....]-&gt;p2-&gt;...-&gt;None，我们翻转[]内容，p2不变</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseN</span>(<span class="params">self, head, n</span>):</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="variable language_">self</span>.p2 = head.<span class="built_in">next</span> <span class="comment"># 这个p2是全局变量，表示没有反转的链表的头结点，[head-&gt;....]-&gt;p2-&gt;...-&gt;None，我们翻转[]内容，p2不变</span></span><br><span class="line">            <span class="keyword">return</span> head <span class="comment"># 返回翻转后的头结点</span></span><br><span class="line"></span><br><span class="line">        p1 = <span class="variable language_">self</span>.reverseN(head.<span class="built_in">next</span>, n-<span class="number">1</span>) <span class="comment"># 递归翻转链表的前n-1个节点</span></span><br><span class="line">        head.<span class="built_in">next</span>.<span class="built_in">next</span> = head <span class="comment"># 将head接到翻转后的链表的尾巴上</span></span><br><span class="line">        head.<span class="built_in">next</span> = <span class="variable language_">self</span>.p2 <span class="comment"># 将head接到p2上，完成拼接</span></span><br><span class="line">        <span class="keyword">return</span> p1 <span class="comment"># 返回翻转后的头结点</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p><a href="https://leetcode.cn/problems/reverse-linked-list-ii/">Leetcode 92</a> 反转链表 II<br>上面反转链表会了，直接就能搞，分三段font，mid，end, 维护5个指针，分别是font_begin，font_end，mid_begin，mid_end，end_begin。<br>然后把中间的反转，后面拼接就好</p>
</li>
<li><p><a href="https://leetcode.cn/problems/reverse-nodes-in-k-group/">Leetcode 25*</a> K 个一组翻转链表<br>非常好的一个题目一共提交了两个版本,无论是那个版本，都用到了前面反转链表的代码，个人感觉第二个版本更好一些，下面是第两个版本的代码：</p>
</li>
</ul>
<p>方法一：全链上操作，维护pre,group_begin,group_end,post四个指针，</p>
<ul>
<li>pre: 一个group的前驱结点，用于将反转后的group接到pre后面</li>
<li>group_begin，group_end: group的头结点和尾结点</li>
<li>post: group的后继结点，用于剩下的内容在反转group之后，拼接</li>
</ul>
<p>整体来说这个方法不是很好，设计到大量的指针操作，容易出错，下面是代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverse</span>(<span class="params">self, head</span>):</span><br><span class="line">        <span class="comment"># pass, 前面的代码已经写过了</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseKGroup</span>(<span class="params">self, head, k</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type head: Optional[ListNode]</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: Optional[ListNode]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        dummy = ListNode(<span class="number">10086</span>)</span><br><span class="line"></span><br><span class="line">        pre = dummy</span><br><span class="line">        post = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        group_begin = <span class="literal">None</span></span><br><span class="line">        group_end = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        正常情况下：pre-&gt;group_begin-&gt;...-&gt;group_end-&gt;post</span></span><br><span class="line"><span class="string">        找到之后这四个指针之后</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        pre.next = None</span></span><br><span class="line"><span class="string">        group_end.next = None</span></span><br><span class="line"><span class="string">        reverse(group_begin)</span></span><br><span class="line"><span class="string">        拼接</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        p = head</span><br><span class="line">        cnt = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> p:</span><br><span class="line">            <span class="keyword">if</span> cnt % k == <span class="number">0</span>:</span><br><span class="line">                group_begin = p</span><br><span class="line">                <span class="comment"># print(&quot;cnt % k == 0&quot;, p)</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> cnt % k == k - <span class="number">1</span>:</span><br><span class="line">                group_end = p</span><br><span class="line">                post = p.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">                group_end.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">                _ = <span class="variable language_">self</span>.reverse(group_begin)</span><br><span class="line"></span><br><span class="line">                pre.<span class="built_in">next</span> = group_end</span><br><span class="line">                group_begin.<span class="built_in">next</span> = post</span><br><span class="line"></span><br><span class="line">                pre = group_begin</span><br><span class="line">                p = group_begin</span><br><span class="line"></span><br><span class="line">                post = <span class="literal">None</span></span><br><span class="line">                <span class="comment"># print(&quot;cnt % k == k-1&quot;, p)</span></span><br><span class="line"></span><br><span class="line">            p = p.<span class="built_in">next</span></span><br><span class="line">            cnt += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>

<p>方法二：<br>尝试从head切下k个节点，然后把剩下的部分也返回用于下次切割，最主要的设计了一个函数<code>cut_Knodes_from_head(self, head, k)</code>,其返回的元组：</p>
<ul>
<li>group_begin: group的头结点，如果为空则说明给的head为空</li>
<li>group_end: group的尾结点，确保group_end.next &#x3D; None，如果为空则说明凑不够k个节点，remain一定None</li>
<li>remain: 切剩下的部分，如果为空则说明1. 刚好切了k个节点，2. 凑不够k个节点</li>
</ul>
<p>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverse</span>(<span class="params">self, head</span>):</span><br><span class="line">        <span class="comment"># pass, 前面的代码已经写过了</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">cut_Knodes_from_head</span>(<span class="params">self, head, k</span>):</span><br><span class="line">        group_head = head</span><br><span class="line">        group_tail = <span class="literal">None</span></span><br><span class="line">        remain = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        p = head</span><br><span class="line">        cnt = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> p <span class="keyword">and</span> cnt &lt; k:</span><br><span class="line">            p = p.<span class="built_in">next</span></span><br><span class="line">            cnt += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> p:</span><br><span class="line">            group_tail = p</span><br><span class="line">            remain = p.<span class="built_in">next</span></span><br><span class="line">            group_tail.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            group_tail = <span class="literal">None</span></span><br><span class="line">            remain = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> group_head, group_tail, remain</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseKGroup</span>(<span class="params">self, head, k</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type head: Optional[ListNode]</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: Optional[ListNode]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        dummy = ListNode(<span class="number">10086</span>)</span><br><span class="line">        dummy_tail = dummy</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            group_head, group_tail, head = <span class="variable language_">self</span>.cut_Knodes_from_head(head, k)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> group_head:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> group_tail:</span><br><span class="line">                dummy_tail.<span class="built_in">next</span> = group_head</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="comment"># assert group_head is not None and group_tail is not None</span></span><br><span class="line">            _ = <span class="variable language_">self</span>.reverse(group_head)</span><br><span class="line">            dummy_tail.<span class="built_in">next</span> = group_tail</span><br><span class="line">            dummy_tail = group_head</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>









<h3 id="如何判断回文链表"><a href="#如何判断回文链表" class="headerlink" title="如何判断回文链表"></a><a href="https://labuladong.online/algo/data-structure/palindrome-linked-list/">如何判断回文链表</a></h3><ul>
<li><a href="https://leetcode.cn/problems/palindrome-linked-list/">Leetcode 234*</a> 回文链表<br>首先这个题目本来就不难，如果不要求空间复杂度为O(1)，直接遍历存到<code>arr</code>中，然后判断<code>arr == arr[::-1]</code>即可。</li>
</ul>
<p>同时这个题目也有一个误区，朴素地尝试用stack来实现，实际上stack可以验证括号的合法性，但是似乎不能用来验证回文链表的合法性，可以构造一个例子<code>开开心心</code>，显然不是回文串，但是stack会认为是回文串。<br>如果非要用stack，需要找到链表的中心节点，然后将后半部分压入栈中，然后再遍历前半部分和后半部分进行比较。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isPalindrome</span>(<span class="params">self, head</span>):</span><br><span class="line">        stack = []</span><br><span class="line">        slow，fast = head, head</span><br><span class="line">        <span class="keyword">while</span> fast <span class="keyword">and</span> fast.<span class="built_in">next</span>:</span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">            fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">while</span> slow:</span><br><span class="line">            stack.append(slow.val)</span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">        slow = head</span><br><span class="line">        <span class="keyword">while</span> slow <span class="keyword">and</span> stack:</span><br><span class="line">            <span class="keyword">if</span> slow.val != stack.pop():</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p>如果非要用O(1)的空间复杂度来实现，我们可以试着采用后序遍历的方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.left = <span class="literal">None</span></span><br><span class="line">        <span class="variable language_">self</span>.right = <span class="literal">None</span></span><br><span class="line">        <span class="variable language_">self</span>.res = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">traverse</span>(<span class="params">self,p</span>):</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> p <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="variable language_">self</span>.traverse(p.<span class="built_in">next</span>)</span><br><span class="line">        <span class="variable language_">self</span>.right = p</span><br><span class="line">        <span class="variable language_">self</span>.res = <span class="variable language_">self</span>.res <span class="keyword">and</span> <span class="variable language_">self</span>.right.val ==  <span class="variable language_">self</span>.left.val</span><br><span class="line">        <span class="variable language_">self</span>.left = <span class="variable language_">self</span>.left.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isPalindrome</span>(<span class="params">self, head</span>):</span><br><span class="line">        <span class="variable language_">self</span>.left = head</span><br><span class="line">        <span class="variable language_">self</span>.traverse(head)</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.res</span><br></pre></td></tr></table></figure>



<h2 id="手把手刷数组算法"><a href="#手把手刷数组算法" class="headerlink" title="手把手刷数组算法"></a><a href="https://labuladong.online/algo/menu/array/">手把手刷数组算法</a></h2><h3 id="双指针技巧秒杀七道数组题目"><a href="#双指针技巧秒杀七道数组题目" class="headerlink" title="双指针技巧秒杀七道数组题目"></a><a href="https://labuladong.online/algo/essential-technique/array-two-pointers-summary/">双指针技巧秒杀七道数组题目</a></h3><h3 id="二维数组的花式遍历技巧"><a href="#二维数组的花式遍历技巧" class="headerlink" title="二维数组的花式遍历技巧"></a><a href="https://labuladong.online/algo/practice-in-action/2d-array-traversal-summary/">二维数组的花式遍历技巧</a></h3><!-- LeetCode	力扣	难度
151. Reverse Words in a String	151. 反转字符串中的单词	🟠
48. Rotate Image	48. 旋转图像	🟠
54. Spiral Matrix	54. 螺旋矩阵	🟠
59. Spiral Matrix II	59. 螺旋矩阵 II	🟠
61. Rotate List	61. 旋转链表	🟠
-	剑指 Offer 29. 顺时针打印矩阵	🟢 -->

<ul>
<li><a href="https://leetcode.cn/problems/reverse-words-in-a-string/">Leetcode 151</a> 反转字符串中的单词<br>用python直接输出<code>&quot; &quot;.join(reversed(s.split()))</code>即可</li>
<li><a href="https://leetcode.cn/problems/rotate-image/">Leetcode 48*</a> 旋转图像<br><img src="/../images/image-25.png" alt="alt text"><br><strong>rotate &#x3D; transpose + flip</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rotate</span>(<span class="params">self, matrix</span>):</span><br><span class="line">        <span class="variable language_">self</span>.transpose(matrix)</span><br><span class="line">        <span class="variable language_">self</span>.flip(matrix)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">flip</span>(<span class="params">self,matrix</span>):</span><br><span class="line">        n = <span class="built_in">len</span>(matrix)</span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> matrix:</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n//<span class="number">2</span>):</span><br><span class="line">                row[j],row[n-<span class="number">1</span>-j] = row[n-<span class="number">1</span>-j], row[j]</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">transpose</span>(<span class="params">self,matrix</span>):</span><br><span class="line">        n = <span class="built_in">len</span>(matrix)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i,n):</span><br><span class="line">                matrix[i][j],matrix[j][i] = matrix[j][i],matrix[i][j]</span><br></pre></td></tr></table></figure>




<ul>
<li><a href="https://leetcode.cn/problems/spiral-matrix/">Leetcode 54</a> 螺旋矩阵<br>直接按照要求pop就行了，注意pop(0)和pop()的区别，pop(0)是O(n)，pop()是O(1)，所以要尽量避免pop(0)的使用。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">spiralOrder</span>(<span class="params">self, matrix</span>):</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> matrix:</span><br><span class="line">            <span class="keyword">if</span> matrix:</span><br><span class="line">                res += matrix.pop(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> row <span class="keyword">in</span> matrix:</span><br><span class="line">                res.append(row.pop())</span><br><span class="line"></span><br><span class="line">            matrix = [_ <span class="keyword">for</span> _ <span class="keyword">in</span> matrix <span class="keyword">if</span> _ != []]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> matrix:</span><br><span class="line">                res += matrix.pop()[::-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> row <span class="keyword">in</span> matrix[::-<span class="number">1</span>]:</span><br><span class="line">                res.append(row.pop(<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">            matrix = [_ <span class="keyword">for</span> _ <span class="keyword">in</span> matrix <span class="keyword">if</span> _ != []]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<ul>
<li><a href="https://leetcode.cn/problems/spiral-matrix-ii/">Leetcode 59*</a> 螺旋矩阵 II<br>注意二维数组的初始化方法，<code>matrix = [[0]*n for _ in range(n)]</code>，注意不能用<code>matrix = [[0]*n]*n</code>，因为这样会导致所有的行都是同一个对象，修改其中一行会导致其他行也被修改。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">generateMatrix</span>(<span class="params">self, n</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        arr = <span class="built_in">list</span>(<span class="built_in">range</span>(n ** <span class="number">2</span>, <span class="number">0</span>, -<span class="number">1</span>))</span><br><span class="line">        matrix = [[<span class="literal">None</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line"></span><br><span class="line">        upper_bound, left_bound, bottom_bound, right_bound = <span class="number">0</span>, n, n, <span class="number">0</span></span><br><span class="line">        i, j = <span class="number">0</span>, -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(arr) &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="comment"># 👉 i.e. j++ until reach left_bound</span></span><br><span class="line">            upper_bound += <span class="number">1</span></span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> j &lt; left_bound:</span><br><span class="line">                matrix[i][j] = arr.pop()</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 👇 i.e. i++ until reach bottom_bound</span></span><br><span class="line">            left_bound -= <span class="number">1</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> i &lt; bottom_bound:</span><br><span class="line">                matrix[i][j] = arr.pop()</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            i -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 👈 i.e. j-- until reach right_bound</span></span><br><span class="line">            bottom_bound -= <span class="number">1</span></span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> j &gt;= right_bound:</span><br><span class="line">                matrix[i][j] = arr.pop()</span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 👆 i.e. i-- until reach upper_bound</span></span><br><span class="line">            right_bound += <span class="number">1</span></span><br><span class="line">            i -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> i &gt;= upper_bound:</span><br><span class="line">                matrix[i][j] = arr.pop()</span><br><span class="line">                i -= <span class="number">1</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> matrix</span><br></pre></td></tr></table></figure>


<h3 id="【练习】数组双指针经典习题"><a href="#【练习】数组双指针经典习题" class="headerlink" title="【练习】数组双指针经典习题"></a><a href="https://labuladong.online/algo/problem-set/array-two-pointers/">【练习】数组双指针经典习题</a></h3><ul>
<li><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array-ii/">leetcode 80</a> 删除排序数组中的重复项 II<br>非常经典的一道快慢指针问题</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeDuplicates</span>(<span class="params">self, nums</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        slow, fast = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="comment"># nums[0], nums[1],...nums[slow-1] = nums[:slow] 就是删除了有序数组中的重复项目的数组</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> fast &lt; n:</span><br><span class="line">            <span class="keyword">if</span> nums[fast] <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment"># assert nums[fast] is Not None</span></span><br><span class="line">            <span class="keyword">if</span> slow == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">if</span> fast + <span class="number">1</span> &lt; n <span class="keyword">and</span> nums[fast+<span class="number">1</span>] == nums[fast]:</span><br><span class="line">                    slow += <span class="number">2</span></span><br><span class="line">                    fast += <span class="number">2</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    slow += <span class="number">1</span></span><br><span class="line">                    fast += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> nums[slow - <span class="number">1</span>] != nums[fast]:</span><br><span class="line">                    <span class="keyword">if</span> fast + <span class="number">1</span> &lt; n <span class="keyword">and</span> nums[fast+<span class="number">1</span>] == nums[fast]:</span><br><span class="line">                        slow += <span class="number">2</span></span><br><span class="line">                        fast += <span class="number">2</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        slow += <span class="number">1</span></span><br><span class="line">                        fast += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">for</span> p <span class="keyword">in</span> <span class="built_in">range</span>(fast,n-<span class="number">1</span>):</span><br><span class="line">                        <span class="keyword">if</span> nums[p] <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                            <span class="keyword">break</span></span><br><span class="line">                        nums[p] = nums[p+<span class="number">1</span>]</span><br><span class="line">                    nums[n-<span class="number">1</span>] = <span class="literal">None</span> </span><br><span class="line">        <span class="keyword">return</span> slow</span><br><span class="line">        </span><br></pre></td></tr></table></figure>



<ul>
<li><p><a href="https://leetcode.cn/problems/valid-palindrome/description/">Leetcode 125</a> 验证回文串<br>左右指针判断回文串</p>
</li>
<li><p><a href="https://leetcode.cn/problems/sort-colors/description/">Leetcode 75*</a> 颜色分类<br>直接计数排序，时间复杂度为O(n)</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sortColors</span>(<span class="params">self, nums</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: None Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        cnt = Counter(nums)</span><br><span class="line">        curr = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>]:</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(cnt[num]):</span><br><span class="line">                nums[curr] = num</span><br><span class="line">                curr += <span class="number">1</span></span><br></pre></td></tr></table></figure>

<ul>
<li><a href="https://leetcode.cn/problems/merge-sorted-array/description/">Leetcode 88*</a> 合并两个有序数组<br>这个题目比较巧妙，如果开额外的空间，容易做到时间复杂度为O(m+n)</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">merge</span>(<span class="params">self, nums1, m, nums2, n</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums1: List[int]</span></span><br><span class="line"><span class="string">        :type m: int</span></span><br><span class="line"><span class="string">        :type nums2: List[int]</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: None Do not return anything, modify nums1 in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        res = []</span><br><span class="line">        i,j = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> <span class="number">0</span>&lt;=i &lt; m <span class="keyword">and</span> <span class="number">0</span>&lt;= j&lt; n:</span><br><span class="line">            <span class="keyword">if</span> nums1[i] &lt;= nums2[j]:</span><br><span class="line">                res.append(nums1[i])</span><br><span class="line">                i+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res.append(nums2[j])</span><br><span class="line">                j+=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> i == m:</span><br><span class="line">            res += nums2[j:n]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            res += nums1[i:m]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">assert</span> <span class="built_in">len</span>(res) == <span class="built_in">len</span>(nums1)</span><br><span class="line">        <span class="keyword">for</span> idx <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums1)):</span><br><span class="line">            nums1[idx] = res[idx]</span><br></pre></td></tr></table></figure>

<p>但是如果想要同时做到时间和空间的复杂度都是O(m+n)就比较有意思了，由于nums1已经预留好了空间，我们可以从其屁股端开始读写，这样就不用开额外的空间了,注意从屁股塞入的时候，第一个塞入最大的</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">merge</span>(<span class="params">self, nums1, m, nums2, n</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums1: List[int]</span></span><br><span class="line"><span class="string">        :type m: int</span></span><br><span class="line"><span class="string">        :type nums2: List[int]</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: None Do not return anything, modify nums1 in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 从屁股后为0的位置开始写入</span></span><br><span class="line">        res_idx = <span class="built_in">len</span>(nums1) -<span class="number">1</span></span><br><span class="line">        i, j = m-<span class="number">1</span>, n-<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> <span class="number">0</span>&lt;= i <span class="keyword">and</span> <span class="number">0</span>&lt;=j:</span><br><span class="line">            <span class="keyword">if</span> nums1[i] &gt;= nums2[j]:</span><br><span class="line">                nums1[res_idx] =  nums1[i]</span><br><span class="line">                res_idx -= <span class="number">1</span></span><br><span class="line">                i -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                nums1[res_idx] =  nums2[j]</span><br><span class="line">                res_idx -= <span class="number">1</span></span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># i&lt;=0 and j&lt;0 or i&lt;0 and 0&lt;=j</span></span><br><span class="line">        <span class="keyword">if</span> i &gt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">while</span> i &gt;= <span class="number">0</span>:</span><br><span class="line">                nums1[res_idx] =  nums1[i]</span><br><span class="line">                res_idx -= <span class="number">1</span></span><br><span class="line">                i -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">while</span> j &gt;= <span class="number">0</span>:</span><br><span class="line">                nums1[res_idx] =  nums2[j]</span><br><span class="line">                res_idx -= <span class="number">1</span></span><br><span class="line">                j -= <span class="number">1</span></span><br></pre></td></tr></table></figure>


<ul>
<li><p><a href="https://leetcode.cn/problems/squares-of-a-sorted-array/description/">Leetcode 977</a> 有序数组的平方<br>合并两个有序数组与这个题目非常的类似,详见88</p>
</li>
<li><p><a href="https://leetcode.cn/problems/sort-the-matrix-diagonally/description/">Leetcode 1329</a>  将矩阵按对角线排序<br>以<code>(i,j)</code>为开始的所有对角线元素为：<code>[matrix[i][j], matrix[i+1][j+1], ..., matrix[i+k-1][j+k-1]]</code>,引入一个函数用于判断是否越界读写</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.m = <span class="literal">None</span></span><br><span class="line">        <span class="variable language_">self</span>.n = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isInBoundary</span>(<span class="params">self, i, j</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> &lt;= i &lt; <span class="variable language_">self</span>.m <span class="keyword">and</span> <span class="number">0</span> &lt;= j &lt; <span class="variable language_">self</span>.n</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">diagonalSort</span>(<span class="params">self, mat</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type mat: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="variable language_">self</span>.m = <span class="built_in">len</span>(mat)</span><br><span class="line">        <span class="variable language_">self</span>.n = <span class="built_in">len</span>(mat[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 从第1列开始遍历</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="variable language_">self</span>.m):</span><br><span class="line">            diag = []</span><br><span class="line">            _i, _j = i, <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> <span class="variable language_">self</span>.isInBoundary(_i, _j):</span><br><span class="line">                diag.append(mat[_i][_j])</span><br><span class="line">                _i += <span class="number">1</span></span><br><span class="line">                _j += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            diag.sort()</span><br><span class="line">            _i, _j = i, <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> <span class="variable language_">self</span>.isInBoundary(_i, _j):</span><br><span class="line">                mat[_i][_j] = diag[_j]</span><br><span class="line">                _i += <span class="number">1</span></span><br><span class="line">                _j += <span class="number">1</span></span><br><span class="line">        <span class="comment"># 从第1行开始遍历</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="variable language_">self</span>.n):</span><br><span class="line">            diag = []</span><br><span class="line">            _i, _j = <span class="number">0</span>, j</span><br><span class="line">            <span class="keyword">while</span> <span class="variable language_">self</span>.isInBoundary(_i, _j):</span><br><span class="line">                diag.append(mat[_i][_j])</span><br><span class="line">                _i += <span class="number">1</span></span><br><span class="line">                _j += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            diag.sort()</span><br><span class="line">            _i, _j = <span class="number">0</span>, j</span><br><span class="line">            <span class="keyword">while</span> <span class="variable language_">self</span>.isInBoundary(_i, _j):</span><br><span class="line">                mat[_i][_j] = diag[_i]</span><br><span class="line">                _i += <span class="number">1</span></span><br><span class="line">                _j += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> mat</span><br></pre></td></tr></table></figure>


<ul>
<li><p><a href="https://leetcode.cn/problems/shift-2d-grid/description/">Leetcode 1260</a> 二维网格迁徙<br>注意先flatten一下，再reverse</p>
</li>
<li><p><a href="https://leetcode.cn/problems/transpose-matrix/description/">Leetcode 867</a> 转置矩阵<br>注意如何创建一个(n,m)的二维数组，可以使用<code>matrix = [[0]*m for _ in range(n)]</code></p>
</li>
<li><p><a href="https://leetcode.cn/problems/longest-common-prefix/description/">Leetcode 14</a> 最长公共前缀<br>简单题</p>
</li>
</ul>
<h3 id="一个方法团灭-nSum-问题"><a href="#一个方法团灭-nSum-问题" class="headerlink" title="一个方法团灭 nSum 问题"></a><a href="https://labuladong.online/algo/practice-in-action/nsum/">一个方法团灭 nSum 问题</a></h3><p>本篇的核心想法就是先实现<code>twoSumTarget(nums: List[int], target: int) -&gt; List[List[int]]:</code>这个函数，然后面对</p>
<ul>
<li>threeSumTarget，固定一个数字，更新target，然后调用twoSumTarget，得到结果，再把结果加到res中，最后返回res</li>
<li>fourSumTarget，固定一个数字，更新target，然后调用threeSumTarget，得到结果，再把结果加到res中，最后返回res</li>
<li>…</li>
<li>nSumTarget，固定一个数字，更新target，然后调用n-1SumTarget，得到结果，再把结果加到res中，最后返回res</li>
</ul>
<p>接下来我们先实现最为简单的<code>twoSumTarget</code>,我们对此加以限制，<strong>即有且有且仅有一个解</strong>，直接排序+双指针：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">twoSumTarget</span>(<span class="params">nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]: </span><br><span class="line">    <span class="comment"># 有且有且仅有一个解，所以返回一个list[int]而不是List[List[int]]</span></span><br><span class="line">    nums.sort() <span class="comment"># 对此排序</span></span><br><span class="line">    l_idx, r_idx = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> l_idx &lt; r_idx:</span><br><span class="line">        left, right = nums[l_idx], nums[r_idx]</span><br><span class="line">        s = left + right</span><br><span class="line">        <span class="keyword">if</span> s == target:</span><br><span class="line">            <span class="keyword">return</span> [left, right]</span><br><span class="line">        <span class="keyword">elif</span> s &lt; target:</span><br><span class="line">            l_idx += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            r_idx -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> [] <span class="comment"># impossible</span></span><br></pre></td></tr></table></figure>


<p>接下来，我们对于限制，稍加松弛，<strong>即可能有多个解</strong>，例如<code>nums = [1,1,1,2,2,3,3], target = 4</code>，存在答案<code>[[1,3],[2,2]]</code>,如果直接仿照上面双指针的写法，如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">twoSumTarget</span>(<span class="params">nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">    <span class="comment"># ❌!! 该方法不对，会陷入死循环</span></span><br><span class="line">    res = []</span><br><span class="line">    nums.sort()</span><br><span class="line">    l_idx, r_idx = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> l_idx &lt; r_idx:</span><br><span class="line">        left, right = nums[l_idx], nums[r_idx]</span><br><span class="line">        s = left + right</span><br><span class="line">        <span class="keyword">if</span> s == target:</span><br><span class="line">            res.append([left, right])</span><br><span class="line">        <span class="keyword">elif</span> s &lt; target:</span><br><span class="line">            l_idx += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            r_idx -= <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>


<p>会陷入死循环，加入到res后，left，right都不变了。下面提供<strong>可能有多个解</strong>的<code>twoSumTarget</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">twoSumTarget</span>(<span class="params">nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">    <span class="comment"># ✔，该方法才是正确的可以解决多个解的2Sum问题</span></span><br><span class="line">    res = []</span><br><span class="line">    nums.sort()</span><br><span class="line">    l_idx, r_idx = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> l_idx &lt; r_idx:</span><br><span class="line">        left, right = nums[l_idx], nums[r_idx]</span><br><span class="line">        s = left + right</span><br><span class="line">        <span class="keyword">if</span> s == target:</span><br><span class="line">            res.append([left, right])</span><br><span class="line">            <span class="keyword">while</span> l_idx &lt; r_idx <span class="keyword">and</span> nums[l_idx] == left:</span><br><span class="line">                l_idx += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> r_idx &gt; l_idx <span class="keyword">and</span> nums[r_idx] == right:</span><br><span class="line">                r_idx -= <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">elif</span> s &lt; target:</span><br><span class="line">            <span class="keyword">while</span> l_idx &lt; r_idx <span class="keyword">and</span> nums[l_idx] == left:</span><br><span class="line">                l_idx += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>：</span><br><span class="line">            <span class="keyword">while</span> r_idx &gt; l_idx <span class="keyword">and</span> nums[r_idx] == right:</span><br><span class="line">                r_idx -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<p>这样，<strong>松弛后可以支持多个解的2Sum问题就被解决了</strong>，现在对该算法的复杂度进行分析，其时间复杂度为O(nlogn + n) &#x3D; O(nlogn)</p>
<hr>
<p>接下来我们来看<code>threeSumTarget(nums: List[int], target: int) -&gt; List[List[int]]</code>此时我们已经完了了<code>twoSumTarget(nums: List[int], target: int) -&gt; List[List[int]]</code>,不难得出：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">threeSumTarget</span>(<span class="params">nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">    res = []</span><br><span class="line">    numms.sort()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># f_idx 第一个元素的下标，i.e. 每一个可行解都是[nums[f_idx],x,x]</span></span><br><span class="line">    f_idx = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> f_idx &lt; <span class="built_in">len</span>(nums):</span><br><span class="line">        first = nums[f_idx]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> pair <span class="keyword">in</span> twoSumTarget(nums[f_idx+<span class="number">1</span>:], target - first): <span class="comment"># 第2,3个元素：</span></span><br><span class="line">            res.append([first] + pair)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> f_idx &lt; <span class="built_in">len</span>(nums) <span class="keyword">and</span> nums[f_idx] == first:</span><br><span class="line">            f_idx += <span class="number">1</span> <span class="comment"># 跳过重复的元素</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<p>对其进行复杂度分析，其时间复杂度为O(nlogn + n*n) &#x3D; O(n^2)，注意此时已经排序好了，所以每次<code>twoSumTarget</code>的复杂度为O(n)</p>
<hr>
<p>接下来我们来看<code>fourSumTarget(nums: List[int], target: int) -&gt; List[List[int]]</code>此时我们已经完了了<code>threeSumTarget(nums: List[int], target: int) -&gt; List[List[int]]</code>,不难得出：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fourSumTarget</span>(<span class="params">nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">    res = []</span><br><span class="line">    nums.sort()</span><br><span class="line"></span><br><span class="line">    f_idx = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> f_idx &lt; <span class="built_in">len</span>(nums):</span><br><span class="line">        first = nums[f_idx]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">tuple</span> <span class="keyword">in</span> threeSumTarget(nums[f_idx+<span class="number">1</span>:], target - first): <span class="comment"># 第2,3,4个元素：</span></span><br><span class="line">            res.append([first] + <span class="built_in">tuple</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> f_idx &lt; <span class="built_in">len</span>(nums) <span class="keyword">and</span> nums[f_idx] == first:</span><br><span class="line">            f_idx += <span class="number">1</span> <span class="comment"># 跳过重复的元素</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>


<hr>
<p>可以明显看出其重叠子问题的结构，现在尝试使用递归的递归方法来实现<code>nSumTarget</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">nSumTarget</span>(<span class="params">nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span>, n: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">    <span class="keyword">assert</span> n &gt;= <span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums) &lt; n:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">2</span>:</span><br><span class="line">        <span class="comment"># 就是把twoSumTarget抄过来</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        l_idx, r_idx = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> l_idx &lt; r_idx:</span><br><span class="line">            left, right = nums[l_idx], nums[r_idx]</span><br><span class="line">            s = left + right</span><br><span class="line">            <span class="keyword">if</span> s == target:</span><br><span class="line">                res.append([left, right])</span><br><span class="line">                <span class="keyword">while</span> l_idx &lt; r_idx <span class="keyword">and</span> nums[l_idx] == left:</span><br><span class="line">                    l_idx += <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> r_idx &gt; l_idx <span class="keyword">and</span> nums[r_idx] == right:</span><br><span class="line">                    r_idx -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">elif</span> s &lt; target:</span><br><span class="line">                <span class="keyword">while</span> l_idx &lt; r_idx <span class="keyword">and</span> nums[l_idx] == left:</span><br><span class="line">                    l_idx += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">while</span> r_idx &gt; l_idx <span class="keyword">and</span> nums[r_idx] == right:</span><br><span class="line">                    r_idx -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        nums.sort()</span><br><span class="line">        f_idx = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> f_idx &lt; <span class="built_in">len</span>(nums):</span><br><span class="line">            first = nums[f_idx]</span><br><span class="line"></span><br><span class="line">            subs = nSumTarget(nums[f_idx + <span class="number">1</span>:], target - first, n - <span class="number">1</span>)  <span class="comment"># 所有子问题的结果</span></span><br><span class="line">            <span class="keyword">for</span> sub <span class="keyword">in</span> subs:</span><br><span class="line">                res.append([first] + sub)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> f_idx &lt; <span class="built_in">len</span>(nums) <span class="keyword">and</span> nums[f_idx] == first:</span><br><span class="line">                f_idx += <span class="number">1</span>  <span class="comment"># 跳过重复的元素</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>


<ul>
<li><a href="https://leetcode.cn/problems/two-sum/description/">Leetcode 1</a> 两数之和<br>首先用回溯暴力枚举试了下，TLE了，如下是TLE的代码</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.res = <span class="literal">None</span></span><br><span class="line">        <span class="variable language_">self</span>.track = []  <span class="comment"># 用于记录index</span></span><br><span class="line">        <span class="variable language_">self</span>.nums = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">self, begin_idx, target</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.res <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(<span class="variable language_">self</span>.track) &gt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        sum_of_track = <span class="built_in">sum</span>([<span class="variable language_">self</span>.nums[_] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="variable language_">self</span>.track])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(<span class="variable language_">self</span>.track) == <span class="number">2</span> <span class="keyword">and</span> sum_of_track == target:</span><br><span class="line">            <span class="variable language_">self</span>.res = <span class="variable language_">self</span>.track[:]</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> idx <span class="keyword">in</span> <span class="built_in">range</span>(begin_idx, <span class="built_in">len</span>(<span class="variable language_">self</span>.nums)):</span><br><span class="line">            <span class="variable language_">self</span>.track.append(idx)</span><br><span class="line">            <span class="variable language_">self</span>.backtrack(idx + <span class="number">1</span>, target)</span><br><span class="line">            <span class="variable language_">self</span>.track.pop()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">twoSum</span>(<span class="params">self, nums, target</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="variable language_">self</span>.nums = nums</span><br><span class="line">        <span class="variable language_">self</span>.backtrack(<span class="number">0</span>, target)</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.res</span><br></pre></td></tr></table></figure>
<p>该算法的复杂度是O(n^2)，显然比哈希表的复杂度要高，哈希表的复杂度是O(n)，使用哈希表的实现如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">twoSum</span>(<span class="params">self, nums, target</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        table = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> idx,num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            <span class="keyword">if</span> num <span class="keyword">in</span> table:</span><br><span class="line">                table[num].append(idx)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                table[num] = [idx]</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> table.keys():</span><br><span class="line">            remain = target - num</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> remain == num:</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">len</span>(table[num]) == <span class="number">2</span>:</span><br><span class="line">                    <span class="keyword">return</span> table[num]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> remain <span class="keyword">in</span> table:</span><br><span class="line">                    <span class="keyword">return</span> [table[num][<span class="number">0</span>],table[remain][<span class="number">0</span>]]</span><br><span class="line">        <span class="keyword">return</span> []</span><br></pre></td></tr></table></figure>

<p>这个题目不是存在多个解的情况，所以不能用上面提到的<code>def twoSumTarget(nums: List[int], target: int) -&gt; List[List[int]]:</code>而是要用<code>def twoSumTarget(nums: List[int], target: int) -&gt; List[int]:</code>,但是这个题目要求返回idx,且题目给的是无序的就很烦，如下是采用双指针的实现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">twoSum</span>(<span class="params">self, nums, target</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 防止后面排序后，找不到之前的idx</span></span><br><span class="line">        table = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> idx,num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            <span class="keyword">if</span> num <span class="keyword">in</span> table:</span><br><span class="line">                table[num].append(idx)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                table[num] = [idx]</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> table.keys():</span><br><span class="line">            remain = target - num</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 开始双指针</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        l_idx,r_idx = <span class="number">0</span>,<span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> l_idx &lt; r_idx:</span><br><span class="line">            left,right = nums[l_idx], nums[r_idx]</span><br><span class="line">            s = left + right</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> s == target:</span><br><span class="line">                <span class="keyword">return</span> [table[left].pop(),table[right].pop()]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">elif</span> s &lt; target:</span><br><span class="line">                l_idx += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                r_idx -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> [] <span class="comment"># impossible</span></span><br></pre></td></tr></table></figure>




<ul>
<li><a href="https://leetcode.cn/problems/3sum/description/">Leetcode 15</a> 三数之和</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">twoSumTarget</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="comment"># ✔，该方法才是正确的可以解决多个解的2Sum问题</span></span><br><span class="line">        res = []</span><br><span class="line">        nums.sort()</span><br><span class="line">        l_idx, r_idx = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> l_idx &lt; r_idx:</span><br><span class="line">            left, right = nums[l_idx], nums[r_idx]</span><br><span class="line">            s = left + right</span><br><span class="line">            <span class="keyword">if</span> s == target:</span><br><span class="line">                res.append([left, right])</span><br><span class="line">                <span class="keyword">while</span> l_idx &lt; r_idx <span class="keyword">and</span> nums[l_idx] == left:</span><br><span class="line">                    l_idx += <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> r_idx &gt; l_idx <span class="keyword">and</span> nums[r_idx] == right:</span><br><span class="line">                    r_idx -= <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">elif</span> s &lt; target:</span><br><span class="line">                <span class="keyword">while</span> l_idx &lt; r_idx <span class="keyword">and</span> nums[l_idx] == left:</span><br><span class="line">                    l_idx += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">while</span> r_idx &gt; l_idx <span class="keyword">and</span> nums[r_idx] == right:</span><br><span class="line">                    r_idx -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">threeSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        res = []</span><br><span class="line">        nums.sort()</span><br><span class="line">        f_idx = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> f_idx &lt; <span class="built_in">len</span>(nums):</span><br><span class="line">            first = nums[f_idx]</span><br><span class="line">            <span class="keyword">for</span> two_sum_res <span class="keyword">in</span> <span class="variable language_">self</span>.twoSumTarget(nums = nums[f_idx+<span class="number">1</span>:],target = <span class="number">0</span> - first):</span><br><span class="line">                res.append([first] + two_sum_res)</span><br><span class="line">            <span class="keyword">while</span> f_idx&lt; <span class="built_in">len</span>(nums) <span class="keyword">and</span> first == nums[f_idx]:</span><br><span class="line">                f_idx += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>


<ul>
<li><a href="https://leetcode.cn/problems/4sum/description/">Leetcode 18</a> 四数之和<br>非要头铁回溯，TLE了，回溯的代码如下：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.track = []</span><br><span class="line">        <span class="variable language_">self</span>.res = []</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">self,candidates,target</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(<span class="variable language_">self</span>.track) &gt; <span class="number">4</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(<span class="variable language_">self</span>.track) == <span class="number">4</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">sum</span>(<span class="variable language_">self</span>.track) == target:</span><br><span class="line">                <span class="variable language_">self</span>.res.append(<span class="variable language_">self</span>.track[:])</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> idx,candidate <span class="keyword">in</span> <span class="built_in">enumerate</span>(candidates):</span><br><span class="line">            <span class="keyword">if</span> idx - <span class="number">1</span> &gt;= <span class="number">0</span> <span class="keyword">and</span> candidates[idx - <span class="number">1</span>] == candidates[idx]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="variable language_">self</span>.track.append(candidate)</span><br><span class="line">            <span class="variable language_">self</span>.backtrack(candidates[idx+<span class="number">1</span>:],target)</span><br><span class="line">            <span class="variable language_">self</span>.track.pop()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fourSum</span>(<span class="params">self, nums, target</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        <span class="variable language_">self</span>.backtrack(nums,target)</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.res</span><br></pre></td></tr></table></figure>
<p>超时的原因是没有办法合理的剪枝,如下是依据<code>threeSum</code>的思路，利用双指针解决<code>fourSum</code>，如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">twoSumTarget</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="comment"># ✔，该方法才是正确的可以解决多个解的2Sum问题</span></span><br><span class="line">        res = []</span><br><span class="line">        nums.sort()</span><br><span class="line">        l_idx, r_idx = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> l_idx &lt; r_idx:</span><br><span class="line">            left, right = nums[l_idx], nums[r_idx]</span><br><span class="line">            s = left + right</span><br><span class="line">            <span class="keyword">if</span> s == target:</span><br><span class="line">                res.append([left, right])</span><br><span class="line">                <span class="keyword">while</span> l_idx &lt; r_idx <span class="keyword">and</span> nums[l_idx] == left:</span><br><span class="line">                    l_idx += <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> r_idx &gt; l_idx <span class="keyword">and</span> nums[r_idx] == right:</span><br><span class="line">                    r_idx -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">elif</span> s &lt; target:</span><br><span class="line">                <span class="keyword">while</span> l_idx &lt; r_idx <span class="keyword">and</span> nums[l_idx] == left:</span><br><span class="line">                    l_idx += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">while</span> r_idx &gt; l_idx <span class="keyword">and</span> nums[r_idx] == right:</span><br><span class="line">                    r_idx -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">threeSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        res = []</span><br><span class="line">        nums.sort()</span><br><span class="line">        f_idx = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> f_idx &lt; <span class="built_in">len</span>(nums):</span><br><span class="line">            first = nums[f_idx]</span><br><span class="line">            <span class="keyword">for</span> two_sum_res <span class="keyword">in</span> <span class="variable language_">self</span>.twoSumTarget(nums=nums[f_idx + <span class="number">1</span>:], target=target - first):</span><br><span class="line">                res.append([first] + two_sum_res)</span><br><span class="line">            <span class="keyword">while</span> f_idx &lt; <span class="built_in">len</span>(nums) <span class="keyword">and</span> first == nums[f_idx]:</span><br><span class="line">                f_idx += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fourSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        res = []</span><br><span class="line">        nums.sort()</span><br><span class="line"></span><br><span class="line">        f_idx = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> f_idx &lt; <span class="built_in">len</span>(nums):</span><br><span class="line">            first = nums[f_idx]</span><br><span class="line">            <span class="keyword">for</span> three_sum_res <span class="keyword">in</span> <span class="variable language_">self</span>.threeSum(nums=nums[f_idx + <span class="number">1</span>:], target=target - first):</span><br><span class="line">                res.append([first] + three_sum_res)</span><br><span class="line">            <span class="keyword">while</span> f_idx &lt; <span class="built_in">len</span>(nums) <span class="keyword">and</span> first == nums[f_idx]:</span><br><span class="line">                f_idx += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>


<h3 id="小而美的算法技巧：前缀和数组"><a href="#小而美的算法技巧：前缀和数组" class="headerlink" title="小而美的算法技巧：前缀和数组"></a><a href="https://labuladong.online/algo/data-structure/prefix-sum/">小而美的算法技巧：前缀和数组</a></h3><blockquote>
<p>前缀和技巧适用于快速、频繁地计算一个索引区间内的元素之和。<br>前缀和的核心是需要pedding 0，否则会出现越界。</p>
</blockquote>
<h4 id="1-d-前缀和"><a href="#1-d-前缀和" class="headerlink" title="1-d 前缀和"></a>1-d 前缀和</h4><ul>
<li><a href="https://leetcode.cn/problems/range-sum-query-immutable/description/">Leetcode 303</a> 区域和检索-数组不可变<br>对于给定的数组$nums$其长度为$n$，我们定义如下前缀和数组$preSum$其长度为$[n+1]$，定义如下：<br>$$<br>preSum[0] &#x3D; 0\<br>preSum[i] &#x3D; nums[0] + nums[1] + … + nums[i-1] \forall i \in [1,n]<br>$$<br>$preSum[i]$ 表示区间 $[0,i)$ 的元素之和，对于API<code>sumRange(self, left: int, right: int)</code>希望求出区间 $[left,right]$ 的元素之和，可以直接返回:<br>$$<br>\begin{align*}<br>  &amp;nums[left] + …+ nums[right] \<br>  &amp;&#x3D;  nums[0] +…+nums[left] + …+ nums[right] -( nums[0] + … + nums[left-1])\<br>  &amp;&#x3D; preSum[right+1] - preSum[left]<br>\end{align*}<br>$$<br>其具体实现，如下，注意该类后面有很多题目都需要用到</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NumArray</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, nums</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="variable language_">self</span>.prefix_sum = [<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="variable language_">self</span>.prefix_sum.append(<span class="variable language_">self</span>.prefix_sum[-<span class="number">1</span>] + num)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sumRange</span>(<span class="params">self, left, right</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type left: int</span></span><br><span class="line"><span class="string">        :type right: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.prefix_sum[right + <span class="number">1</span>] - <span class="variable language_">self</span>.prefix_sum[left]</span><br></pre></td></tr></table></figure>

<h4 id="2-d-前缀和"><a href="#2-d-前缀和" class="headerlink" title="2-d 前缀和"></a>2-d 前缀和</h4><ul>
<li><a href="https://leetcode.cn/problems/range-sum-query-2d-immutable/description/">Leetcode 304*</a> 二维区域和检索-矩阵不可变<br>对于给定的二维数组$matrix$，其长度为$m$行$n$列，我们定义如下前缀和数组$preSum$其长度为$[m+1,n+1]$，定义如下：</li>
</ul>
<p>$$<br>\begin{align*}<br>preSum[i,j] &amp;&#x3D; 0 \quad i &#x3D; 0 or j &#x3D; 0\<br>preSum[i,j] &amp;&#x3D; matrix[0,0] + … + matrix[i-1,j-1] \forall i,j \in [1,m],[1,n]<br>\end{align*}<br>$$</p>
<p>对于给定的API<code>sumRegion(self, row1: int, col1: int, row2: int, col2: int)</code>希望求出矩阵$matrix$中左上角为$(row1,col1)$，右下角为$(row2,col2)$的元素之和，i.e. $\sum_{i&#x3D;row1}^{row2}\sum_{j&#x3D;col1}^{col2}matrix[i,j]$,证明如下：<br>$$<br>\begin{align*}<br>\sum_{i&#x3D;row1}^{row2}\sum_{j&#x3D;col1}^{col2}matrix[i,j] &amp;&#x3D; matrix[row1,col1] + … + matrix[row2,col2]\<br>\end{align*}<br>$$<br>具体可以拆解为：<br><img src="/../images/1745582349133-image.png" alt="alt text"></p>
<p>那么该题的答案为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NumMatrix</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, matrix</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type matrix: List[List[int]]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        m = <span class="built_in">len</span>(matrix)</span><br><span class="line">        n = <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">self</span>.pre_sum = [[<span class="number">0</span>]*(n+<span class="number">1</span>)<span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m+<span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,m+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 我们此时已经知道了pre_sum[i-1][j-1],pre_sum[i][j-1],pre_sum[i-1][j],</span></span><br><span class="line">                <span class="comment"># 比较蠢的是如下计算，会TLE</span></span><br><span class="line">                <span class="comment"># s = 0</span></span><br><span class="line">                <span class="comment"># for _i in range(i):</span></span><br><span class="line">                <span class="comment">#     for _j in range(j):</span></span><br><span class="line">                <span class="comment">#         s += matrix[_i][_j]</span></span><br><span class="line">                <span class="comment"># self.pre_sum[i][j] = s</span></span><br><span class="line"></span><br><span class="line">                <span class="comment"># 如下是比较聪明的写法</span></span><br><span class="line">                <span class="variable language_">self</span>.pre_sum[i][j] = <span class="variable language_">self</span>.pre_sum[i-<span class="number">1</span>][j] + <span class="variable language_">self</span>.pre_sum[i][j -<span class="number">1</span>] - <span class="variable language_">self</span>.pre_sum[i-<span class="number">1</span>][j-<span class="number">1</span>]  + matrix[i-<span class="number">1</span>][j-<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sumRegion</span>(<span class="params">self, row1, col1, row2, col2</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type row1: int</span></span><br><span class="line"><span class="string">        :type col1: int</span></span><br><span class="line"><span class="string">        :type row2: int</span></span><br><span class="line"><span class="string">        :type col2: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        res += <span class="variable language_">self</span>.pre_sum[row2+<span class="number">1</span>][col2+<span class="number">1</span>]</span><br><span class="line">        res -= <span class="variable language_">self</span>.pre_sum[row2+<span class="number">1</span>][col1]</span><br><span class="line">        res -= <span class="variable language_">self</span>.pre_sum[row1][col2+<span class="number">1</span>]</span><br><span class="line">        res += <span class="variable language_">self</span>.pre_sum[row1][col1]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>



<h3 id="【强化练习】前缀和技巧经典习题"><a href="#【强化练习】前缀和技巧经典习题" class="headerlink" title="【强化练习】前缀和技巧经典习题"></a><a href="https://labuladong.online/algo/problem-set/perfix-sum/">【强化练习】前缀和技巧经典习题</a></h3><!-- - 1314. 矩阵区域和
- 724. 寻找数组的中心下标
- 238. 除自身以外数组的乘积
- 1352. 最后 K 个数的乘积
- 525. 连续数组
- 523. 连续的子数组和
- 560. 和为K的子数组
- 974. 和可被 K 整除的子数组之和
- 1124. 表现良好的最长时间段 -->

<h4 id="prefix-sum"><a href="#prefix-sum" class="headerlink" title="prefix sum"></a>prefix sum</h4><ul>
<li><a href="https://leetcode.cn/problems/matrix-block-sum/description/">Leetcode 1314*</a> 矩阵区域和<br>对于给定的二维数组$matrix$，其长度为$m$行$n$列，我们给其pedding 0, 上下左右都各自pedding k 条 0，构成一个新的二维数组$matrix_p$，其$k+m+k &#x3D; m+2k$行 $n+2k &#x3D; n+2k$列，这两个矩阵的转换为:<br>$$<br>matrix[i,j] &#x3D; matrix_p[i+k,j+k] \quad \forall i\in[0,m-1],j\in[0,n-1]<br>$$<br>另外一方面<br>$$<br>matrix_p[i,j] &#x3D;<br>\begin{cases}<br>&amp;matrix[i-k,j-k] &#x3D; matrix_p[i+k,j+k]  \quad\forall i\in[k,k+m-1],j\in[k,k+n-1] \<br>&amp;0 \quad\forall i\in[0,k-1]\cup[k+m,m+2k-1],j\in[0,k-1]\cup[k+n,n+2k-1]<br>\end{cases}<br>$$<br>对于矩阵$matrix_p$其大小为$(m+2k)\times (m+2k)$，我们如下定义其前缀和数组$preSum$，其大小为$(m+2k+1)\times (m+2k+1)$，定义如下：<br>$$<br>preSum[i,j] &#x3D;<br>\begin{cases}<br>&amp;0 \quad\forall i &#x3D;  0 \text{ OR } j &#x3D; 0\<br>&amp;matrix_p[0,0] +… + matrix_p[i-1,j-1]    \quad\forall i\in[1,m+2k]\cup[1,n+2k]<br>\end{cases}<br>$$<br>对于前缀和矩阵的计算，我们可以递推出：<br>$$<br>preSum[i,j] &#x3D; preSum[i-1,j] + preSum[i,j-1] - preSum[i-1,j-1] + matrix_p[i-1,j-1]<br>$$<br>利用上述递推公式，我们可以以较小的时间复杂度计算出前缀和矩阵，对于要最终返回的矩阵，其大小为$m$行$n$列，我们定义其为$res$矩阵，考虑到其于$matrix$大小相等，我们也可可以直接写道$matrix$上，对于$res[i^<em>,j^</em>] \quad \forall i^<em>\in[0,m-1],j^</em>\in[0,n-1]$ 我们有：<br>$$<br>\begin{align*}<br>  res[i^<em>,j^</em>] &amp;&#x3D; \sum_{i&#x3D;i^<em>}^{i^</em>+2k}\sum_{j&#x3D;j^<em>}^{j^</em>+2k}matrix_p[i,j]\<br>  &amp;&#x3D; matrix_p\text{中 左上为}(i^<em>,j^</em>)到右下为(i^<em>+2k,j^</em>+2k)矩形的和\<br>  &amp;&#x3D; preSum[i^<em>+2k+1,j^</em>+2k+1] \<br>  &amp;- preSum[i^<em>,j^</em>+2k+1] \<br>  &amp;- preSum[i^<em>+2k+1,j^</em>] \<br>  &amp;+ preSum[i^<em>,j^</em>]<br>\end{align*}<br>$$<br>最终，其代码如下：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">matrixBlockSum</span>(<span class="params">self, mat, k</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type mat: List[List[int]]</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        m = <span class="built_in">len</span>(mat)</span><br><span class="line">        n = <span class="built_in">len</span>(mat[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 构造pedding后的矩阵,其shape = (m+2*k)行(n+2*k)列</span></span><br><span class="line">        mat_p = [[<span class="number">0</span>] * (n + <span class="number">2</span> * k) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m + <span class="number">2</span> * k)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k, m + k):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(k, n + k):</span><br><span class="line">                mat_p[i][j] = mat[i - k][j - k]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 构造pre_sum矩阵，其shape = (m+2*k+1)行(n+2*k+1)列</span></span><br><span class="line">        pre_sum = [[<span class="number">0</span>] * (n + <span class="number">2</span> * k + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m + <span class="number">2</span> * k + <span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m + <span class="number">2</span> * k + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">2</span> * k + <span class="number">1</span>):</span><br><span class="line">                pre_sum[i][j] = pre_sum[i - <span class="number">1</span>][j] + pre_sum[i][j - <span class="number">1</span>] - pre_sum[i - <span class="number">1</span>][j - <span class="number">1</span>] + mat_p[i - <span class="number">1</span>][j - <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 构造最终返回的二维数组，其shape = (m)行(n)列，也可以直接用mat</span></span><br><span class="line">        res = [[<span class="number">0</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                tmp = pre_sum[i + <span class="number">2</span> * k + <span class="number">1</span>][j + <span class="number">2</span> * k + <span class="number">1</span>]</span><br><span class="line">                tmp -= pre_sum[i][j + <span class="number">2</span> * k + <span class="number">1</span>]</span><br><span class="line">                tmp -= pre_sum[i + <span class="number">2</span> * k + <span class="number">1</span>][j]</span><br><span class="line">                tmp += pre_sum[i][j]</span><br><span class="line">                res[i][j] = tmp</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p>该题作为2-d前缀和的衍生题目，在<a href="https://leetcode.cn/problems/range-sum-query-2d-immutable/description/">Leetcode 304</a> 实现的<code>NumMatrix.regionSum</code>函数的基础上，我们可以快速得到答案：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NumMatrix</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment"># 详见 [Leetcode 304](https://leetcode.cn/problems/range-sum-query-2d-immutable/description/)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">matrixBlockSum</span>(<span class="params">self, mat, k</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type mat: List[List[int]]</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        m = <span class="built_in">len</span>(mat)</span><br><span class="line">        n = <span class="built_in">len</span>(mat[<span class="number">0</span>])</span><br><span class="line">        num_mat = NumMatrix(mat)</span><br><span class="line">        res = [[<span class="number">0</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                row1, col1 = <span class="built_in">max</span>(i-k,<span class="number">0</span>),<span class="built_in">max</span>(j-k,<span class="number">0</span>) <span class="comment"># 左上角</span></span><br><span class="line">                row2, col2 = <span class="built_in">min</span>(i+k,m-<span class="number">1</span>),<span class="built_in">min</span>(j+k,n-<span class="number">1</span>) <span class="comment"># 右下角</span></span><br><span class="line">                res[i][j] = num_mat.sumRegion(row1, col1, row2, col2)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<ul>
<li><a href="https://leetcode.cn/problems/find-pivot-index/description/">Leetcode 724*</a> 寻找数组的中心下标<br>在前面1-d前缀和的基础上，我们可以快速得到答案：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NumArray</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="comment"># 详见 [Leetcode 303](https://leetcode.cn/problems/range-sum-query-immutable/)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pivotIndex</span>(<span class="params">self, nums</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        num_array = NumArray(nums)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> idx <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> num_array.sumRange(<span class="number">0</span>,idx-<span class="number">1</span>) == num_array.sumRange(idx+<span class="number">1</span>,<span class="built_in">len</span>(nums)-<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">return</span> idx</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span> <span class="comment"># Not found</span></span><br></pre></td></tr></table></figure>

<h4 id="prefix-product"><a href="#prefix-product" class="headerlink" title="prefix product"></a>prefix product</h4><ul>
<li><a href="https://leetcode.cn/problems/product-of-array-except-self/description/">Leetcode 238*</a> 除自身以外数组的乘积<br>同类型的题目还有<a href="https://leetcode.cn/problems/gou-jian-cheng-ji-shu-zu-lcof/description/">LCR 191</a>. 同时构造前缀和和后缀和数组，我们可以快速得到答案：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">productExceptSelf</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line"></span><br><span class="line">        prefix = [<span class="number">1</span>] *(n+<span class="number">1</span>) </span><br><span class="line">        <span class="keyword">for</span> idx <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">            prefix[idx] = prefix[idx-<span class="number">1</span>] * nums[idx-<span class="number">1</span>]</span><br><span class="line">        <span class="comment"># perfix[0] = 1</span></span><br><span class="line">        <span class="comment"># perfix[1] = 1 * nums[0]</span></span><br><span class="line">        <span class="comment"># perfix[2] = 1 * nums[0] * nums[1]</span></span><br><span class="line">        <span class="comment"># ...</span></span><br><span class="line">        <span class="comment"># forall i &gt;= 1</span></span><br><span class="line">        <span class="comment"># perfix[i] = nums[0] * nums[1] *..*nums[i-2]  *nums[i-1] </span></span><br><span class="line">        <span class="comment">#           =(nums[0] * nums[1] *..*nums[i-2]) *nums[i-1] </span></span><br><span class="line">        <span class="comment">#           =perfix[i-1]**nums[i-1]</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        surfix = [<span class="number">1</span>] *(n+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> idx <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">            surfix[idx] = surfix[idx+<span class="number">1</span>] * nums[idx] </span><br><span class="line">        <span class="comment"># surfix[n] = 1</span></span><br><span class="line">        <span class="comment"># surfix[n-1] = nums[n-1] * 1</span></span><br><span class="line">        <span class="comment"># surfix[n-2] = nums[n-2] * nums[n-1] * 1</span></span><br><span class="line">        <span class="comment"># ...</span></span><br><span class="line">        <span class="comment"># forall i &lt;= n-1 </span></span><br><span class="line">        <span class="comment"># surfix[i] = nums[i] *nums[i+1]*...* nums[n-1] * 1</span></span><br><span class="line">        <span class="comment">#           = nums[i] *(nums[i+1]*...* nums[n-1] * 1)</span></span><br><span class="line">        <span class="comment">#           = nums[i] * surfix[i+1]</span></span><br><span class="line"></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> idx <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            res.append(prefix[idx]*surfix[idx+<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<ul>
<li><a href="https://leetcode.cn/problems/product-of-the-last-k-numbers/description/">Leetcode 1352*</a> 最后 K 个数的乘积<br>最朴素的想法就是后缀积数组，但是TLE：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ProductOfNumbers</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.surfix = [<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self, num: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="variable language_">self</span>.surfix = [_*num <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="variable language_">self</span>.surfix]</span><br><span class="line">        <span class="variable language_">self</span>.surfix.append(<span class="number">1</span>)</span><br><span class="line">        <span class="comment"># print(f&quot;add=&#123;num&#125;,then surfix=&#123;self.surfix&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getProduct</span>(<span class="params">self, k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># print(f&quot;get=&#123;k&#125; of surfix=&#123;self.surfix&#125;&quot;)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.surfix[-k-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<p>由于元素是以流的形式输入的，每加入一个元素，后缀和需要整个都更新一遍，没办法以O(1)的时间复杂度更新<code>surfix</code>。只能用<code>prefix</code>,那么应该如何解决这个问题呢？</p>
<ul>
<li>首先假设：输入的数据流没有0.假如输入了<code>1,2,3,4,5</code>,此时的<code>prefix = [1,1,2,6,24,120]</code>,则此时<code>getProduct(2) = 4*5 = prefix[-1]/prefix[-2-1] = 120/6=20</code>.i.e. <code>getProduct(k)=prefix[-1]/prefix[-k-1]</code></li>
<li>假设输入的数据流中有0，输入<code>1,2,0,4,5</code>，此时的<code>prefix = [1,1,2,0,0,0]</code>显然没有办法采用上面的办法。<strong>如果输入了0，我们就重置prefix为[1]</strong> 如果<code>k&lt;len(prefix)</code>则说明0后面的后缀乘积，不受影响<code>getProduct(k)=prefix[-1]/prefix[-k-1]</code>。如果<code>k&gt;=len(prefix)</code>则说明乘积中包含0，则必为0。<br>基于上述想法的代码实现如下：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ProductOfNumbers</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.prefix = [<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self, num: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">if</span> num == <span class="number">0</span>:</span><br><span class="line">            <span class="variable language_">self</span>.prefix = [<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="variable language_">self</span>.prefix.append(<span class="variable language_">self</span>.prefix[-<span class="number">1</span>] * num)</span><br><span class="line">        <span class="comment"># print(f&quot;add=&#123;num&#125;,prefix=&#123;self.prefix&#125;&quot;)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getProduct</span>(<span class="params">self, k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># print(f&quot;k=&#123;k&#125;,with prefix=&#123;self.prefix&#125;&quot;)</span></span><br><span class="line">        <span class="keyword">if</span> k &gt;= <span class="built_in">len</span>(<span class="variable language_">self</span>.prefix):</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">self</span>.prefix[-<span class="number">1</span>] // <span class="variable language_">self</span>.prefix[-k-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<h4 id="prefix-sum-hashmap"><a href="#prefix-sum-hashmap" class="headerlink" title="prefix sum + hashmap"></a>prefix sum + hashmap</h4><ul>
<li><a href="https://leetcode.cn/problems/contiguous-array/">Leetcode 525*</a> 连续数组<br>上来就暴力枚举，复杂度$O(n^2)$，显然问题规模到$10^5$,会TLE：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NumArray</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, nums</span>):</span><br><span class="line">        <span class="variable language_">self</span>.prefix_sum = [<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="variable language_">self</span>.prefix_sum.append(<span class="variable language_">self</span>.prefix_sum[-<span class="number">1</span>] + num)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sumRange</span>(<span class="params">self, left, right</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.prefix_sum[right + <span class="number">1</span>] - <span class="variable language_">self</span>.prefix_sum[left]</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findMaxLength</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n =<span class="built_in">len</span>(nums)</span><br><span class="line">        num_arr = NumArray(nums)</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>,n):</span><br><span class="line">                cur_len = j - i +<span class="number">1</span></span><br><span class="line">                cnt_1 = num_arr.sumRange(i,j)</span><br><span class="line">                <span class="keyword">if</span> cnt_1 + cnt_1 == cur_len:</span><br><span class="line">                    res = <span class="built_in">max</span>(res,cur_len)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p>首先在没有看解析之前，尝试使用前缀和+双指针的方法解决,优化到O(n)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NumArray</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, nums</span>):</span><br><span class="line">        <span class="variable language_">self</span>.prefix_sum = [<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="variable language_">self</span>.prefix_sum.append(<span class="variable language_">self</span>.prefix_sum[-<span class="number">1</span>] + num)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sumRange</span>(<span class="params">self, left, right</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.prefix_sum[right + <span class="number">1</span>] - <span class="variable language_">self</span>.prefix_sum[left]</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findMaxLength</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        num_arr = NumArray(nums)</span><br><span class="line">        l_idx, r_idx = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> l_idx &lt; r_idx:</span><br><span class="line">            cur_len = r_idx - l_idx + <span class="number">1</span></span><br><span class="line">            cnt_1 = num_arr.sumRange(l_idx, r_idx)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> cnt_1 + cnt_1 == cur_len: <span class="comment"># 刚刚好</span></span><br><span class="line">                <span class="keyword">return</span> cur_len</span><br><span class="line"></span><br><span class="line">            <span class="keyword">elif</span> cnt_1 + cnt_1 &lt; cur_len:  <span class="comment"># 1 太少, 0太多</span></span><br><span class="line">                <span class="keyword">if</span> nums[l_idx] == <span class="number">0</span>:</span><br><span class="line">                    l_idx += <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> nums[r_idx] == <span class="number">0</span>:</span><br><span class="line">                    r_idx -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">assert</span> nums[l_idx] == <span class="number">1</span> <span class="keyword">and</span> nums[r_idx] == <span class="number">1</span></span><br><span class="line">                    <span class="comment"># 移动最接近0的那一边</span></span><br><span class="line">                    flag = <span class="literal">None</span></span><br><span class="line">                    _ = <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> l_idx + _ &lt; r_idx <span class="keyword">and</span> r_idx - _ &gt; l_idx:</span><br><span class="line">                        <span class="keyword">if</span> nums[l_idx + _] == <span class="number">0</span>:</span><br><span class="line">                            flag = <span class="number">1</span>  <span class="comment"># l_idx 更有潜力</span></span><br><span class="line">                            <span class="keyword">break</span></span><br><span class="line">                        <span class="keyword">elif</span> nums[r_idx - _] == <span class="number">0</span>:</span><br><span class="line">                            flag = -<span class="number">1</span>  <span class="comment"># r_idx 更有潜力</span></span><br><span class="line">                            <span class="keyword">break</span></span><br><span class="line">                        _ += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> flag == <span class="number">1</span>:</span><br><span class="line">                        l_idx += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">elif</span> flag == -<span class="number">1</span>:</span><br><span class="line">                        r_idx -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="keyword">raise</span> ValueError(<span class="string">&#x27;fuck!&#x27;</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span>:  <span class="comment"># 1 太多, 0太少</span></span><br><span class="line">                <span class="keyword">if</span> nums[l_idx] == <span class="number">1</span>:</span><br><span class="line">                    l_idx += <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> nums[r_idx] == <span class="number">1</span>:</span><br><span class="line">                    r_idx -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">assert</span> nums[l_idx] == <span class="number">0</span> <span class="keyword">and</span> nums[r_idx] == <span class="number">0</span></span><br><span class="line">                    <span class="comment"># 移动最接近1的那一边</span></span><br><span class="line">                    flag = <span class="literal">None</span></span><br><span class="line">                    _ = <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> l_idx + _ &lt; r_idx <span class="keyword">and</span> r_idx - _ &gt; l_idx:</span><br><span class="line">                        <span class="keyword">if</span> nums[l_idx + _] == <span class="number">1</span>:</span><br><span class="line">                            flag = <span class="number">1</span>  <span class="comment"># l_idx 更有潜力</span></span><br><span class="line">                            <span class="keyword">break</span></span><br><span class="line">                        <span class="keyword">elif</span> nums[r_idx - _] == <span class="number">1</span>:</span><br><span class="line">                            flag = -<span class="number">1</span>  <span class="comment"># r_idx 更有潜力</span></span><br><span class="line">                            <span class="keyword">break</span></span><br><span class="line">                        _ += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> flag == <span class="number">1</span>:</span><br><span class="line">                        l_idx += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">elif</span> flag == -<span class="number">1</span>:</span><br><span class="line">                        r_idx -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="keyword">raise</span> ValueError(<span class="string">&#x27;fuck!&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> <span class="comment"># 没有找到，nums可能全0 or 全1</span></span><br></pre></td></tr></table></figure>
<p>这个算法的核心就是就是判断<code>l_idx</code>和<code>r_idx</code>之间是否满足<code>cnt_1 + cnt_1 == cur_len</code>，如果满足，则返回<code>cur_len</code>，如果不满足，则移动<code>l_idx</code>和<code>r_idx</code>到趋向<code>cnt_1 + cnt_1 == cur_len</code>的方向，但是没有办法过所有的测力，例如：<code>[0,1,1,0,1,1,1,0]</code>,一开始左右都为0，算法就比较懵逼，到底移动那个？。</p>
<p>对于这个题目，比较好的一个思路是：</p>
<ul>
<li><strong>将数组中的0替换为-1</strong>，这样我们就可以不用关心字串的长度，和字串的和是不是长度的一半了，只用关心字串的和是否为0</li>
<li><strong>建立一个preSum-&gt;[idx]的映射</strong>，对于相同preSum的不用idx，其构成的字串是符合要求的<br>这个技巧非常的巧妙，代码实现起来也不难：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findMaxLength</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line"></span><br><span class="line">        nums = [-<span class="number">1</span> <span class="keyword">if</span> _ == <span class="number">0</span> <span class="keyword">else</span> _ <span class="keyword">for</span> _ <span class="keyword">in</span> nums]</span><br><span class="line"></span><br><span class="line">        pre_sum = [<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> nums:</span><br><span class="line">            pre_sum.append(pre_sum[-<span class="number">1</span>] + _)</span><br><span class="line"></span><br><span class="line">        ps2idxs = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> idx,ps <span class="keyword">in</span> <span class="built_in">enumerate</span>(pre_sum):</span><br><span class="line">            <span class="keyword">if</span> ps <span class="keyword">in</span> ps2idxs:</span><br><span class="line">                ps2idxs[ps].append(idx)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ps2idxs[ps] = [idx]</span><br><span class="line"></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> _,val <span class="keyword">in</span> ps2idxs.items():</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(val) &gt;=<span class="number">2</span> :</span><br><span class="line">                res = <span class="built_in">max</span>(res,val[-<span class="number">1</span>]-val[<span class="number">0</span>])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<ul>
<li><a href="https://leetcode.cn/problems/subarray-sum-equals-k/description/">Leetcode 560</a> 子数组元素和为K<br>也是和上面的题目一样，采用了前缀和+hashmap的技巧，构造<code>ps2idxs</code>，具体的方法如下：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">subarraySum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        pre_sum = [<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> nums:</span><br><span class="line">            pre_sum.append(pre_sum[-<span class="number">1</span>] + _)</span><br><span class="line"></span><br><span class="line">        ps2idxs = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> idx, ps <span class="keyword">in</span> <span class="built_in">enumerate</span>(pre_sum):</span><br><span class="line">            <span class="keyword">if</span> ps <span class="keyword">in</span> ps2idxs:</span><br><span class="line">                ps2idxs[ps].append(idx)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ps2idxs[ps] = [idx]</span><br><span class="line"></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> ps, idxs <span class="keyword">in</span> ps2idxs.items():</span><br><span class="line">            <span class="comment"># k == 0, ps+k = ps in ps2idxs for sure</span></span><br><span class="line">            <span class="keyword">if</span> k == <span class="number">0</span>:</span><br><span class="line">                res += ((<span class="built_in">len</span>(idxs) - <span class="number">1</span>) * <span class="built_in">len</span>(idxs) // <span class="number">2</span>) <span class="comment"># C_n^2</span></span><br><span class="line">            <span class="comment"># assert k != 0</span></span><br><span class="line">            <span class="keyword">elif</span> ps + k <span class="keyword">in</span> ps2idxs:</span><br><span class="line">                _idxs = ps2idxs[ps + k]</span><br><span class="line">                <span class="comment"># you can not res += len(idxs) * len(_idxs) </span></span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> idxs:</span><br><span class="line">                    <span class="keyword">for</span> j <span class="keyword">in</span> _idxs:</span><br><span class="line">                        <span class="keyword">if</span> i &lt; j:</span><br><span class="line">                            res += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p><strong>这个题目之所以不能采用sliding window，是因为给定的数组中是有负数的</strong>，所以不能用sliding window，而是采用前缀和+hashmap的技巧。</p>
<ul>
<li><a href="https://leetcode.cn/problems/subarray-sums-divisible-by-k/description/">Leetcode 974*</a> 子数组和可被K整除的个数<br>不难用前缀和+暴力枚举可以以$O(n^2)$的复杂度完成题目，但是问题的复杂度到了$10^4$采用此方法会导致TLE</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">   <span class="keyword">def</span> <span class="title function_">subarraysDivByK</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">       pre_sum = [<span class="number">0</span>]</span><br><span class="line">       <span class="keyword">for</span> _ <span class="keyword">in</span> nums:</span><br><span class="line">           pre_sum.append(pre_sum[-<span class="number">1</span>] + _)</span><br><span class="line"></span><br><span class="line">       res = <span class="number">0</span></span><br><span class="line">       <span class="keyword">for</span> l <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">           <span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(l,<span class="built_in">len</span>(nums)):</span><br><span class="line">               range_sum = pre_sum[r+<span class="number">1</span>]-pre_sum[l]</span><br><span class="line">               <span class="keyword">if</span> range_sum % k == <span class="number">0</span>:</span><br><span class="line">                   res += <span class="number">1</span></span><br><span class="line">       <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p>该题目的技巧是：<br>$$<br>\sum_{i\in [l,r]} nums[i] \textbf{ mod } K &#x3D; 0  \<br>\Downarrow  \<br>\sum_{i\in [l,r]} nums[i] \textbf{ mod } K &#x3D; \sum_{i\in [0,r]} nums[i] \textbf{ mod } K - \sum_{i\in [0,l-1]} nums[i] \textbf{ mod } K &#x3D; 0\<br>\Downarrow  \<br>\sum_{i\in [0,r]} nums[i] \textbf{ mod } K &#x3D; \sum_{i\in [0,l-1]} nums[i] \textbf{ mod } K<br>$$<br>合法的子数组的要求$l,r,s.t. \sum_{i\in [0,r]} nums[i] \textbf{ mod } K &#x3D; \sum_{i\in [0,l-1]} nums[i] \textbf{ mod } K$ 以用hashmap记录一个余数到idxs的映射<code>reminder2idxs</code>，然后遍历<code>reminder2idxs</code>，找到满足条件的<code>l,r</code>，然后更新<code>res</code>，最后返回<code>res</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">subarraysDivByK</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        pre_sum = [<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> nums:</span><br><span class="line">            pre_sum.append(pre_sum[-<span class="number">1</span>] + _)</span><br><span class="line"></span><br><span class="line">        reminder2idxs = &#123;&#125;  <span class="comment"># 余数-&gt;idxs的映射</span></span><br><span class="line">        <span class="keyword">for</span> idx, ps <span class="keyword">in</span> <span class="built_in">enumerate</span>(pre_sum):</span><br><span class="line">            reminder = ps % k</span><br><span class="line">            <span class="keyword">if</span> reminder <span class="keyword">in</span> reminder2idxs:</span><br><span class="line">                reminder2idxs[reminder].append(idx)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                reminder2idxs[reminder] = [idx]</span><br><span class="line"></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> reminder, idxs <span class="keyword">in</span> reminder2idxs.items():</span><br><span class="line">            res += <span class="built_in">len</span>(idxs) * (<span class="built_in">len</span>(idxs) - <span class="number">1</span>) // <span class="number">2</span> <span class="comment"># C_n^2. i.e. choose 2  elements from idxs</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>


<ul>
<li><a href="https://leetcode.cn/problems/longest-well-performing-interval/">Leetcode 1124*</a> 表现良好的最长时间段<br>与上面的题目一样，容易知道$O(n^2)$的算法：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">longestWPI</span>(<span class="params">self, hours: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        nums = [<span class="number">1</span> <span class="keyword">if</span> hour &gt; <span class="number">8</span> <span class="keyword">else</span> -<span class="number">1</span> <span class="keyword">for</span> hour <span class="keyword">in</span> hours]</span><br><span class="line"></span><br><span class="line">        pre_sum = [<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            pre_sum.append(pre_sum[-<span class="number">1</span>] + num)</span><br><span class="line"></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> l <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(l, <span class="built_in">len</span>(nums)):</span><br><span class="line">                s = pre_sum[r + <span class="number">1</span>] - pre_sum[l]</span><br><span class="line">                <span class="keyword">if</span> s &gt; <span class="number">0</span>:</span><br><span class="line">                    res = <span class="built_in">max</span>(res, r - l + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p>可以使用hashmap记录ps-&gt;idx的映射，然后遍历<code>ps2idxs</code>:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">longestWPI</span>(<span class="params">self, hours: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        nums = [<span class="number">1</span> <span class="keyword">if</span> hour &gt; <span class="number">8</span> <span class="keyword">else</span> -<span class="number">1</span> <span class="keyword">for</span> hour <span class="keyword">in</span> hours]</span><br><span class="line"></span><br><span class="line">        pre_sum = [<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            pre_sum.append(pre_sum[-<span class="number">1</span>] + num)</span><br><span class="line"></span><br><span class="line">        ps2idxs = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> idx, ps <span class="keyword">in</span> <span class="built_in">enumerate</span>(pre_sum):</span><br><span class="line">            <span class="keyword">if</span> ps <span class="keyword">in</span> ps2idxs:</span><br><span class="line">                ps2idxs[ps].append(idx)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ps2idxs[ps] = [idx]</span><br><span class="line"></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> ps, idxs <span class="keyword">in</span> ps2idxs.items():</span><br><span class="line">            <span class="keyword">if</span> ps &gt; <span class="number">0</span>:</span><br><span class="line">                <span class="comment"># 说明 idxs中的每一个 i s.t. hours[0..i-1]是「表现良好的时间段」</span></span><br><span class="line">                <span class="comment"># 直接选取最大的一个idxs[-1]</span></span><br><span class="line">                res = <span class="built_in">max</span>(idxs[-<span class="number">1</span>], res)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 说明idxs的每一个 i s.t sum(nums[0,1,...,i-1]) &lt;=0</span></span><br><span class="line">                <span class="comment"># i.e. preSum[i] &lt;=0，需要寻找一个 j 使得 preSum[i] - preSum[j] &gt; 0</span></span><br><span class="line">                <span class="comment"># 考虑到我们的 preSum 数组每两个相邻元素的差的绝对值都是 1 且 j 应该尽可能小，</span></span><br><span class="line">                <span class="comment"># 那么只要找到 preSum[j] == preSum[i] - 1，nums[j+1..i] 就是一个「表现良好的时间段」</span></span><br><span class="line">                <span class="comment"># 故：jdxs = ps2idxs[ps-1]</span></span><br><span class="line">                <span class="keyword">if</span> ps - <span class="number">1</span> <span class="keyword">in</span> ps2idxs:</span><br><span class="line">                    jdxs = ps2idxs[ps - <span class="number">1</span>]</span><br><span class="line">                    i, j = idxs[-<span class="number">1</span>], jdxs[<span class="number">0</span>]</span><br><span class="line">                    res = <span class="built_in">max</span>(res, i - j)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<hr>
<p>搞了这么久的prefix sum了，下面写一下其API,其本质就是将<strong>查询闭区间[i,j]内的元素求和的复杂度从$O(n)$降低到$O(1)$</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PrefixSum</span>:</span><br><span class="line">    <span class="comment"># 前缀和数组</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>):</span><br><span class="line">        <span class="variable language_">self</span>.prefix = [<span class="number">0</span>] * (<span class="built_in">len</span>(nums) + <span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 计算 nums 的累加和</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(<span class="variable language_">self</span>.prefix)):</span><br><span class="line">            <span class="variable language_">self</span>.prefix[i] = <span class="variable language_">self</span>.prefix[i - <span class="number">1</span>] + nums[i - <span class="number">1</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 引入hashmap技巧</span></span><br><span class="line">        <span class="variable language_">self</span>.ps2idxs = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(<span class="variable language_">self</span>.prefix)):</span><br><span class="line">            <span class="keyword">if</span> <span class="variable language_">self</span>.prefix[i] <span class="keyword">not</span> <span class="keyword">in</span> <span class="variable language_">self</span>.ps2idxs:</span><br><span class="line">                <span class="variable language_">self</span>.ps2idxs[<span class="variable language_">self</span>.prefix[i]] = []</span><br><span class="line">            <span class="variable language_">self</span>.ps2idxs[<span class="variable language_">self</span>.prefix[i]].append(i)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 查询闭区间 [i, j] 的累加和</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">query</span>(<span class="params">self, i: <span class="built_in">int</span>, j: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.prefix[j + <span class="number">1</span>] - <span class="variable language_">self</span>.prefix[i]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 查询前缀和等于 target 的所有[0, j]的 j</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">find</span>(<span class="params">self, target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">if</span> target <span class="keyword">not</span> <span class="keyword">in</span> <span class="variable language_">self</span>.ps2idxs:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.ps2idxs[target]</span><br></pre></td></tr></table></figure>

<h3 id="小而美的算法技巧：差分数组"><a href="#小而美的算法技巧：差分数组" class="headerlink" title="小而美的算法技巧：差分数组"></a><a href="https://labuladong.online/algo/data-structure/diff-array/">小而美的算法技巧：差分数组</a></h3><h4 id="算法原理与具体实现"><a href="#算法原理与具体实现" class="headerlink" title="算法原理与具体实现"></a>算法原理与具体实现</h4><blockquote>
<p>差分数组的主要适用场景是频繁对原始数组的某个区间的元素进行增减</p>
</blockquote>
<p>对于一个长度为n的数组<br>$$<br>nums &#x3D; [nums[0], …, nums[i], …,nums[j],… nums[n-1]]<br>$$<br>定义其长度为n的差分数组<br>$$<br>diff &#x3D; [nums[0], …, nums[i] - nums[i-1],…, nums[j] - nums[j-1] …, nums[n-1] - nums[n-2]]<br>$$</p>
<p>现在对<code>nums</code>的闭区间[i,j]上加上一个可以为负的值<code>val</code>,则此时:<br>$$<br>nums_{addVal} &#x3D; [nums[0], …, nums[i]+val, …,nums[j]+val,… nums[n-1]]<br>$$<br>我们发现其<strong>对应的差分数组$diff_{addVal}$居然只有两处改变</strong>，即：<br>$$<br>\begin{align*}<br>    diff_{addVal} &amp;&#x3D; \<br>    &amp;&#x3D; [nums[0], …, nums[i]+val - nums[i-1],…, nums[j] - nums[j-1], nums[j+1] - nums[j]-val, …, nums[n-1] - nums[n-2]]\<br>    &amp;&#x3D; [diff[0], …, diff[i] + val,diff[i+1],…,diff[j],diff[j+1]-val,…,diff[n-1]]\<br>\end{align*}<br>$$<br>而差分数组又很容易还原出原始数组，基于此我们可以设计查封数组的API，可以以O(1)的时间复杂度对原始数组进行闭区间值的增减操作：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 差分数组工具类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Difference</span>:</span><br><span class="line">    <span class="comment"># 差分数组</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>):</span><br><span class="line">        <span class="keyword">assert</span> <span class="built_in">len</span>(nums) &gt; <span class="number">0</span></span><br><span class="line">        <span class="variable language_">self</span>.diff = [<span class="number">0</span>] * <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="comment"># 根据初始数组构造差分数组</span></span><br><span class="line">        <span class="variable language_">self</span>.diff[<span class="number">0</span>] = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="variable language_">self</span>.diff[i] = nums[i] - nums[i - <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 给闭区间 [i, j] 增加 val（可以是负数）</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">increment</span>(<span class="params">self, i: <span class="built_in">int</span>, j: <span class="built_in">int</span>, val: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="variable language_">self</span>.diff[i] += val</span><br><span class="line">        <span class="keyword">if</span> j + <span class="number">1</span> &lt; <span class="built_in">len</span>(<span class="variable language_">self</span>.diff):</span><br><span class="line">            <span class="variable language_">self</span>.diff[j + <span class="number">1</span>] -= val</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 返回结果数组</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">result</span>(<span class="params">self</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        res = [<span class="number">0</span>] * <span class="built_in">len</span>(<span class="variable language_">self</span>.diff)</span><br><span class="line">        <span class="comment"># 根据差分数组构造结果数组</span></span><br><span class="line">        res[<span class="number">0</span>] = <span class="variable language_">self</span>.diff[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(<span class="variable language_">self</span>.diff)):</span><br><span class="line">            res[i] = res[i - <span class="number">1</span>] + <span class="variable language_">self</span>.diff[i]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><ul>
<li><a href="https://leetcode.cn/problems/corporate-flight-bookings/description/">Leetcode 1109</a>  航班预订统计<br>非常典型的差分数组的应用，直接调用API即可</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Difference</span>:</span><br><span class="line">    <span class="comment"># 差分数组</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">corpFlightBookings</span>(<span class="params">self, bookings: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], n: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        nums = [<span class="number">0</span>] * n</span><br><span class="line">        difference = Difference(nums)</span><br><span class="line">        <span class="keyword">for</span> booking <span class="keyword">in</span> bookings:</span><br><span class="line">            i = booking[<span class="number">0</span>] - <span class="number">1</span></span><br><span class="line">            j = booking[<span class="number">1</span>] - <span class="number">1</span></span><br><span class="line">            val = booking[<span class="number">2</span>]</span><br><span class="line">            difference.increment(i, j, val)</span><br><span class="line">        <span class="keyword">return</span> difference.result()</span><br></pre></td></tr></table></figure>

<ul>
<li><a href="https://leetcode.cn/problems/car-pooling/description/">Leetcode 109*</a> 拼车<br>为了避免一个站又上车又下车的问题，直接将<code>j= trip[2] - 1</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Difference</span>:</span><br><span class="line">    <span class="comment"># 差分数组</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">carPooling</span>(<span class="params">self, trips: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], capacity: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        farest = <span class="built_in">max</span>([_[-<span class="number">1</span>] <span class="keyword">for</span> _ <span class="keyword">in</span> trips])</span><br><span class="line">        nums = [<span class="number">0</span>] * farest</span><br><span class="line">        difference = Difference(nums)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> trip <span class="keyword">in</span> trips:</span><br><span class="line">            val = trip[<span class="number">0</span>]</span><br><span class="line">            i = trip[<span class="number">1</span>] </span><br><span class="line">            j = trip[<span class="number">2</span>] - <span class="number">1</span> <span class="comment"># 让乘客“提前”一站下车</span></span><br><span class="line">            difference.increment(i,j,val)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(difference.result()) &lt;= capacity</span><br></pre></td></tr></table></figure>
<h3 id="滑动窗口算法核心代码模板"><a href="#滑动窗口算法核心代码模板" class="headerlink" title="滑动窗口算法核心代码模板"></a><a href="https://labuladong.online/algo/essential-technique/sliding-window-framework/">滑动窗口算法核心代码模板</a></h3><p>这一部分详见[第零章-核心刷题框架汇总],下面提供滑动窗口的模板以做回顾：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 滑动窗口算法伪码框架</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">slidingWindow</span>(<span class="params">s: <span class="built_in">str</span></span>):</span><br><span class="line">    <span class="comment"># 用合适的数据结构记录窗口中的数据，根据具体场景变通</span></span><br><span class="line">    <span class="comment"># 比如说，我想记录窗口中元素出现的次数，就用 map</span></span><br><span class="line">    <span class="comment"># 如果我想记录窗口中的元素和，就可以只用一个 int</span></span><br><span class="line">    window = ...</span><br><span class="line"></span><br><span class="line">    left, right = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> right &lt; <span class="built_in">len</span>(s):</span><br><span class="line">        <span class="comment"># c 是将移入窗口的字符</span></span><br><span class="line">        c = s[right]</span><br><span class="line">        window.add(c)</span><br><span class="line">        <span class="comment"># 增大窗口</span></span><br><span class="line">        right += <span class="number">1</span></span><br><span class="line">        <span class="comment"># 进行窗口内数据的一系列更新</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Your code here 1</span></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="comment"># *** debug 输出的位置 ***</span></span><br><span class="line">        <span class="comment"># 注意在最终的解法代码中不要 print</span></span><br><span class="line">        <span class="comment"># 因为 IO 操作很耗时，可能导致超时</span></span><br><span class="line">        <span class="comment"># print(f&quot;window: [&#123;left&#125;, &#123;right&#125;)&quot;)</span></span><br><span class="line">        <span class="comment"># ***********************</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 判断左侧窗口是否要收缩</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> window needs shrink:</span><br><span class="line">            <span class="comment"># d 是将移出窗口的字符</span></span><br><span class="line">            d = s[left]</span><br><span class="line">            window.remove(d)</span><br><span class="line">            <span class="comment"># 缩小窗口</span></span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 进行窗口内数据的一系列更新</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment"># Your code here 2</span></span><br><span class="line">            ...</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Your code here 3</span></span><br><span class="line">        ...</span><br></pre></td></tr></table></figure>
<p>到子数组&#x2F;子串相关的问题，你只要能回答出来以下几个问题，就能运用滑动窗口算法：</p>
<ul>
<li>1、什么时候应该扩大窗口？</li>
<li>2、什么时候应该缩小窗口？</li>
<li>3、什么时候应该更新答案？</li>
</ul>
<h3 id="【强化练习】滑动窗口算法经典习题"><a href="#【强化练习】滑动窗口算法经典习题" class="headerlink" title="【强化练习】滑动窗口算法经典习题"></a><a href="https://labuladong.online/algo/problem-set/sliding-window/">【强化练习】滑动窗口算法经典习题</a></h3><ul>
<li><a href="https://leetcode.cn/problems/minimum-operations-to-reduce-x-to-zero/description/">Leetcode 1658</a>  最小操作次数使数组的和为零<br>首先比较容易回溯得到答案，但是原问题的规模达到$10^5$，会超时，下面是基于回溯的解法：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.res = -<span class="number">1</span></span><br><span class="line">        <span class="variable language_">self</span>.track = []</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">self,nums,x</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">sum</span>(<span class="variable language_">self</span>.track) &gt; x:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">elif</span> <span class="built_in">sum</span>(<span class="variable language_">self</span>.track) == x:</span><br><span class="line">            <span class="variable language_">self</span>.res = <span class="built_in">len</span>(<span class="variable language_">self</span>.track) <span class="keyword">if</span> <span class="variable language_">self</span>.res == -<span class="number">1</span> <span class="keyword">else</span> <span class="built_in">min</span>(<span class="built_in">len</span>(<span class="variable language_">self</span>.track),<span class="variable language_">self</span>.res)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> nums:</span><br><span class="line">                <span class="variable language_">self</span>.track.append(nums[-<span class="number">1</span>])</span><br><span class="line">                <span class="variable language_">self</span>.backtrack(nums[:-<span class="number">1</span>],x)</span><br><span class="line">                <span class="variable language_">self</span>.track.pop()</span><br><span class="line"></span><br><span class="line">                <span class="variable language_">self</span>.track.append(nums[<span class="number">0</span>])</span><br><span class="line">                <span class="variable language_">self</span>.backtrack(nums[<span class="number">1</span>:],x)</span><br><span class="line">                <span class="variable language_">self</span>.track.pop()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minOperations</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], x: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="variable language_">self</span>.backtrack(nums,x)</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.res</span><br></pre></td></tr></table></figure>
<p>从头删除了l个元素，从尾部删除了r个元素，此时形成了一个可行解，i.e. $\sum_{i&#x3D;0}^l nums[i] + \sum_{i&#x3D;n-r}^{n-1} nums[i] &#x3D; x$，则此时剩下的数组为：<br>$$<br>\sum_{i&#x3D;l+1}^{n-r-1} nums[i] &#x3D; \sum nums[i] - x<br>$$<br>然而这样的可行解存在多个，按照题目要求，需要最小的删除，i.e. 剩下来的尽可能多，显然可以解答滑动窗口3问：</p>
<ul>
<li>1、什么时候应该扩大窗口？ $\sum_{i&#x3D;l+1}^{n-r-1} nums[i] &lt; \sum nums[i] - x$</li>
<li>2、什么时候应该缩小窗口？ $\sum_{i&#x3D;l+1}^{n-r-1} nums[i] &gt; \sum nums[i] - x$</li>
<li>3、什么时候应该更新答案？ $\sum_{i&#x3D;l+1}^{n-r-1} nums[i] &#x3D; \sum nums[i] - x$</li>
</ul>
<p>如下是滑动窗口的解法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minOperations</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], x: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># from collections import deque</span></span><br><span class="line">        <span class="comment"># window = deque([])</span></span><br><span class="line">        window_sum = <span class="number">0</span></span><br><span class="line">        window_len = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        target = <span class="built_in">sum</span>(nums) - x</span><br><span class="line">        left, right = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        res = -<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> right &lt; <span class="built_in">len</span>(nums):</span><br><span class="line">            c = nums[right]</span><br><span class="line">            right += <span class="number">1</span></span><br><span class="line">            <span class="comment"># window.append(c)</span></span><br><span class="line">            window_sum += c</span><br><span class="line">            window_len += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># while left &lt; right and sum(window) &gt; target:</span></span><br><span class="line">            <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> window_sum &gt; target:</span><br><span class="line">                d = nums[left]</span><br><span class="line">                <span class="comment"># window.popleft()</span></span><br><span class="line">                window_sum -= d</span><br><span class="line">                window_len -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># if sum(window) == target:</span></span><br><span class="line">            <span class="comment">#     res = max(len(window), res)</span></span><br><span class="line">            <span class="keyword">if</span> window_sum == target:</span><br><span class="line">                res = <span class="built_in">max</span>(window_len, res)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span> <span class="keyword">if</span> res == -<span class="number">1</span> <span class="keyword">else</span> <span class="built_in">len</span>(nums) - res</span><br></pre></td></tr></table></figure>
<p>从这个题目可以看出，滑动窗口不一定非得要有窗口，<strong>在这里我们只关心其长度和和，所以只用维护这两个变量就可以</strong>。使用deque没有办法通过所有的测例。</p>
<ul>
<li><a href="https://leetcode.cn/problems/subarray-product-less-than-k/description/">Leetcode 713*</a>  乘积小于 K 的子数组<br>很典型的滑动窗口问题，难点在于如何更新答案</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">numSubarrayProductLessThanK</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        window_prod = <span class="number">1</span></span><br><span class="line">        left,right =<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> right &lt; <span class="built_in">len</span>(nums):</span><br><span class="line">            c = nums[right]</span><br><span class="line">            right += <span class="number">1</span></span><br><span class="line">            window_prod *= c</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> window_prod &gt;= k:</span><br><span class="line">                d = nums[left]</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">                window_prod /= d</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 现在必然是一个合法的窗口，但注意思考这个窗口中的子数组个数怎么计算：</span></span><br><span class="line">            <span class="comment"># 比方说 left = 1, right = 4 划定了 [1, 2, 3] 这个窗口（right 是开区间）</span></span><br><span class="line">            <span class="comment"># 但不止 [left..right] 是合法的子数组，[left+1..right], [left+2..right] 等都是合法子数组</span></span><br><span class="line">            <span class="comment"># 所以我们需要把 [3], [2,3], [1,2,3] 这 right - left 个子数组都加上</span></span><br><span class="line">            res += (right - left)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>


<ul>
<li><a href="https://leetcode.cn/problems/max-consecutive-ones-iii/description/">Leetcode 1004</a>  最大连续 1 的个数 III</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">longestOnes</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        window = &#123;<span class="number">0</span>: <span class="number">0</span>, <span class="number">1</span>: <span class="number">0</span>&#125;</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        left, right = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> right &lt; <span class="built_in">len</span>(nums):</span><br><span class="line">            c = nums[right]</span><br><span class="line">            right += <span class="number">1</span></span><br><span class="line">            window[c] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> window[<span class="number">0</span>] &gt; k:</span><br><span class="line">                d = nums[left]</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">                window[d] -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">assert</span> window[<span class="number">0</span>] &lt;= k</span><br><span class="line">            res = <span class="built_in">max</span>(res, window[<span class="number">0</span>] + window[<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>


<ul>
<li><a href="https://leetcode.cn/problems/longest-repeating-character-replacement/description/">Leetcode 424</a>  替换后的最长重复字符</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">characterReplacement</span>(<span class="params">self, s: <span class="built_in">str</span>, k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">is_window_need_shink</span>(<span class="params">window,k</span>):</span><br><span class="line">            <span class="comment"># 判断窗口是否需要缩小</span></span><br><span class="line">            <span class="comment"># sum(window) - max(window): 表示当前窗口中为了元素一样，需要替换的元素个数</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">sum</span>(window) - <span class="built_in">max</span>(window) &gt; k</span><br><span class="line">    </span><br><span class="line">        window = [<span class="number">0</span>] * <span class="number">26</span> <span class="comment"># 相当于一个dict，本质上是一个计数器</span></span><br><span class="line">        left,right =<span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> right &lt; <span class="built_in">len</span>(s):</span><br><span class="line">            c = s[right]</span><br><span class="line">            right += <span class="number">1</span></span><br><span class="line">            window[<span class="built_in">ord</span>(c) - <span class="built_in">ord</span>(<span class="string">&#x27;A&#x27;</span>)] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> is_window_need_shink(window,k):</span><br><span class="line">                d = s[left]</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">                window[<span class="built_in">ord</span>(d)-<span class="built_in">ord</span>(<span class="string">&#x27;A&#x27;</span>)] -= <span class="number">1</span></span><br><span class="line">            res = <span class="built_in">max</span>(res,<span class="built_in">sum</span>(window))</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p>滑动窗口3大问：</p>
<ul>
<li><p>1、什么时候应该扩大窗口？需要替换的元素个数小于k</p>
</li>
<li><p>2、什么时候应该缩小窗口？需要替换的元素个数大于k</p>
</li>
<li><p>3、什么时候应该更新答案？缩小完的窗口长度or根本就不用缩小，更新答案</p>
</li>
<li><p><a href="https://leetcode.cn/problems/contains-duplicate-ii/description/">Leetcode 219</a>  存在重复元素ii<br>感觉这个题目用滑动窗口反而不是很直观，直接考虑用哈希表来解决，代码如下：</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">containsNearbyDuplicate</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line">        num2idxs = defaultdict(<span class="built_in">list</span>)</span><br><span class="line">        <span class="keyword">for</span> idx,num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            num2idxs[num].append(idx)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> _,idxs <span class="keyword">in</span> num2idxs.items():</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(idxs) &gt;= <span class="number">2</span>:</span><br><span class="line">                <span class="comment"># idxs本身是有序的，所以可以这样求出差值</span></span><br><span class="line">                diff = [idxs[i] - idxs[i-<span class="number">1</span>] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(idxs))] </span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">min</span>(diff) &lt;= k:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<p>当然也可以用滑动窗口，只不过这个滑动窗口是固定长度的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">containsNearbyDuplicate</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        windows = <span class="built_in">set</span>()</span><br><span class="line">        left,right = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> right &lt; <span class="built_in">len</span>(nums):</span><br><span class="line">            c = nums[right]</span><br><span class="line">            right += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">in</span> windows:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            windows.add(c)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> <span class="built_in">len</span>(windows) &gt; k:</span><br><span class="line">                d = nums[left]</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">                windows.remove(d)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<p>滑动窗口3问：</p>
<ul>
<li><p>1、什么时候应该扩大窗口？ 窗口元素小于k，应该扩大窗口</p>
</li>
<li><p>2、什么时候应该缩小窗口？ 窗口元素大于k，应该缩小窗口</p>
</li>
<li><p>3、什么时候应该更新答案？ 扩大窗口时发现存在重复元素</p>
</li>
<li><p><a href="https://leetcode.cn/problems/contains-duplicate-iii/description/">Leetcode 220*</a>  存在重复元素iii<br>尝试采用暴力枚举的方法，时间复杂度O(n^2)，显然问题规模达到5次方量级，不能采用。</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">containsNearbyAlmostDuplicate</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], indexDiff: <span class="built_in">int</span>, valueDiff: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i + <span class="number">1</span>, <span class="built_in">min</span>(<span class="built_in">len</span>(nums), i + indexDiff + <span class="number">1</span>)):</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">abs</span>(nums[i] - nums[j]) &lt;= valueDiff:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<p>尝试自己写一个滑动窗口，但是对于问题3，i.e. 什么时候应该更新答案？此处需要判断windows的差分数组的最小值是不是小于valueDiff，显然这个复杂度为O(n)，再加上外层的遍历窗口的复杂度为O(n)，所以时间复杂度为O(n^2)，依然不行。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">containsNearbyAlmostDuplicate</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], indexDiff: <span class="built_in">int</span>, valueDiff: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line">        window = deque([])</span><br><span class="line">        left, right = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> right &lt; <span class="built_in">len</span>(nums):</span><br><span class="line">            c = nums[right]</span><br><span class="line">            right += <span class="number">1</span></span><br><span class="line">            window.append(c)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> right - left - <span class="number">1</span> &gt; indexDiff:</span><br><span class="line">                d = nums[left]</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">                window.popleft()</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 此时已经确保了，window中任意两个元素的index差 &lt;= indexDiff</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(window) &gt;= <span class="number">2</span>:</span><br><span class="line">                tmp = <span class="built_in">sorted</span>(<span class="built_in">list</span>(window))</span><br><span class="line">                diff = [tmp[i] - tmp[i - <span class="number">1</span>] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(tmp))]</span><br><span class="line">                <span class="comment"># windows内最小的value差是不是小于valueDiff</span></span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">min</span>(diff) &lt;= valueDiff:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<p><strong>这里的window需要采用一种特殊的数据结构<code>SortedList</code></strong> <code>SortedList</code>可以自动保持升序，其提供</p>
<ul>
<li><code>add(val)</code> 以O(logn)的时间复杂度插入一个元素</li>
<li><code>remove(val)</code> 以O(logn)的时间复杂度删除一个元素</li>
<li><code>bisect_left(value)</code> 以O(logn)的时间复杂度返回插入点的索引<br>例如:</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sortedcontainers <span class="keyword">import</span> SortedList</span><br><span class="line">sl = SortedList([<span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(sl)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">sl.bisect_left(<span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>尤其是<code>bisect_left(value)</code>，我们就不用每次算差分数组的最小值了，如下是更新窗口的代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">containsNearbyAlmostDuplicate</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], indexDiff: <span class="built_in">int</span>, valueDiff: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">from</span> sortedcontainers <span class="keyword">import</span> SortedList</span><br><span class="line">        window = SortedList()</span><br><span class="line">        left, right = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> right &lt; <span class="built_in">len</span>(nums):</span><br><span class="line">            c = nums[right]</span><br><span class="line">            right += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 查找略大于 nums[i] 的那个元素window[pos]</span></span><br><span class="line">            pos = window.bisect_left(c)</span><br><span class="line">            <span class="keyword">if</span> pos &lt; <span class="built_in">len</span>(window) <span class="keyword">and</span> window[pos] - c &lt;= valueDiff:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="comment"># 查找略小于 nums[i] 的那个元素window[pos - 1]</span></span><br><span class="line">            <span class="keyword">if</span> pos &gt; <span class="number">0</span> <span class="keyword">and</span> c - window[pos - <span class="number">1</span>] &lt;= valueDiff:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 安全，我们添加c</span></span><br><span class="line">            window.add(c)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> right - left &gt; indexDiff:</span><br><span class="line">                d = nums[left]</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">                window.remove(d)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>



<ul>
<li><a href="https://leetcode.cn/problems/minimum-size-subarray-sum/description/">Leetcode 209</a>  长度最小的子数组<br>这个题目比较有意思的地方<code>your code  here 1</code>和<code>your code  here 2</code>两处的代码时一样的，其实这个重复的可以只保留一份到<code>tag</code>处，但是为了模板风格的统一就保留了两份</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minSubArrayLen</span>(<span class="params">self, target: <span class="built_in">int</span>, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        window_sum, window_len = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        left, right = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> right &lt; <span class="built_in">len</span>(nums):</span><br><span class="line">            c = nums[right]</span><br><span class="line">            right += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            window_sum += c</span><br><span class="line">            window_len += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># your code  here 1</span></span><br><span class="line">            <span class="keyword">if</span> window_sum &gt;= target:</span><br><span class="line">                res = <span class="built_in">min</span>(res, window_len) <span class="keyword">if</span> res != <span class="number">0</span> <span class="keyword">else</span> window_len</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> window_sum &gt;= target:</span><br><span class="line">                <span class="comment"># tag</span></span><br><span class="line">                d = nums[left]</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">                window_sum -= d</span><br><span class="line">                window_len -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">                <span class="comment"># your code  here 2</span></span><br><span class="line">                <span class="keyword">if</span> window_sum &gt;= target:</span><br><span class="line">                    res = <span class="built_in">min</span>(res, window_len) <span class="keyword">if</span> res != <span class="number">0</span> <span class="keyword">else</span> window_len</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>


<ul>
<li><a href="https://leetcode.cn/problems/longest-substring-with-at-least-k-repeating-characters/description/">Leetcode 395*</a>  最长子串包含K个相同字符<br>最简单就是暴力枚举：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">longestSubstring</span>(<span class="params">self, s: <span class="built_in">str</span>, k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>,<span class="built_in">len</span>(s) + <span class="number">1</span>):</span><br><span class="line">                cnt  = Counter(s[i:j])</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">min</span>(cnt.values()) &gt;= k:</span><br><span class="line">                    res = <span class="built_in">max</span>(res,j-i)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p>采用滑动窗口是比较难的，因为无法解答：</p>
<ul>
<li><ol>
<li>什么时候扩大窗口？不知道</li>
</ol>
</li>
<li><ol start="2">
<li>什么时候缩小窗口？不知道</li>
</ol>
</li>
<li><ol start="3">
<li>什么时候更新答案？这个比较好知道，<code>Counter(window).most_common(-1) &gt;= k</code>也就是说window内最少出现的字符都大于等于k的时候，必然是合法的，所以可以更新答案。</li>
</ol>
</li>
</ul>
<p>那么如何解决该么问题呢？由于不知道应该什么时候扩大窗口，什么时候缩小窗口，我们对题目增加一个限制，现在的限制为：求每个字符都出现至少 k 次，<strong>仅包含 count 种不同字符的最长子串</strong>。我们遍历26种情况，取最大值。i.e. 现在的题目变成了：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">longestSubstringWithAdditionalConstrain</span>(<span class="params">self, s: <span class="built_in">str</span>, k: <span class="built_in">int</span>, count: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        给你一个字符串 s 、一个整数k、一个整数count。 </span></span><br><span class="line"><span class="string">        请你找出 s 中的最长子串， 要求该子串中的每一字符出现次数都不少于 k 且 该该字串种只包含count中字母。</span></span><br><span class="line"><span class="string">        返回这一子串的长度。</span></span><br><span class="line"><span class="string">        例如：</span></span><br><span class="line"><span class="string">        s = &quot;aaabb&quot;, k = 3，count = 1 return 3</span></span><br><span class="line"><span class="string">        s = &quot;aaabb&quot;, k = 3，count = 2 return 0</span></span><br><span class="line"><span class="string">        param: s - 字符串</span></span><br><span class="line"><span class="string">        param: k - 每个字符都出现至少 k 次</span></span><br><span class="line"><span class="string">        param: count - 仅包含 count 种不同字符的最长子串</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<p>假设我们已经实现了上述函数<code>longestSubstringWithAdditionalConstrain</code>,那么原问题的答案就很好得出：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">longestSubstring</span>(<span class="params">self, s: <span class="built_in">str</span>, k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(<span class="variable language_">self</span>.longestSubstringWithAdditionalConstrain(s, k, count) <span class="keyword">for</span> count <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">27</span>))</span><br></pre></td></tr></table></figure>
<p>现在应该如何实现<code>longestSubstringWithAdditionalConstrain</code>呢？滑动窗口3大问：</p>
<ul>
<li>什么时候扩大窗口？ 默认扩大</li>
<li>什么时候缩小窗口？ window中存在的字母种数&gt;count</li>
<li>什么时候更新答案？ 当窗口中字符种类为 count 且每个字符出现次数都满足 k 时，更新答案</li>
</ul>
<p>则该题的最终答案是：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyWindow</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        初始化MyWindow类的实例。</span></span><br><span class="line"><span class="string">        该类主要用于管理一个包含26个元素的窗口，用于统计字母出现次数。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="variable language_">self</span>.window = [<span class="number">0</span>] * <span class="number">26</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        计算当前窗口中所有字母出现的总次数。</span></span><br><span class="line"><span class="string">        Returns:</span></span><br><span class="line"><span class="string">            int: 字母出现的总次数。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(<span class="variable language_">self</span>.window)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__type_counter</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        统计当前窗口中有多少种不同的字母。</span></span><br><span class="line"><span class="string">        Returns:</span></span><br><span class="line"><span class="string">            int: 不同字母的种类数。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        cnt = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="variable language_">self</span>.window:</span><br><span class="line">            <span class="keyword">if</span> _ != <span class="number">0</span>:</span><br><span class="line">                cnt += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> cnt</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_need_shrink</span>(<span class="params">self, count</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        判断当前窗口中的字母种类是否超过了指定的数量。</span></span><br><span class="line"><span class="string">        Args:</span></span><br><span class="line"><span class="string">            count (int): 指定的字母种类数量。</span></span><br><span class="line"><span class="string">        Returns:</span></span><br><span class="line"><span class="string">            bool: 如果当前窗口中的字母种类超过指定数量，则返回True，否则返回False。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.__type_counter() &gt; count</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_valid</span>(<span class="params">self, count, k</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        检查当前窗口中的字母是否满足特定条件。</span></span><br><span class="line"><span class="string">        条件是：窗口中的字母种类等于指定的数量，并且每种字母的出现次数都不少于k次。</span></span><br><span class="line"><span class="string">        Args:</span></span><br><span class="line"><span class="string">            count (int): 指定的字母种类数量。</span></span><br><span class="line"><span class="string">            k (int): 每种字母至少出现的次数。</span></span><br><span class="line"><span class="string">        Returns:</span></span><br><span class="line"><span class="string">            bool: 如果满足条件，则返回True，否则返回False。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.__type_counter() == count:</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="variable language_">self</span>.window:</span><br><span class="line">                <span class="keyword">if</span> _ != <span class="number">0</span> <span class="keyword">and</span> _ &lt; k:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self, val</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        向窗口中添加一个字母。</span></span><br><span class="line"><span class="string">        Args:</span></span><br><span class="line"><span class="string">            val (char): 要添加的字母。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="variable language_">self</span>.window[<span class="built_in">ord</span>(val) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">remove</span>(<span class="params">self, val</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        从窗口中移除一个字母。</span></span><br><span class="line"><span class="string">        Args:</span></span><br><span class="line"><span class="string">            val (char): 要移除的字母。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="variable language_">self</span>.window[<span class="built_in">ord</span>(val) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)] -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">longestSubstring</span>(<span class="params">self, s: <span class="built_in">str</span>, k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(<span class="variable language_">self</span>.longestSubstringWithAdditionalConstrain(s, k, count) <span class="keyword">for</span> count <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">27</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">longestSubstringWithAdditionalConstrain</span>(<span class="params">self, s: <span class="built_in">str</span>, k: <span class="built_in">int</span>, count: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        给你一个字符串 s 、一个整数k、一个整数count。</span></span><br><span class="line"><span class="string">        请你找出 s 中的最长子串， 要求该子串中的每一字符出现次数都不少于 k 且 该该字串种只包含count中字母。</span></span><br><span class="line"><span class="string">        返回这一子串的长度。</span></span><br><span class="line"><span class="string">        例如：</span></span><br><span class="line"><span class="string">        s = &quot;aaabb&quot;, k = 3，count = 1 return 3</span></span><br><span class="line"><span class="string">        s = &quot;aaabb&quot;, k = 3，count = 2 return 0</span></span><br><span class="line"><span class="string">        param: s - 字符串</span></span><br><span class="line"><span class="string">        param: k - 每个字符都出现至少 k 次</span></span><br><span class="line"><span class="string">        param: count - 仅包含 count 种不同字符的最长子串</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        window = MyWindow()</span><br><span class="line">        left, right = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> right &lt; <span class="built_in">len</span>(s):</span><br><span class="line">            c = s[right]</span><br><span class="line">            right += <span class="number">1</span></span><br><span class="line">            window.add(c)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> window.is_need_shrink(count):</span><br><span class="line">                d = s[left]</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">                window.remove(d)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> window.is_valid(count, k):</span><br><span class="line">                res = <span class="built_in">max</span>(res, <span class="built_in">len</span>(window))</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h3 id="滑动窗口延伸：Rabin-Karp-字符匹配算法"><a href="#滑动窗口延伸：Rabin-Karp-字符匹配算法" class="headerlink" title="滑动窗口延伸：Rabin Karp 字符匹配算法"></a><a href="https://labuladong.online/algo/practice-in-action/rabinkarp/">滑动窗口延伸：Rabin Karp 字符匹配算法</a></h3><ul>
<li><a href="https://leetcode.cn/problems/repeated-dna-sequences/description/">LeetCode 187</a> 重复的DNA序列</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyWindow</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line">        <span class="variable language_">self</span>.window = deque([])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(<span class="variable language_">self</span>.window)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__hash__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">hash</span>(<span class="built_in">str</span>(<span class="variable language_">self</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__eq__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(other, MyWindow):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">str</span>(<span class="variable language_">self</span>) == <span class="built_in">str</span>(other)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join(<span class="variable language_">self</span>.window)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__copy__</span>(<span class="params">self</span>):</span><br><span class="line">        new_window = MyWindow()</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="variable language_">self</span>.window:</span><br><span class="line">            new_window.add(_)</span><br><span class="line">        <span class="keyword">return</span> new_window</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_need_shrink</span>(<span class="params">self, L=<span class="number">10</span></span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(<span class="variable language_">self</span>.window) &gt; L</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self, val</span>):</span><br><span class="line">        <span class="variable language_">self</span>.window.append(val)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">remove</span>(<span class="params">self, val</span>):</span><br><span class="line">        <span class="keyword">assert</span> val == <span class="variable language_">self</span>.window[<span class="number">0</span>]</span><br><span class="line">        <span class="variable language_">self</span>.window.popleft()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findRepeatedDnaSequences</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span><br><span class="line">        <span class="keyword">from</span> copy <span class="keyword">import</span> copy</span><br><span class="line"></span><br><span class="line">        window = MyWindow()</span><br><span class="line">        res = <span class="built_in">set</span>()</span><br><span class="line">        visited = <span class="built_in">set</span>()</span><br><span class="line"></span><br><span class="line">        left, right = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> right &lt; <span class="built_in">len</span>(s):</span><br><span class="line">            <span class="comment"># 字符串的长度为N，此循环复杂度为O(N)</span></span><br><span class="line">            c = s[right]</span><br><span class="line">            right += <span class="number">1</span></span><br><span class="line">            window.add(c)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> window.is_need_shrink():</span><br><span class="line">                d = s[left]</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">                window.remove(d)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(window) == <span class="number">10</span>:</span><br><span class="line">                <span class="keyword">if</span> window <span class="keyword">in</span> visited:</span><br><span class="line">                    <span class="comment"># hash和copy需要遍历L=10的字串，复杂度为O(L)</span></span><br><span class="line">                    res.add(copy(window))</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    visited.add(copy(window))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> [<span class="built_in">str</span>(_) <span class="keyword">for</span> _ <span class="keyword">in</span> res]</span><br></pre></td></tr></table></figure>
<p>如上是这个题目暴力枚举的答案，我们首先分析一下其复杂度，假设s的长度为N，所要匹配的字符串的长度为L，在本题中L是10，那么时间复杂度为O(N*L)，由于L&#x3D;10，那么时间复杂度为O(N)，但是该算法仍然有优化空间。<br>下面介绍一个O(N)的算法，其核心就是将四种碱基对映射为一个数字：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;A&quot;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">&quot;C&quot;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">&quot;G&quot;</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="string">&quot;T&quot;</span>: <span class="number">4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于一段碱基序列，我们可以将其转化为一个数字，比如<code>ACGT</code>转化为<code>1234</code>,则我们设计该算法的<code>MyWindow</code>类如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> log10</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyWindow</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.AGTC2digit = &#123;</span><br><span class="line">            <span class="string">&quot;A&quot;</span>: <span class="number">1</span>,</span><br><span class="line">            <span class="string">&quot;C&quot;</span>: <span class="number">2</span>,</span><br><span class="line">            <span class="string">&quot;G&quot;</span>: <span class="number">3</span>,</span><br><span class="line">            <span class="string">&quot;T&quot;</span>: <span class="number">4</span>,</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable language_">self</span>.digit2AGTC = &#123;</span><br><span class="line">            <span class="number">1</span>: <span class="string">&quot;A&quot;</span>,</span><br><span class="line">            <span class="number">2</span>: <span class="string">&quot;C&quot;</span>,</span><br><span class="line">            <span class="number">3</span>: <span class="string">&quot;G&quot;</span>,</span><br><span class="line">            <span class="number">4</span>: <span class="string">&quot;T&quot;</span>,</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable language_">self</span>.window = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">int</span>(log10(<span class="variable language_">self</span>.window)) + <span class="number">1</span> <span class="keyword">if</span> <span class="variable language_">self</span>.window != <span class="number">0</span> <span class="keyword">else</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__hash__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># O(1)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">hash</span>(<span class="variable language_">self</span>.window)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__eq__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="comment"># O(1)</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(other, MyWindow):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.window == other.window</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join([<span class="variable language_">self</span>.digit2AGTC[<span class="built_in">int</span>(_)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">str</span>(<span class="variable language_">self</span>.window)])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__copy__</span>(<span class="params">self</span>):</span><br><span class="line">        new_window = MyWindow()</span><br><span class="line">        new_window.window = <span class="variable language_">self</span>.window</span><br><span class="line">        <span class="keyword">return</span> new_window</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_need_shrink</span>(<span class="params">self, L=<span class="number">10</span></span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.__len__() &gt; L</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self, val</span>):</span><br><span class="line">        <span class="variable language_">self</span>.window = <span class="variable language_">self</span>.window * <span class="number">10</span> + <span class="variable language_">self</span>.AGTC2digit[val]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">remove</span>(<span class="params">self, val</span>):</span><br><span class="line">        <span class="variable language_">self</span>.window -= <span class="variable language_">self</span>.AGTC2digit[val] * <span class="number">10</span> ** (<span class="variable language_">self</span>.__len__() - <span class="number">1</span>)</span><br></pre></td></tr></table></figure>


<h4 id="Rabin-Karp-字符匹配算法"><a href="#Rabin-Karp-字符匹配算法" class="headerlink" title="Rabin Karp 字符匹配算法"></a>Rabin Karp 字符匹配算法</h4><p>该算法可以封装为如下的函数:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">txt: <span class="built_in">str</span>, pat: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="comment"># 在文本串 txt 中搜索模式串 pat 的起始索引</span></span><br></pre></td></tr></table></figure>
<p>假设txt的长度为N，pat的长度为L，十分容易得到一个O(NL)的算法，如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">txt: <span class="built_in">str</span>, pat: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    N, L = <span class="built_in">len</span>(txt), <span class="built_in">len</span>(pat)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N - L + <span class="number">1</span>):</span><br><span class="line">        subStr = txt[i:i + L]</span><br><span class="line">        <span class="keyword">if</span> subStr == pat:</span><br><span class="line">            <span class="comment"># 在 txt 中找到模式串 pat，返回起始索引</span></span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line">    <span class="comment"># txt 中不存在模式串 pat</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>本质上就是一个滑动窗口，仿照上面<a href="https://leetcode.cn/problems/repeated-dna-sequences/description/">LeetCode 187</a> 重复的DNA序列可以采用用数字编码字符的形式，但是存在一下难点：</p>
<ul>
<li>如何将字符串转化为数字？ASCII码有256个，那么数字编码字符的ASCII码范围是0-255，如何编码</li>
<li>如何将编码的数字转化为字符串？</li>
<li>如何进行窗口的add，remove操作？</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> log, <span class="built_in">pow</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyWindow</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.window = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">int</span>(log(<span class="variable language_">self</span>.window, <span class="number">255</span>)) + <span class="number">1</span> <span class="keyword">if</span> <span class="variable language_">self</span>.window != <span class="number">0</span> <span class="keyword">else</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__hash__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># O(1)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">hash</span>(<span class="variable language_">self</span>.window)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__eq__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="comment"># O(1)</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(other, MyWindow):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.window == other.window</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        tmp_window = <span class="variable language_">self</span>.window</span><br><span class="line">        res = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">while</span> tmp_window != <span class="number">0</span>:</span><br><span class="line">            res = <span class="built_in">chr</span>(tmp_window % <span class="number">255</span>) + res</span><br><span class="line">            tmp_window //= <span class="number">255</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__copy__</span>(<span class="params">self</span>):</span><br><span class="line">        new_window = MyWindow()</span><br><span class="line">        new_window.window = <span class="variable language_">self</span>.window</span><br><span class="line">        <span class="keyword">return</span> new_window</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_need_shrink</span>(<span class="params">self, L=<span class="number">10</span></span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(<span class="variable language_">self</span>) &gt; L</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self, val</span>):</span><br><span class="line">        <span class="variable language_">self</span>.window = <span class="variable language_">self</span>.window * <span class="number">255</span> + <span class="built_in">ord</span>(val)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">remove</span>(<span class="params">self, val</span>):</span><br><span class="line">        <span class="variable language_">self</span>.window -= <span class="built_in">ord</span>(val) * <span class="built_in">int</span>(<span class="built_in">pow</span>(<span class="number">255</span>, <span class="built_in">len</span>(<span class="variable language_">self</span>) - <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">window = MyWindow()</span><br><span class="line">window.add(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">window.add(<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">window.add(<span class="string">&#x27;c&#x27;</span>)</span><br><span class="line">window.remove(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">new_window = window.__copy__()</span><br><span class="line"><span class="built_in">print</span>(new_window)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bc</span><br></pre></td></tr></table></figure>




<h3 id="二分搜索算法核心代码模板"><a href="#二分搜索算法核心代码模板" class="headerlink" title="二分搜索算法核心代码模板"></a><a href="https://labuladong.online/algo/essential-technique/binary-search-framework/">二分搜索算法核心代码模板</a></h3><h4 id="基本的二分搜索-vanilla-binary-search"><a href="#基本的二分搜索-vanilla-binary-search" class="headerlink" title="基本的二分搜索&#x2F;vanilla binary search"></a>基本的二分搜索&#x2F;vanilla binary search</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">vanilla_binary_search</span>(<span class="params">nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    寻找目标元素的索引，如果目标元素不存在，返回 -1</span></span><br><span class="line"><span class="string">    数组中存在多个目标元素，该函数可能返回最左、最右甚至中间的索引</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 注意</span></span><br><span class="line">        right = <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            mid = left + (right - left) // <span class="number">2</span> <span class="comment"># 等价于 (left + right) // 2，之所以 这样写是为了避免整数溢出</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            <span class="keyword">elif</span> nums[mid] &lt; target:</span><br><span class="line">                <span class="comment"># 注意</span></span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> nums[mid] &gt; target:</span><br><span class="line">                <span class="comment"># 注意</span></span><br><span class="line">                right = mid - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">raise</span> ValueError(<span class="string">&quot;what the fuck&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>该函数存在巨大的局限性，<strong>数组中存在多个目标元素，该函数可能返回最左、最右甚至中间的索引</strong>。下面针对该函数的细节，做出解释</p>
<ul>
<li><code>right = len(nums) - 1</code> 表示搜索的闭区间是<code>[left,right]</code></li>
<li><code>left &lt;= right</code> ，之所以不是严格小于，可以假设<code>nums = [1],target=1</code>,严格小于答案不对</li>
<li><code>left = mid + 1</code>而不是<code>left = mid</code>是因为<code>nums[mid] &lt; target</code>,那么下一轮的搜索区间是<code>[mid+1,right]</code>不再包括<code>nums[mid]</code></li>
</ul>
<p>相关的例题有<a href="https://leetcode.cn/problems/binary-search/description/">LeetCode 704</a>二分查找，答案如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> vanilla_binary_search(nums, target)</span><br></pre></td></tr></table></figure>
<p>也可以直接用python内置的<code>bisect_left</code>，实现如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">from</span> bisect <span class="keyword">import</span> bisect_left</span><br><span class="line">        bsl = bisect_left(nums,target)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span> <span class="keyword">if</span> bsl == <span class="built_in">len</span>(nums) <span class="keyword">or</span> nums[bsl] != target <span class="keyword">else</span> bsl</span><br></pre></td></tr></table></figure>
<h4 id="寻找左侧边界的二分搜索-find-left-bound-binary-search"><a href="#寻找左侧边界的二分搜索-find-left-bound-binary-search" class="headerlink" title="寻找左侧边界的二分搜索&#x2F;find-left-bound-binary-search&#x2F;"></a>寻找左侧边界的二分搜索&#x2F;find-left-bound-binary-search&#x2F;</h4><blockquote>
<p>最相关例题：<a href="https://leetcode.cn/problems/search-insert-position/description/">https://leetcode.cn/problems/search-insert-position/description/</a><br>如下就开始系统性介绍<code>bisect</code>库了，非常重要的一个库，自己写二分边界条件简直是灾难，学会调用系统库<br>bisect 这个名称来源于 “binary search”（二分查找） 和 “section”（分段、划分） 的组合，可以理解为 “二分分割” 或 “二分插入”</p>
</blockquote>
<p>本质上就是实现<code>bisect.bisect_left</code>,该函数的定义为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; help(bisect.bisect_left)</span><br><span class="line">bisect_left(a, x, lo=0, hi=None, *, key=None)</span><br><span class="line">    Return the index where to insert item x in list a, assuming a is sorted.</span><br><span class="line">    </span><br><span class="line">    The return value i is such that all e in a[:i] have e &lt; x, and all e in</span><br><span class="line">    a[i:] have e &gt;= x.  So if x already appears in the list, a.insert(i, x) will</span><br><span class="line">    insert just before the leftmost x already there.</span><br><span class="line">    </span><br><span class="line">    Optional args lo (default 0) and hi (default len(a)) bound the</span><br><span class="line">    slice of a to be searched.</span><br></pre></td></tr></table></figure>
<p>其返回值<code>i</code>满足<code>max(a[:i]) &lt; x</code>且<code>min(a[i:]) &gt;= x</code>，<code>bisect.bisect_left</code>的内部实现如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">left_bound_binary_search</span>(<span class="params">nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    返回一个有序数组中第一个大于等于目标元素的索引。</span></span><br><span class="line"><span class="string">    例如：</span></span><br><span class="line"><span class="string">    nums = [1,2,2,2,3]，target = 2，函数返回 1，因为该数组中第一个大于等于2的元素是nums[1]=2</span></span><br><span class="line"><span class="string">    nums = [1,2,3,5,6]，target = 4，函数返回 3，因为该数组中第一个大于等于2的元素是nums[3]=5</span></span><br><span class="line"><span class="string">    nums = [1,2,3,5,6]，target = 7，函数返回 5 = len(nums)，表示该数组的所有元素nums[:5] &lt; target  = 7</span></span><br><span class="line"><span class="string">    nums = [1,2,3,5,6]，target = 0，函数返回 0，表示该数组中的nums[:0] = [] &lt; target = 0, i.e. 不存在元素小于target</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    left = <span class="number">0</span></span><br><span class="line">    <span class="comment"># 注意</span></span><br><span class="line">    right = <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="comment"># 注意</span></span><br><span class="line">    <span class="keyword">while</span> left &lt; right:</span><br><span class="line">        mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">            right = mid</span><br><span class="line">        <span class="keyword">elif</span> nums[mid] &lt; target:</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> nums[mid] &gt; target:</span><br><span class="line">            <span class="comment"># 注意</span></span><br><span class="line">            right = mid</span><br><span class="line">    <span class="keyword">return</span> left</span><br></pre></td></tr></table></figure>
<p><strong>该函数返回值域为<code>[0,len(nums)]</code>,除了返回<code>len(nums)</code>明确表示没找到，其余情况都得进行返回值<code>i</code>是不是满足<code>nums[i]==target</code>来判断有没有找到</strong></p>
<h4 id="寻找右侧边界的二分搜索-find-right-bound-binary-search"><a href="#寻找右侧边界的二分搜索-find-right-bound-binary-search" class="headerlink" title="寻找右侧边界的二分搜索&#x2F;find-right-bound-binary-search&#x2F;"></a>寻找右侧边界的二分搜索&#x2F;find-right-bound-binary-search&#x2F;</h4><p>本质上就是实现<code>bisect.bisect_right</code>,该函数的定义为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; help(bisect.bisect_right)</span><br><span class="line">bisect_right(a, x, lo=0, hi=None, *, key=None)</span><br><span class="line">    Return the index where to insert item x in list a, assuming a is sorted.</span><br><span class="line">    </span><br><span class="line">    The return value i is such that all e in a[:i] have e &lt;= x, and all e in</span><br><span class="line">    a[i:] have e &gt; x.  So if x already appears in the list, a.insert(i, x) will</span><br><span class="line">    insert just after the rightmost x already there.</span><br><span class="line">    </span><br><span class="line">    Optional args lo (default 0) and hi (default len(a)) bound the</span><br><span class="line">    slice of a to be searched.</span><br></pre></td></tr></table></figure>
<p>其返回值<code>i</code>满足<code>max(a[:i]) &lt;= x</code>且<code>min(a[i:]) &gt; x</code>，<code>bisect.bisect_right</code>的内部实现如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">right_bound_binary_search</span>(<span class="params">nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    返回一个有序数组中第一个严格大于目标元素的索引。</span></span><br><span class="line"><span class="string">    例如：</span></span><br><span class="line"><span class="string">    nums = [1,2,2,2,3]，target = 2，函数返回 4，因为该数组中第一个严格大于2的元素是nums[4]=3</span></span><br><span class="line"><span class="string">    nums = [1,2,3,5,6]，target = 4，函数返回 3，因为该数组中第一个严格大于4的元素是nums[3]=5</span></span><br><span class="line"><span class="string">    nums = [1,2,3,5,6]，target = 7，函数返回 5 = len(nums)，表示该数组的所有元素nums[:5] &lt;= target = 7</span></span><br><span class="line"><span class="string">    nums = [1,2,3,5,6]，target = 0，函数返回 0，因为该数组中第一个严格大于0的元素是nums[0]=1</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    left, right = <span class="number">0</span>, <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="keyword">while</span> left &lt; right:</span><br><span class="line">        mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">            <span class="comment"># 注意</span></span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> nums[mid] &lt; target:</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> nums[mid] &gt; target:</span><br><span class="line">            right = mid</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> left</span><br></pre></td></tr></table></figure>
<p><strong>该函数返回值域为<code>[0,len(nums)]</code>,除了返回0明确表示没有找到，其余情况都得进行返回值<code>i</code>是不是满足<code>nums[i-1]==target</code>来判断有没有找到</strong></p>
<h4 id="相关例题："><a href="#相关例题：" class="headerlink" title="相关例题："></a>相关例题：</h4><ul>
<li><a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/description/">LeetCode 34</a> 在排序数组中查找元素的第一个和最后一个位置</li>
<li><a href="https://leetcode.cn/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/">LCR 172</a> 统计目标成绩的出现次数</li>
<li><a href="https://leetcode.cn/problems/binary-search/description/">LeetCode 704</a> 二分查找</li>
</ul>
<h3 id="实际运用二分搜索时的思维框架"><a href="#实际运用二分搜索时的思维框架" class="headerlink" title="实际运用二分搜索时的思维框架"></a><a href="https://labuladong.online/algo/frequency-interview/binary-search-in-action/">实际运用二分搜索时的思维框架</a></h3><p>对于<code>bisect_left(a, x, lo=0, hi=None, *, key=None)</code>中的<code>key</code>我们需要理解：<br><img src="/../images/1746267436817-image.png" alt="alt text"><br><code>bisect_left</code>和<code>bisect_right</code>对于有序数组中找target的左右边界，只是这两个函数最基本的功能，更重要的是，<strong>这两个函数可以配合<code>key</code>参数对于某单调递增函数（单调递减取相反数）在值域上搜索函数值为target（同样单调递减需要取target的相反数）的左右边界，这是该函数的最主要功能</strong></p>
<ul>
<li><a href="https://leetcode.cn/problems/koko-eating-bananas/description/">LeetCode 875</a> 爱吃香蕉的珂珂</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minEatingSpeed</span>(<span class="params">self, piles: <span class="type">List</span>[<span class="built_in">int</span>], h: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">from</span> bisect <span class="keyword">import</span> bisect_left</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">            <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            k:  吃香蕉速度</span></span><br><span class="line"><span class="string">            return:  返回珂珂吃香蕉所需要的时间的相反数</span></span><br><span class="line"><span class="string">            k越大，所需时间越少，所需时间的相反数越大，所以f(k)是一个单调递增函数</span></span><br><span class="line"><span class="string">            &quot;&quot;&quot;</span></span><br><span class="line">            <span class="keyword">if</span> k == <span class="number">0</span>:</span><br><span class="line">                hours = <span class="number">2</span> ** <span class="number">31</span> - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                hours = <span class="number">0</span></span><br><span class="line">                <span class="keyword">for</span> p <span class="keyword">in</span> piles:</span><br><span class="line">                    hours += p // k</span><br><span class="line">                    <span class="keyword">if</span> p % k:</span><br><span class="line">                        hours += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> -hours</span><br><span class="line">        <span class="keyword">return</span> bisect_left(<span class="built_in">range</span>(<span class="number">0</span>, <span class="number">2</span> ** <span class="number">31</span>), -h, key=f) <span class="comment"># 注意对于h也要取相反数</span></span><br></pre></td></tr></table></figure>



<ul>
<li><a href="https://leetcode.cn/problems/capacity-to-ship-packages-within-d-days/description/">LeetCode 1011</a> 在D天内送达包裹的能力</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">shipWithinDays</span>(<span class="params">self, weights: <span class="type">List</span>[<span class="built_in">int</span>], days: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">capacity: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">            <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            capacity:  每条船的容量</span></span><br><span class="line"><span class="string">            return:  返回需要天数的相反数</span></span><br><span class="line"><span class="string">            capacity越大，需要天数越少，需要天数的相反数越大，所以f(capacity)是一个单调递增函数</span></span><br><span class="line"><span class="string">            &quot;&quot;&quot;</span></span><br><span class="line">            <span class="keyword">if</span> capacity &lt; <span class="built_in">max</span>(weights):</span><br><span class="line">                days = <span class="number">2</span> ** <span class="number">31</span> - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                days = <span class="number">0</span></span><br><span class="line">                capacity_left = capacity</span><br><span class="line">                <span class="keyword">for</span> weight <span class="keyword">in</span> weights:</span><br><span class="line">                    <span class="keyword">if</span> capacity_left - weight &gt;= <span class="number">0</span>:</span><br><span class="line">                        capacity_left -= weight</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        days += <span class="number">1</span></span><br><span class="line">                        capacity_left = capacity - weight</span><br><span class="line">                days += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> -days</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">from</span> bisect <span class="keyword">import</span> bisect_left</span><br><span class="line">        <span class="keyword">return</span> bisect_left(<span class="built_in">range</span>(<span class="number">0</span>, <span class="number">2</span>**<span class="number">31</span>-<span class="number">1</span>), -days, key=f) <span class="comment"># 注意对于days也要取相反数</span></span><br></pre></td></tr></table></figure>

<ul>
<li><a href="https://leetcode.cn/problems/split-array-largest-sum/description/">LeetCode 410*</a> 分割数组<br>该题及其巧妙，与<a href="https://leetcode.cn/problems/capacity-to-ship-packages-within-d-days/description/">LeetCode 1011</a> 在D天内送达包裹的能力本质上考虑的是一个问题</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">shipWithinDays</span>(<span class="params">self, weights: <span class="type">List</span>[<span class="built_in">int</span>], days: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">capacity: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">            <span class="keyword">if</span> capacity &lt; <span class="built_in">max</span>(weights):</span><br><span class="line">                days = <span class="number">2</span> ** <span class="number">31</span> - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                days = <span class="number">0</span></span><br><span class="line">                capacity_left = capacity</span><br><span class="line">                <span class="keyword">for</span> weight <span class="keyword">in</span> weights:</span><br><span class="line">                    <span class="keyword">if</span> capacity_left - weight &gt;= <span class="number">0</span>:</span><br><span class="line">                        capacity_left -= weight</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        days += <span class="number">1</span></span><br><span class="line">                        capacity_left = capacity - weight</span><br><span class="line">                days += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> -days</span><br><span class="line">        <span class="keyword">from</span> bisect <span class="keyword">import</span> bisect_left</span><br><span class="line">        <span class="keyword">return</span> bisect_left(<span class="built_in">range</span>(<span class="number">0</span>, <span class="number">2</span>**<span class="number">31</span>-<span class="number">1</span>), -days, key=f)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">splitArray</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.shipWithinDays(weights=nums,days=k)</span><br></pre></td></tr></table></figure>


<h3 id="【强化练习】二分搜索算法经典习题"><a href="#【强化练习】二分搜索算法经典习题" class="headerlink" title="【强化练习】二分搜索算法经典习题"></a><a href="https://labuladong.online/algo/problem-set/binary-search/">【强化练习】二分搜索算法经典习题</a></h3><ul>
<li><a href="https://leetcode.cn/problems/reshape-the-matrix/">Leetcode 566</a> 矩阵重塑<blockquote>
<p>ps:该题与二分无关，但是与二维的二分搜索有关</p>
</blockquote>
</li>
</ul>
<p>对于一个任意m行n列的矩阵$mat$，我们都可以将其flatten为一维数组$flat$该数组的长度为m*n，如何将两者联系起来联起来：<br>$$<br>mat[i][j] &#x3D; flat[i * n + j] \quad \text{其中} \quad i \in [0, m - 1], j \in [0, n - 1]\<br>flat[idx] &#x3D; mat[idx &#x2F;&#x2F; n][idx % n] \quad \text{其中} \quad idx \in [0, m * n - 1]<br>$$<br>基于此，我们可以设计如下连个函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self, mat: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], idx: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    得到mat对应的flat的idx位置的值，i.e.  flat[idx]</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    m,n = <span class="built_in">len</span>(mat), <span class="built_in">len</span>(mat[<span class="number">0</span>])</span><br><span class="line">    i,j = idx // n, idx % n</span><br><span class="line">    <span class="keyword">return</span> mat[i][j]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">set</span>(<span class="params">self, mat: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], idx: <span class="built_in">int</span>, val: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    将mat对应的flat的idx位置的值设置为val，i.e.  flat[idx] = val</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    m,n = <span class="built_in">len</span>(mat), <span class="built_in">len</span>(mat[<span class="number">0</span>])</span><br><span class="line">    i,j = idx // n, idx % n</span><br><span class="line">    mat[i][j] = val</span><br><span class="line">    <span class="keyword">return</span></span><br></pre></td></tr></table></figure>
<p>基于上述两个函数，我们可以得到</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">matrixReshape</span>(<span class="params">self, mat: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], r: <span class="built_in">int</span>, c: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        m, n = <span class="built_in">len</span>(mat), <span class="built_in">len</span>(mat[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">if</span> m * n != r * c:</span><br><span class="line">            <span class="keyword">return</span> mat</span><br><span class="line">        res = [[<span class="number">0</span>] * c <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(r)]</span><br><span class="line">        <span class="keyword">for</span> idx <span class="keyword">in</span> <span class="built_in">range</span>(m * n):</span><br><span class="line">            <span class="variable language_">self</span>.<span class="built_in">set</span>(res, idx, <span class="variable language_">self</span>.get(mat, idx))</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>



<ul>
<li><a href="https://leetcode.cn/problems/search-a-2d-matrix/">LeetCode 74</a> 搜索二维矩阵<br>可见<code>get(self, mat: List[List[int]], idx: int) -&gt; int</code>在二维有序矩阵的二分搜索的作用</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self, mat: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], idx: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        得到mat对应的flat的idx位置的值，i.e.  flat[idx]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        m, n = <span class="built_in">len</span>(mat), <span class="built_in">len</span>(mat[<span class="number">0</span>])</span><br><span class="line">        i, j = idx // n, idx % n</span><br><span class="line">        <span class="keyword">return</span> mat[i][j]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">searchMatrix</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        m,n = <span class="built_in">len</span>(matrix),<span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">idx:<span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">            <span class="comment"># 单调递增函数</span></span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">self</span>.get(matrix,idx)</span><br><span class="line">        <span class="keyword">from</span> bisect <span class="keyword">import</span> bisect_left</span><br><span class="line">        res_idx = bisect_left(<span class="built_in">range</span>(<span class="number">0</span>,m*n),target,key=f)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span> <span class="keyword">if</span> <span class="number">0</span>&lt;= res_idx &lt; m*n <span class="keyword">and</span> <span class="variable language_">self</span>.get(matrix,res_idx) == target <span class="keyword">else</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>


<ul>
<li><a href="https://leetcode-cn.com/problems/search-a-2d-matrix-ii/">LeetCode 240</a>  搜索二维矩阵 II</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">searchMatrix</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        flatten = []</span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span>  matrix:</span><br><span class="line">            flatten += row</span><br><span class="line">        flatten.sort()</span><br><span class="line">        <span class="keyword">from</span> bisect <span class="keyword">import</span> bisect_left</span><br><span class="line">        bsl = bisect_left(flatten,target)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span> <span class="keyword">if</span> <span class="number">0</span> &lt;= bsl &lt; <span class="built_in">len</span>(flatten) <span class="keyword">and</span> flatten[bsl] == target <span class="keyword">else</span> <span class="literal">False</span> </span><br></pre></td></tr></table></figure>

<ul>
<li><a href="https://leetcode.cn/problems/number-of-matching-subsequences/description/">Leetcode 729*</a> 匹配子序列的单词数<br>改题目作为<a href="https://leetcode.cn/problems/is-subsequence/">Leetcode 392</a> 判断子序列的衍生，392主要的想法是用两个指针分别遍历s,t，如果s[i] &#x3D;&#x3D; t[j]，则i++，j++，如果s[i] !&#x3D; t[j]，则j++，直到j &#x3D;&#x3D; len(t)，如果j &#x3D;&#x3D; len(t)，则返回True，否则返回False。但是729的words过大且有<strong>很多重复</strong>，直接遍历会TLE，尝试加入memo，则可以通过，告诉我们记忆化搜索是十分重要的。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.memo = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isSubsequence</span>(<span class="params">self, s: <span class="built_in">str</span>, t: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        leetcode 392</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> s <span class="keyword">in</span> <span class="variable language_">self</span>.memo:</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">self</span>.memo[s]</span><br><span class="line">        i,j = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(s) <span class="keyword">and</span> j&lt;<span class="built_in">len</span>(t):</span><br><span class="line">            <span class="keyword">if</span> s[i] == t[j]:</span><br><span class="line">                i+=<span class="number">1</span></span><br><span class="line">                j+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                j+=<span class="number">1</span></span><br><span class="line">        <span class="variable language_">self</span>.memo[s] = (i == <span class="built_in">len</span>(s))</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.memo[s]</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">numMatchingSubseq</span>(<span class="params">self, s: <span class="built_in">str</span>, words: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        leetcode 792</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">            <span class="keyword">if</span> <span class="variable language_">self</span>.isSubsequence(word,s):</span><br><span class="line">                res += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p>这个题目放到这里想必是和二分查找是有点关系的，对于<code>isSubsequence(self, s: str, t: str) -&gt; bool</code>使用循环遍历t是比较笨比的且t在这个题目中是固定的，可以建立一个索引数组$char2idxs$将每个字符与其所在的索引们对应起来，这样就可以不用遍历j了，下面是加入二分优化：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> bisect <span class="keyword">import</span> bisect_left</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.memo = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isSubsequence</span>(<span class="params">self, s: <span class="built_in">str</span>, char2idxs: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        leetcode 392</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> s <span class="keyword">in</span> <span class="variable language_">self</span>.memo:</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">self</span>.memo[s]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 不在memo中，需要计算</span></span><br><span class="line">        i,j = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(s):</span><br><span class="line">            c = s[i]</span><br><span class="line">            arr = char2idxs[<span class="built_in">ord</span>(c) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)]</span><br><span class="line">        </span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> arr:</span><br><span class="line">                <span class="comment"># 一定没有办法匹配</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            bsl = bisect_left(arr,j)</span><br><span class="line">            <span class="keyword">if</span> <span class="number">0</span>  &lt;= bsl &lt; <span class="built_in">len</span>(arr):</span><br><span class="line">                <span class="comment"># 一定是找到了的</span></span><br><span class="line">                j = arr[bsl] + <span class="number">1</span></span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="variable language_">self</span>.memo[s] = (i == <span class="built_in">len</span>(s))</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.memo[s]</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">numMatchingSubseq</span>(<span class="params">self, s: <span class="built_in">str</span>, words: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        leetcode 792</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment">#题目明确说明：两个字符串都只由小写字符组成</span></span><br><span class="line">        <span class="comment"># 对于其中某一个字母，其索引数组为char2idxs[ord(char) - ord(&#x27;a&#x27;)]，且为单调递增的</span></span><br><span class="line">        char2idxs = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">26</span>)] </span><br><span class="line">        <span class="keyword">for</span> idx, char <span class="keyword">in</span> <span class="built_in">enumerate</span>(s):</span><br><span class="line">            char2idxs[<span class="built_in">ord</span>(char) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)].append(idx)  </span><br><span class="line">        </span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">            <span class="keyword">if</span> <span class="variable language_">self</span>.isSubsequence(word,char2idxs):</span><br><span class="line">                res += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p>确实比没有用二分的要快很多。<br><img src="/../images/1746343037577-image.png" alt="alt text"></p>
<ul>
<li><a href="https://leetcode.cn/problems/find-k-closest-elements/">LeetCode 658</a> 找到最接近的K个数<br>可以直接用自定义key的排序来解决，这里面的<code>lambda y: abs(y-x)</code>是一个匿名函数，等价于：<code>def f(y): return abs(y-x)</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findClosestElements</span>(<span class="params">self, arr: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span>, x: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sorted</span>(<span class="built_in">sorted</span>(arr,key=<span class="keyword">lambda</span> y: <span class="built_in">abs</span>(y-x))[:k])</span><br></pre></td></tr></table></figure>
<p>该算法的复杂度是O(nlogn)，利用二分查找+双指针可以优化成$O(logn+k+klogk)\approx O(logn)$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findClosestElements</span>(<span class="params">self, arr: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span>, x: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">from</span> bisect <span class="keyword">import</span> bisect_left</span><br><span class="line"></span><br><span class="line">        bsl = bisect_left(arr, x)</span><br><span class="line"></span><br><span class="line">        pos = bsl - <span class="number">1</span> <span class="keyword">if</span> bsl == <span class="built_in">len</span>(arr) <span class="keyword">or</span> (bsl &gt; <span class="number">0</span> <span class="keyword">and</span> <span class="built_in">abs</span>(arr[bsl - <span class="number">1</span>] - x) &lt;= <span class="built_in">abs</span>(arr[bsl] - x)) <span class="keyword">else</span> bsl</span><br><span class="line">        res = [arr[pos]]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 双指针</span></span><br><span class="line">        left, right = pos - <span class="number">1</span>, pos + <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(res) &lt; k:</span><br><span class="line">            <span class="keyword">if</span> <span class="number">0</span> &lt;= left &lt; <span class="built_in">len</span>(arr) <span class="keyword">and</span> <span class="number">0</span> &lt;= right &lt; <span class="built_in">len</span>(arr):</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">abs</span>(arr[left] - x) &lt;= <span class="built_in">abs</span>(arr[right] - x):</span><br><span class="line">                    res.append(arr[left])</span><br><span class="line">                    left -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    res.append(arr[right])</span><br><span class="line">                    right += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> <span class="number">0</span> &lt;= left &lt; <span class="built_in">len</span>(arr):</span><br><span class="line">                res.append(arr[left])</span><br><span class="line">                left -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> <span class="number">0</span> &lt;= right &lt; <span class="built_in">len</span>(arr):</span><br><span class="line">                res.append(arr[right])</span><br><span class="line">                right += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">raise</span> ValueError(<span class="string">&quot;Fuck&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sorted</span>(res)</span><br></pre></td></tr></table></figure>
<ul>
<li><a href="https://leetcode.cn/problems/find-peak-element/">Leetcode 162</a> 寻找峰值<br>题目中明确说明<code>1 &lt;= nums.length &lt;= 1000</code>直接线性遍历就好</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findPeakElement</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)-<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &gt;= nums[i+<span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(nums)-<span class="number">1</span></span><br></pre></td></tr></table></figure>

<ul>
<li><a href="https://leetcode.cn/problems/search-in-rotated-sorted-array/">Leetcode 33</a> 搜索旋转排序数组</li>
<li><a href="https://leetcode.cn/problems/search-in-rotated-sorted-array-ii/">Leetcode 81</a> 搜索旋转排序数组 II<br>这俩放一块说吧，本质上就是循环数组的二分查找，建议直接<code>sort</code>一下，然后二分查找即可,搞那些花里胡哨干什么….</li>
</ul>
<h3 id="带权重的随机选择算法"><a href="#带权重的随机选择算法" class="headerlink" title="带权重的随机选择算法"></a><a href="https://labuladong.online/algo/frequency-interview/random-pick-with-weight/">带权重的随机选择算法</a></h3><p>该篇文章本质上就是在将一个随机变量$X$其分从Categorical distribution(或者说广义伯努利分布)<br>$$<br>X\sim \text{Categorical distribution}(p_1, p_2, \dots, p_n ) \textbf{ where }\sum_{i&#x3D;1}^{n}p_i &#x3D; 1<br>$$<br>需要完成该随即便利的RNG，最基本的就是用<code>random.chooses()</code>该函数的定义为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; help(random.choices)</span><br><span class="line">choices(population, weights=None, *, cum_weights=None, k=1) method of random.Random instance</span><br><span class="line">    Return a k sized list of population elements chosen with replacement.</span><br><span class="line">    </span><br><span class="line">    If the relative weights or cumulative weights are not specified,</span><br><span class="line">    the selections are made with equal probability.</span><br></pre></td></tr></table></figure>
<p>该函数的内部实现如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">rng</span>(<span class="params">self, probs:<span class="type">List</span>[<span class="built_in">float</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    probs: list[float] 类别0,1,...,len(probs)-1所对应的概率</span></span><br><span class="line"><span class="string">    Return：int 类别</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">sum</span>(probs) == <span class="number">1</span></span><br><span class="line">    r = random.random()</span><br><span class="line">    cumulative = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> idx,prob <span class="keyword">in</span> <span class="built_in">enumerate</span>(probs):</span><br><span class="line">        cumulative += prob</span><br><span class="line">        <span class="keyword">if</span> cumulative &gt; r:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> idx</span><br></pre></td></tr></table></figure>
<p>尝试分析一下概算法的时间复杂度，最坏情况，最后一个类别的概率很大，probs&#x3D;[0,0,0,0,….,1]这种情况，时间复杂度是O(n)，平均情况是O(n&#x2F;2)&#x3D;O(n),<strong>总结来说，时间复杂度是O(n)，我们尝试优化他</strong>，上述for循环的内部，本质上就是找你生成的r在pre_sum_of_probs的左边界，可以用二分来优化：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 多次调用rng,我们缓存好pre_sum_of_probs，这样时间复杂度就变成O(1)了</span></span><br><span class="line">pre_sum = [<span class="number">0</span>] * (<span class="built_in">len</span>(probs) + <span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(probs) + <span class="number">1</span>):</span><br><span class="line">    pre_sum[i] = pre_sum[i-<span class="number">1</span>] + probs[i-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">rng</span>(<span class="params">self, pre_sum: <span class="type">List</span>[<span class="built_in">float</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    r  = random.random()</span><br><span class="line">    pos = bisect_left(pre_sum, r)</span><br><span class="line">    <span class="keyword">return</span> pos - <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p><strong>这样我们就把原来O(n)优化到O(logn)了</strong>引用此算法我们可以解决</p>
<ul>
<li><a href="https://leetcode.cn/problems/random-pick-with-weight/">Leetcode 528</a> . 按权重随机选择</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> bisect <span class="keyword">import</span> bisect_left</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, w: <span class="type">List</span>[<span class="built_in">int</span>]</span>):</span><br><span class="line">        <span class="variable language_">self</span>.probs = [_/<span class="built_in">sum</span>(w) <span class="keyword">for</span> _ <span class="keyword">in</span> w]</span><br><span class="line">        <span class="variable language_">self</span>.pre_sum = [<span class="number">0</span>] * (<span class="built_in">len</span>(<span class="variable language_">self</span>.probs) + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(<span class="variable language_">self</span>.pre_sum)):</span><br><span class="line">            <span class="variable language_">self</span>.pre_sum[i] = <span class="variable language_">self</span>.pre_sum[i-<span class="number">1</span>] + <span class="variable language_">self</span>.probs[i-<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pickIndex</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> bisect_left(<span class="variable language_">self</span>.pre_sum,random()) - <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>O(logn)和O(n)复杂度的算法的时间确实有不小差距：<br><img src="/../images/1746426165225-image.png" alt="alt text"></p>
<h3 id="田忌赛马背后的算法决策"><a href="#田忌赛马背后的算法决策" class="headerlink" title="田忌赛马背后的算法决策"></a><a href="https://labuladong.online/algo/practice-in-action/advantage-shuffle/">田忌赛马背后的算法决策</a></h3><ul>
<li>什么时候送人头？ 自己的最厉害的比不过别人最厉害的，索性送了</li>
<li>什么时候不送人头？ 自己的最厉害的比过别人最厉害的，不送</li>
</ul>
<p><a href="https://leetcode.cn/problems/advantage-shuffle/">Leetcode 870</a> 田忌赛马&#x2F;优势洗牌</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">advantageCount</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], nums2: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        dq_nums1 = deque(<span class="built_in">sorted</span>(nums1))</span><br><span class="line">        hq_nums2 = [(-num, idx) <span class="keyword">for</span> idx, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums2)] <span class="comment"># 模拟最大堆</span></span><br><span class="line">        heapq.heapify(hq_nums2)</span><br><span class="line"></span><br><span class="line">        res = [<span class="number">0</span>] * <span class="built_in">len</span>(nums1)</span><br><span class="line">        <span class="keyword">while</span> hq_nums2:</span><br><span class="line">            num, idx = heapq.heappop(hq_nums2)</span><br><span class="line">            num *= -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> num &lt; dq_nums1[-<span class="number">1</span>]:</span><br><span class="line">                res[idx] = dq_nums1.pop()</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res[idx] = dq_nums1.popleft()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>


<h2 id="经典队列-栈算法"><a href="#经典队列-栈算法" class="headerlink" title="经典队列&#x2F;栈算法"></a>经典队列&#x2F;栈算法</h2><h3 id="队列实现栈以及栈实现队列"><a href="#队列实现栈以及栈实现队列" class="headerlink" title="队列实现栈以及栈实现队列"></a><a href="https://labuladong.online/algo/data-structure/stack-queue/">队列实现栈以及栈实现队列</a></h3><blockquote>
<p>无论是队列还是栈，其本质都是<strong>受限制的数组或者链表</strong>，两者本质上的区别</p>
<ul>
<li>队列：一头进，<strong>另</strong>一头出</li>
<li>栈：一头进，<strong>这</strong>一头出</li>
</ul>
</blockquote>
<p>现在的问题是这两者之间能不能相互转换？</p>
<h4 id="用栈模拟队列"><a href="#用栈模拟队列" class="headerlink" title="用栈模拟队列"></a>用栈模拟队列</h4><ul>
<li><a href="https://leetcode.cn/problems/implement-queue-using-stacks/">Leetcode 232</a> 用栈实现队列<br>核心想法就是搞两个栈，一个叫<code>queue_tail</code>一个是叫<code>queue_head</code>,push()的时候，压入栈<code>queue_tail</code>，pop() or peak()的时候，尝试从<code>queue_head</code>pop,如果没有就将<code>queue_tail</code>中的元素全部压入<code>queue_head</code>中，再从<code>queue_head</code>pop，代码实现如下：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.queue_tail = []</span><br><span class="line">        <span class="variable language_">self</span>.queue_head = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="variable language_">self</span>.queue_tail.append(x)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="variable language_">self</span>.peek()</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.queue_head.pop()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">peek</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="variable language_">self</span>.queue_head:</span><br><span class="line">            <span class="keyword">while</span> <span class="variable language_">self</span>.queue_tail:</span><br><span class="line">                <span class="variable language_">self</span>.queue_head.append(<span class="variable language_">self</span>.queue_tail.pop())</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.queue_head[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">empty</span>(<span class="params">self</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(<span class="variable language_">self</span>.queue_head) + <span class="built_in">len</span>(<span class="variable language_">self</span>.queue_tail) == <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>来分析一下这个栈模拟队列的算法的时间复杂度：</p>
<ul>
<li>push()：O(1)</li>
<li>peak(): 最优时间复杂度O(1),最坏时间复杂度O(n)，平均到每个元素为O(1)</li>
<li>pop(): 最优时间复杂度O(1),最坏时间复杂度O(n)，平均到每个元素为O(1)</li>
</ul>
<h3 id="用队列模拟栈"><a href="#用队列模拟栈" class="headerlink" title="用队列模拟栈"></a>用队列模拟栈</h3><ul>
<li><a href="https://leetcode.cn/problems/implement-stack-using-queues/">Leetcode 225</a> 用队列实现栈<br>与用栈模拟队列相比，用队列模拟栈显得十分无聊，完全没有任何应用情景，只是单纯为了做题，其想法比较搞怪，只用一个q就可以完成，如下是代码：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue <span class="comment"># 使用严格的单端队列</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.q = Queue()</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="variable language_">self</span>.q.put(x)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="variable language_">self</span>.q.qsize()-<span class="number">1</span>):</span><br><span class="line">            <span class="variable language_">self</span>.q.put(<span class="variable language_">self</span>.q.get())</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.q.get()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">top</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="variable language_">self</span>.q.qsize()-<span class="number">1</span>):</span><br><span class="line">            <span class="variable language_">self</span>.q.put(<span class="variable language_">self</span>.q.get())</span><br><span class="line">        res = <span class="variable language_">self</span>.q.get()</span><br><span class="line">        <span class="variable language_">self</span>.q.put(res)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">empty</span>(<span class="params">self</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.q.qsize() == <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>其核心想法就是<code>self.q.put(self.q.get())</code>,让队列扮演大蛇丸…算法复杂度</p>
<ul>
<li>push()：O(1)</li>
<li>peak(): O(n)</li>
<li>pop(): O(n)</li>
<li>empty(): O(1)</li>
</ul>
<p>与两个栈模拟队列相比，用队列模拟栈屁用没有。</p>
<h3 id="【练习】栈的经典习题"><a href="#【练习】栈的经典习题" class="headerlink" title="【练习】栈的经典习题"></a><a href="https://labuladong.online/algo/problem-set/stack/">【练习】栈的经典习题</a></h3><ul>
<li><p><a href="https://leetcode.cn/problems/simplify-path/">Leetcode 71</a> 简化路径<br>简单题</p>
</li>
<li><p><a href="https://leetcode.cn/problems/reorder-list/">Leetcode 143</a> 重排链表<br>dummy后面一个正序一个逆序，逆序需要stk，正序直接遍历head就可以，但是感觉不如deque直观</p>
</li>
<li><p><a href="https://leetcode.cn/problems/valid-parentheses/">Leetcode 20</a> 括号匹配<br>简单题</p>
</li>
<li><p><a href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/">Leetcode 150*</a> 逆波兰表达式求值<br>注意python的<code>eval()</code>函数</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; help(eval)</span><br><span class="line">eval(source, globals=None, locals=None, /)</span><br><span class="line">    Evaluate the given source in the context of globals and locals.</span><br><span class="line">    </span><br><span class="line">    The source may be a string representing a Python expression</span><br><span class="line">    or a code object as returned by compile().</span><br><span class="line">    The globals must be a dictionary and locals can be any mapping,</span><br><span class="line">    defaulting to the current globals and locals.</span><br><span class="line">    If only globals is given, locals defaults to it.</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">evalRPN</span>(<span class="params">self, tokens: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        stk = []</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> tokens:</span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">in</span> <span class="string">&quot;+-*/&quot;</span>:</span><br><span class="line">                r = <span class="built_in">str</span>(stk.pop())</span><br><span class="line">                l = <span class="built_in">str</span>(stk.pop())</span><br><span class="line">                stk.append(<span class="built_in">int</span>(<span class="built_in">eval</span>(l + c + r)))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                stk.append(c)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">int</span>(stk.pop())</span><br></pre></td></tr></table></figure>



<ul>
<li><a href="https://leetcode-cn.com/problems/longest-absolute-file-path/">LeetCode 388.</a>  文件的最长绝对路径<br>核心想法就是用一个栈去维护该文件or文件夹的父路径，当该文件的level&lt;父路径的层级,则说明要弹出栈顶的元素</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lengthLongestPath</span>(<span class="params">self, <span class="built_in">input</span>: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        parts = <span class="built_in">input</span>.split(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">        stk = []</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> part <span class="keyword">in</span> parts:</span><br><span class="line">            level = part.count(<span class="string">&quot;\t&quot;</span>)</span><br><span class="line">            remain = part.replace(<span class="string">&quot;\t&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">            is_file = <span class="string">&quot;.&quot;</span> <span class="keyword">in</span> remain</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> <span class="built_in">len</span>(stk) &gt; level:</span><br><span class="line">                stk.pop()</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> is_file:</span><br><span class="line">                stk.append(remain)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                tmp = <span class="string">&quot;/&quot;</span>.join(stk)</span><br><span class="line">                tmp += <span class="string">&quot;/&quot;</span> <span class="keyword">if</span> tmp != <span class="string">&quot;&quot;</span> <span class="keyword">else</span> <span class="string">&quot;&quot;</span>  <span class="comment"># 根目录不加  /</span></span><br><span class="line">                tmp += remain</span><br><span class="line">                res = <span class="built_in">max</span>(res, <span class="built_in">len</span>(tmp))</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>





<ul>
<li><a href="https://leetcode-cn.com/problems/min-stack/">LeetCode 155</a> 最小栈<br>不要搞什么一个min_val变量，这样的化push的时候好解决，但是pop的时候你pop出的元素&#x3D;&#x3D;min_val的时候你就得要遍历整个栈来更新min_val,空间换时间，索性就换个彻底，每次压栈的时候就(val,min_val),val:当前元素,min_val:当前栈的最小值 这两个元素都压入。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.stk = []</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self, val: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="variable language_">self</span>.stk:</span><br><span class="line">            <span class="variable language_">self</span>.stk.append((val,val))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="variable language_">self</span>.stk.append((val,<span class="built_in">min</span>(val,<span class="variable language_">self</span>.stk[-<span class="number">1</span>][<span class="number">1</span>])))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.stk:</span><br><span class="line">            <span class="variable language_">self</span>.stk.pop()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">top</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.stk:</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">self</span>.stk[-<span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getMin</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.stk:</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">self</span>.stk[-<span class="number">1</span>][<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>





<ul>
<li><a href="https://leetcode-cn.com/problems/maximum-frequency-stack/">LeetCode 895*</a> 最大频率栈<br>自己想的一个办法，用Counter来记录每个数字出现的频率，然后每次取频率最大的数字，如果频率相同，则取最近出现的出现的数字。<br>需要注意的是，python的<code>Counter().most_common()</code>实现通常是通过堆排序，其时间复杂度是O(klogk)，k表示当前Counter中数字的个数。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FreqStack</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.stk = []</span><br><span class="line">        <span class="variable language_">self</span>.cnt = Counter()</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self, val: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="variable language_">self</span>.stk.append(val)</span><br><span class="line">        <span class="variable language_">self</span>.cnt[val] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.stk:</span><br><span class="line">            _,most_freq = <span class="variable language_">self</span>.cnt.most_common(<span class="number">1</span>)[<span class="number">0</span>]</span><br><span class="line">            most_freq_eles = []</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> ele,freq <span class="keyword">in</span> <span class="variable language_">self</span>.cnt.most_common():</span><br><span class="line">                <span class="keyword">if</span> freq == most_freq:</span><br><span class="line">                    most_freq_eles.append(ele)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">            indexs = [idx <span class="keyword">for</span> idx,num <span class="keyword">in</span> <span class="built_in">enumerate</span>(<span class="variable language_">self</span>.stk) <span class="keyword">if</span> num <span class="keyword">in</span> most_freq_eles]</span><br><span class="line">            droped = <span class="variable language_">self</span>.stk.pop(indexs[-<span class="number">1</span>])</span><br><span class="line">            <span class="variable language_">self</span>.cnt[droped] -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> droped</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&quot;wtf?&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>下面对该算法进行复杂度分析，假设进行N次<code>push</code>操作，M次<code>pop</code>操作，那么时间复杂度如下：</p>
<ul>
<li>每次<code>push</code>操作，时间复杂度是O(1)，所以总时间复杂度是O(N)</li>
<li>每次<code>pop</code>操作，most_common()的最坏情况是O(NlogN),且又遍历了整个stk再加上O(N),则每次的时间复杂度是O(NlogN+N),整体的时间复杂度是O(M(NlogN+N)) &#x3D; O(MNlogN)</li>
</ul>
<p>题目中说明了，push 和 pop 的操作数不大于 2 * 10^4，<strong>O(MNlogN)的复杂度会TLE了</strong></p>
<p>思考一下 push 和 pop 方法，难点如下：</p>
<ul>
<li>1、每次 pop 时，必须要知道频率最高的元素是什么。</li>
<li>2、如果频率最高的元素有多个，还得知道哪个是最近 push 进来的元素是哪个。</li>
</ul>
<p>为了实现上述难点，我们要做到以下几点：</p>
<ul>
<li>1、肯定要有一个变量 max_freq 记录当前栈中最高的频率是多少。</li>
<li>2、我们得知道一个频率 freq 对应的元素(freq2vals)有哪些，且这些元素要有时间顺序。</li>
<li>3、随着 pop 的调用，每个 val 对应的频率会变化，所以还得维持一个映射记录每个 val 对应的 freq(val2freq)</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FreqStack</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.max_freq = <span class="number">0</span></span><br><span class="line">        <span class="comment"># FV表</span></span><br><span class="line">        <span class="variable language_">self</span>.freq2vals = defaultdict(<span class="built_in">list</span>)</span><br><span class="line">        <span class="comment"># VF表</span></span><br><span class="line">        <span class="variable language_">self</span>.val2freq = defaultdict(<span class="built_in">int</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self, val: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="variable language_">self</span>.val2freq[val] += <span class="number">1</span></span><br><span class="line">        freq = <span class="variable language_">self</span>.val2freq[val]</span><br><span class="line">        <span class="variable language_">self</span>.freq2vals[freq].append(val)</span><br><span class="line">        <span class="variable language_">self</span>.max_freq = <span class="built_in">max</span>(<span class="variable language_">self</span>.max_freq,freq)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        vals = <span class="variable language_">self</span>.freq2vals[<span class="variable language_">self</span>.max_freq]</span><br><span class="line">        v = vals.pop()</span><br><span class="line">        <span class="variable language_">self</span>.val2freq[v] -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> vals:</span><br><span class="line">            <span class="comment"># 如果 maxFreq 对应的元素空了</span></span><br><span class="line">            <span class="variable language_">self</span>.max_freq -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> v</span><br></pre></td></tr></table></figure>


<h3 id="【练习】括号类问题汇总"><a href="#【练习】括号类问题汇总" class="headerlink" title="【练习】括号类问题汇总"></a><a href="https://labuladong.online/algo/problem-set/parentheses/">【练习】括号类问题汇总</a></h3><ul>
<li><p><a href="https://leetcode.cn/problems/valid-parentheses/">Leetcode 20</a> 有效的括号<br>最为经典的栈的应用，压栈的时候分类讨论，最后是不是valid看stk是否非空</p>
</li>
<li><p><a href="https://leetcode.cn/problems/minimum-add-to-make-parentheses-valid/">Leetcode 921</a> 使括号有效的最少添加<br>和上面的题目本质上一样，上面的题目是否valid看是不是stk为空，最小的添加就是stk.size()</p>
</li>
<li><p><a href="https://leetcode.cn/problems/minimum-insertions-to-balance-a-parentheses-string/">Leetcode 1541*</a> 最小插入次数使括号有效的方法<br>用了一个非常奇怪的方法，过了两边栈</p>
</li>
</ul>
<h3 id="【练习】队列的经典习题"><a href="#【练习】队列的经典习题" class="headerlink" title="【练习】队列的经典习题"></a><a href="https://labuladong.online/algo/problem-set/queue/">【练习】队列的经典习题</a></h3><ul>
<li><a href="https://leetcode.cn/problems/design-front-middle-back-queue/description/">Leetcode 1670*</a> 设计前中后队列<br>本质上就是封装<code>deque</code>,注意deque是没有deque.pop(index)这个方法的，需要采用<code>del deque[index]</code>来删除元素</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FrontMiddleBackQueue</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.dq = deque()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pushFront</span>(<span class="params">self, val: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="variable language_">self</span>.dq.appendleft(val)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pushMiddle</span>(<span class="params">self, val: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="variable language_">self</span>.dq.insert(<span class="built_in">len</span>(<span class="variable language_">self</span>.dq) // <span class="number">2</span>, val)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pushBack</span>(<span class="params">self, val: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="variable language_">self</span>.dq.append(val)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">popFront</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.dq:</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">self</span>.dq.popleft()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">popMiddle</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.dq:</span><br><span class="line">            <span class="comment"># 需要分类一下长度是奇数还是偶数</span></span><br><span class="line">            mid_idx = <span class="built_in">len</span>(<span class="variable language_">self</span>.dq) // <span class="number">2</span> <span class="keyword">if</span> <span class="built_in">len</span>(<span class="variable language_">self</span>.dq) % <span class="number">2</span> == <span class="number">1</span> <span class="keyword">else</span> <span class="built_in">len</span>(<span class="variable language_">self</span>.dq) // <span class="number">2</span> - <span class="number">1</span></span><br><span class="line">            mid = <span class="variable language_">self</span>.dq[mid_idx]</span><br><span class="line">            <span class="comment"># 删除中间元素</span></span><br><span class="line">            <span class="keyword">del</span> <span class="variable language_">self</span>.dq[mid_idx]</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">popBack</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.dq:</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">self</span>.dq.pop()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">repr</span>(<span class="variable language_">self</span>.dq)</span><br></pre></td></tr></table></figure>



<h3 id="单调栈算法模板解决三道例题"><a href="#单调栈算法模板解决三道例题" class="headerlink" title="单调栈算法模板解决三道例题"></a><a href="https://labuladong.online/algo/data-structure/monotonic-stack/">单调栈算法模板解决三道例题</a></h3><h4 id="单调栈模板"><a href="#单调栈模板" class="headerlink" title="单调栈模板"></a>单调栈模板</h4><p>对于一个长度为n的数组$nums$,我们希望获得一个长度为n的数组$ans$，其定义如下：<br>$$<br>ans[i]&#x3D; nums[i+1,i+2,..,n-1] \text{中比} nums[i] \text{大的元素，如果没有则为-1}<br>$$<br>例如：nums &#x3D; [2,1,2,4,3]，那么ans &#x3D; [4,2,4,-1,-1]。显然可以将上述功能以$O(n^2)$的复杂度时间</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">nextGreaterElement</span>(<span class="params">nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">    ans = [<span class="number">0</span>] * <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="keyword">for</span> idx, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">        tmp = -<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> jdx <span class="keyword">in</span> <span class="built_in">range</span>(idx + <span class="number">1</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[jdx] &gt; num:</span><br><span class="line">                tmp = nums[jdx]</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        ans[idx] = tmp</span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>可以用单调栈将其优化到$O(n)$,首先来看一下单调栈的定义</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MonotonicStack</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, increasing=<span class="literal">True</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Initialize a monotonic stack.</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        Parameters:</span></span><br><span class="line"><span class="string">        - increasing: If True, maintains stack in increasing order (bottom to top).</span></span><br><span class="line"><span class="string">                     If False, maintains stack in decreasing order.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="variable language_">self</span>.stack = []</span><br><span class="line">        <span class="variable language_">self</span>.increasing = increasing</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self, val</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Push a value onto the stack while maintaining monotonic property.</span></span><br><span class="line"><span class="string">        Removes elements that would violate the monotonic condition.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.increasing:</span><br><span class="line">            <span class="comment"># 单调递增栈：元素从栈底递增到栈顶，栈顶最大，栈底最小</span></span><br><span class="line">            <span class="keyword">while</span> <span class="variable language_">self</span>.stack <span class="keyword">and</span> <span class="variable language_">self</span>.stack[-<span class="number">1</span>] &gt; val:</span><br><span class="line">                <span class="variable language_">self</span>.stack.pop()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 单调递减栈：元素从栈底递减到栈顶，栈顶最小，栈底最大</span></span><br><span class="line">            <span class="keyword">while</span> <span class="variable language_">self</span>.stack <span class="keyword">and</span> <span class="variable language_">self</span>.stack[-<span class="number">1</span>] &lt; val:</span><br><span class="line">                <span class="variable language_">self</span>.stack.pop()</span><br><span class="line">        <span class="variable language_">self</span>.stack.append(val)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.stack.pop() <span class="keyword">if</span> <span class="variable language_">self</span>.stack <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">top</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.stack[-<span class="number">1</span>] <span class="keyword">if</span> <span class="variable language_">self</span>.stack <span class="keyword">else</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>
<p>对于上面的<code>nextGreaterElement(nums: List[int]) -&gt; List[int]</code>函数，我们尝试从尾部倒着压入一个单调递减栈，</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">nextGreaterElement</span>(<span class="params">nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">    ans = [<span class="number">0</span>] * <span class="built_in">len</span>(nums)</span><br><span class="line">    stk = []</span><br><span class="line">    <span class="keyword">for</span> idx <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums) - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>): <span class="comment"># 倒序遍历</span></span><br><span class="line">        <span class="comment"># 单调递减栈：元素从栈底递减到栈顶，栈顶最小，栈底最大</span></span><br><span class="line">        <span class="keyword">while</span> stk <span class="keyword">and</span> stk[-<span class="number">1</span>] &lt; nums[idx]: <span class="comment"># 尝试压入</span></span><br><span class="line">            stk.pop()</span><br><span class="line">        ans[idx] = stk[-<span class="number">1</span>] <span class="keyword">if</span> stk <span class="keyword">else</span> -<span class="number">1</span> <span class="comment"># 如果栈为空，则说明该元素后面没有比它大的元素</span></span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>显然该函数的时间复杂度是$O(n)$，该题就是<a href="https://leetcode.cn/problems/next-greater-element-i/">Leetcode 496</a> 下一个元素-i</p>
<h4 id="单调栈例题"><a href="#单调栈例题" class="headerlink" title="单调栈例题"></a>单调栈例题</h4><ul>
<li><a href="https://leetcode.cn/problems/daily-temperatures/">Leetcode 739*</a> 每日温度<br>与前面的模板稍有不用，这个关系的不是下一个更大的元素本身，而是下一个更大元素与当前的idx差，所以压栈的时候要额外记录idx，代码实现如下：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dailyTemperatures</span>(<span class="params">self, temperatures: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> idx, temp_with_idx <span class="keyword">in</span> <span class="built_in">enumerate</span>(<span class="variable language_">self</span>.calculateNextGreaterElement(temperatures)):</span><br><span class="line">            temp, temp_idx = temp_with_idx</span><br><span class="line">            <span class="keyword">if</span> temp == -<span class="number">1</span>:</span><br><span class="line">                res.append(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res.append(temp_idx - idx)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">calculateNextGreaterElement</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        ans = [<span class="literal">None</span>] * <span class="built_in">len</span>(nums)</span><br><span class="line">        stk = []</span><br><span class="line">        <span class="keyword">for</span> idx <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums) - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">while</span> stk <span class="keyword">and</span> stk[-<span class="number">1</span>][<span class="number">0</span>] &lt;= nums[idx]:</span><br><span class="line">                stk.pop()</span><br><span class="line">            ans[idx] = stk[-<span class="number">1</span>] <span class="keyword">if</span> stk <span class="keyword">else</span> (-<span class="number">1</span>, -<span class="number">1</span>)</span><br><span class="line">            <span class="comment"># 记得压入idx</span></span><br><span class="line">            stk.append((nums[idx], idx))</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<ul>
<li><a href="https://leetcode.cn/problems/next-greater-element-ii/description/">Leetcode 503</a> 下一个更大元素-ii<br>数组变成了环形的数组，注意对idx取模，相当于说将两个nums拼接在一起了。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">nextGreaterElements</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        stk = []</span><br><span class="line">        ans = [<span class="number">0</span>] * n</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>*n-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">            real_idx = i % n</span><br><span class="line">            <span class="keyword">while</span> stk <span class="keyword">and</span> stk[-<span class="number">1</span>] &lt;= nums[real_idx]:</span><br><span class="line">                stk.pop()</span><br><span class="line">            ans[real_idx] = stk[-<span class="number">1</span>] <span class="keyword">if</span> stk <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line">            stk.append(nums[real_idx])</span><br><span class="line">        <span class="keyword">return</span> ans   </span><br></pre></td></tr></table></figure>
<p>该问题更加泛化的题解详见下文。</p>
<h3 id="【练习】单调栈的几种变体及经典习题"><a href="#【练习】单调栈的几种变体及经典习题" class="headerlink" title="【练习】单调栈的几种变体及经典习题"></a><a href="https://labuladong.online/algo/problem-set/monotonic-stack/">【练习】单调栈的几种变体及经典习题</a></h3><p>前文中我们实现了<strong>下一个更大元素<code>nextGreaterElement(nums: List[int]) -&gt; List[int]</code></strong>,我们将这个问题泛化，请实现：</p>
<ul>
<li>下一个更大或相等元素</li>
<li>下一个更小元素</li>
<li>下一个更小或相等元素</li>
<li>上一个更大元素</li>
<li>上一个更大或相等元素</li>
<li>上一个更小元素</li>
<li>上一个更小或相等元素<br>可以以如下思维导图汇总</li>
</ul>
<!-- <pre class="mermaid">mindmap
  root((单调栈问题))
    下一个元素
      更大
        严格更大
        更大或者相等
      更小
        严格更小
        更小或者相等
    上一个元素
      更大
        严格更大
        更大或者相等
      更小
        严格更小
        更小或者相等
``` -->
<p><img src="/../images/1746709574123-image.png" alt="alt text"></p>
<p>同时还要考虑到是不是循环数组，总共$2<em>2</em>2*2&#x3D;16$种情况，我们定义如下的算法模板：</p>
<pre><code class="language-python">def monoStkTemplate(nums: List[int], is_cyclic=False: bool, is_next=True: bool, is_greater=True: bool,is_equal=True: bool) -&gt; List[int]:
    &quot;&quot;&quot;
    nums: 输入数组
    is_cyclic: 是否循环数组
    is_next: 是关注下一个元素，还是上一个元素
    is_greater: 是关注更大还是更小
    is_equal: 是严格更大/更小还是包括等于的情况
    &quot;&quot;&quot;
    n = len(nums)
    ans = [0] * n
    stk = []

    range_ = None
    comparator = None

    if is_next and is_cyclic:
        range_ = range(2*n-1,-1,-1) 
    elif is_next and not is_cyclic:
        range_ = range(n-1, -1, -1)
    elif not is_next and is_cyclic:
        range_ = range(2*n)
    elif not is_next and not is_cyclic:
        range_ = range(n)

    if is_greater and is_equal:
        comparator = lambda stk_top, cur: stk_top &lt; cur
    elif is_greater and not is_equal:
        comparator = lambda stk_top, cur: stk_top &lt;= cur
    elif not is_greater and is_equal:
        comparator = lambda stk_top, cur: stk_top &gt; cur
    elif not is_greater and not is_equal:
        comparator = lambda stk_top, cur: stk_top &gt;= cur

    for i in range_:
        idx = i % k
        cur = nums[idx]

        while stk and comparator(stk[-1], cur):
            stk.pop()
        ans[idx] = stk[-1] if stk else -1
        stk.append(cur)

    return ans&lt;/pre&gt;



&lt;!-- 单调队列结构解决滑动窗口问题  
【练习】单调队列的通用实现及经典习题   --&gt;
&lt;!-- ## [手把手刷二叉树算法](https://labuladong.online/algo/menu/binary-tree/)
### [二叉树系列算法核心纲领](https://labuladong.online/algo/essential-technique/binary-tree-summary/)
### [二叉树心法（思路篇）](https://labuladong.online/algo/data-structure/binary-tree-part1/)
### [二叉树心法（构造篇）](https://labuladong.online/algo/data-structure/binary-tree-part2/)
### [二叉树心法（后序篇）](https://labuladong.online/algo/data-structure/binary-tree-part3/)
### [二叉树心法（序列化篇）](https://labuladong.online/algo/data-structure/serialize-and-deserialize-binary-tree/)
### [二叉搜索树心法（特性篇）](https://labuladong.online/algo/data-structure/bst-part1/)
### [二叉搜索树心法（基操篇）](https://labuladong.online/algo/data-structure/bst-part2/)
### [二叉搜索树心法（构造篇）](https://labuladong.online/algo/data-structure/bst-part3/)
### [二叉搜索树心法（后序篇）](https://labuladong.online/algo/data-structure/bst-part4/)
## [套模板解决 100 道二叉树习题](https://labuladong.online/algo/menu/100-bt/) --&gt;



&lt;!-- 
### [本章导读](https://labuladong.online/algo/intro/binary-tree-practice/)
### [【强化练习】用「遍历」思维解题 I](https://labuladong.online/algo/problem-set/binary-tree-traverse-i/)
### [【强化练习】用「遍历」思维解题 II](https://labuladong.online/algo/problem-set/binary-tree-traverse-ii/)
### [【强化练习】用「遍历」思维解题 III](https://labuladong.online/algo/problem-set/binary-tree-traverse-iii/)
### [【强化练习】用「分解问题」思维解题 I](https://labuladong.online/algo/problem-set/binary-tree-divide-i/)
### [【强化练习】用「分解问题」思维解题 II](https://labuladong.online/algo/problem-set/binary-tree-divide-ii/)
### [【强化练习】同时运用两种思维解题](https://labuladong.online/algo/problem-set/binary-tree-combine-two-view/)
### [【强化练习】利用后序位置解题 I](https://labuladong.online/algo/problem-set/binary-tree-post-order-i/)
### [【强化练习】利用后序位置解题 II](https://labuladong.online/algo/problem-set/binary-tree-post-order-ii/)
### [【强化练习】利用后序位置解题 III](https://labuladong.online/algo/problem-set/binary-tree-post-order-iii/)
### [【强化练习】运用层序遍历解题 I](https://labuladong.online/algo/problem-set/binary-tree-level-i/)
### [【强化练习】运用层序遍历解题 II](https://labuladong.online/algo/problem-set/binary-tree-level-ii/)
### [【强化练习】二叉搜索树经典例题 I](https://labuladong.online/algo/problem-set/bst1/)
### [【强化练习】二叉搜索树经典例题 II](https://labuladong.online/algo/problem-set/bst2/)
## [二叉树的拓展延伸](https://labuladong.online/algo/menu/more-bt/)
### [拓展：最近公共祖先系列解题框架](https://labuladong.online/algo/practice-in-action/lowest-common-ancestor-summary/)
### [拓展：如何计算完全二叉树的节点数](https://labuladong.online/algo/data-structure/count-complete-tree-nodes/)
### [拓展：惰性展开多叉树](https://labuladong.online/algo/data-structure/flatten-nested-list-iterator/)
### [拓展：归并排序详解及应用](https://labuladong.online/algo/practice-in-action/merge-sort/)
### [拓展：快速排序详解及应用](https://labuladong.online/algo/practice-in-action/quick-sort/)
### [拓展：用栈模拟递归迭代遍历二叉树](https://labuladong.online/algo/data-structure/iterative-traversal-binary-tree/)
## [手把手设计数据结构](https://labuladong.online/algo/menu/design/)
### [队列实现栈以及栈实现队列](https://labuladong.online/algo/data-structure/stack-queue/)
### [【强化练习】栈的经典习题](https://labuladong.online/algo/problem-set/stack/)
### [【强化练习】括号类问题汇总](https://labuladong.online/algo/problem-set/parentheses/)
### [【强化练习】队列的经典习题](https://labuladong.online/algo/problem-set/queue/)
### [单调栈算法模板解决三道例题](https://labuladong.online/algo/data-structure/monotonic-stack/)
### [【强化练习】单调栈的几种变体及经典习题](https://labuladong.online/algo/problem-set/monotonic-stack/)
### [单调队列结构解决滑动窗口问题](https://labuladong.online/algo/data-structure/monotonic-queue/)
### [【强化练习】单调队列的通用实现及经典习题](https://labuladong.online/algo/problem-set/monotonic-queue/)
### [算法就像搭乐高：手撸 LRU 算法](https://labuladong.online/algo/data-structure/lru-cache/)
### [算法就像搭乐高：手撸 LFU 算法](https://labuladong.online/algo/frequency-interview/lfu/)
### [常数时间删除/查找数组中的任意元素](https://labuladong.online/algo/data-structure/random-set/)
### [【强化练习】哈希表更多习题](https://labuladong.online/algo/problem-set/hash-table/)
### [【强化练习】优先级队列经典习题](https://labuladong.online/algo/problem-set/binary-heap/)
### [TreeMap/TreeSet 代码实现](https://labuladong.online/algo/data-structure-basic/tree-map-implement/)
### [SegmentTree 线段树代码实现](https://labuladong.online/algo/data-structure/segment-tree-implement/)
### [Trie/字典树/前缀树代码实现](https://labuladong.online/algo/data-structure/trie-implement/)
### [【强化练习】Trie 树算法习题](https://labuladong.online/algo/problem-set/trie/)
### [设计朋友圈时间线功能](https://labuladong.online/algo/data-structure/design-twitter/)
### [设计考场座位分配算法](https://labuladong.online/algo/frequency-interview/exam-room/)
### [【强化练习】更多经典设计习题](https://labuladong.online/algo/problem-set/ds-design/)
### [拓展：如何实现一个计算器](https://labuladong.online/algo/data-structure/implement-calculator/)
### [拓展：两个二叉堆实现中位数算法](https://labuladong.online/algo/practice-in-action/find-median-from-data-stream/)
### [拓展：数组去重问题（困难版）](https://labuladong.online/algo/frequency-interview/remove-duplicate-letters/)
## [手把手刷图算法](https://labuladong.online/algo/menu/graph/)
### [环检测及拓扑排序算法](https://labuladong.online/algo/data-structure/topological-sort/)
### [众里寻他千百度：名流问题](https://labuladong.online/algo/frequency-interview/find-celebrity/)
### [二分图判定算法](https://labuladong.online/algo/data-structure/bipartite-graph/)
### [Union-Find 并查集算法](https://labuladong.online/algo/data-structure/union-find/)
### [【强化练习】并查集经典习题](https://labuladong.online/algo/problem-set/union-find/)
### [Kruskal 最小生成树算法](https://labuladong.online/algo/data-structure/kruskal/)
### [Prim 最小生成树算法](https://labuladong.online/algo/data-structure/prim/)
### [Dijkstra 算法模板及应用](https://labuladong.online/algo/data-structure/dijkstra/)
### [【强化练习】Dijkstra 算法经典习题](https://labuladong.online/algo/problem-set/dijkstra/) --&gt;
</code></pre>
]]></content>
      <categories>
        <category>labuladong算法笔记</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>排序算法</tag>
        <tag>cpp</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>华为入职培训-C++语言编程规范</title>
    <url>/2025/04/22/%E5%8D%8E%E4%B8%BA%E5%85%A5%E8%81%8C%E5%9F%B9%E8%AE%AD-C-%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/</url>
    <content><![CDATA[<h1 id="1-课程简介"><a href="#1-课程简介" class="headerlink" title="1. 课程简介"></a>1. 课程简介</h1><p>视频中说可以在公司内网下载，在互联网上找到一个版本<a href="https://blog.csdn.net/yaoming168/article/details/136063619">华为C++语言编程规范</a></p>
<h1 id="2-引言"><a href="#2-引言" class="headerlink" title="2. 引言"></a>2. 引言</h1><p>常见的c++中的未定义行为</p>
<ul>
<li>整数除以0</li>
<li>有符号的整数溢出</li>
<li>访问越界数组</li>
<li>使用未初始化的变量</li>
<li>越界访问</li>
<li>使用<code>new T[n]</code>分配数组，却用delete不带[]释放<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>* arr = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>];  <span class="comment">// 分配10个int的空间</span></span><br><span class="line"><span class="keyword">delete</span> arr;              <span class="comment">// 错误！应该用delete[] arr</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>关于指针，优先使用<strong>引用和智能指针</strong></p>
<h1 id="3-代码风格"><a href="#3-代码风格" class="headerlink" title="3. 代码风格"></a>3. 代码风格</h1><p>主要看项目组用啥命名风格，不推荐匈牙利</p>
<h1 id="4-编程实践"><a href="#4-编程实践" class="headerlink" title="4. 编程实践"></a>4. 编程实践</h1><h2 id="4-1-函数、类、常量"><a href="#4-1-函数、类、常量" class="headerlink" title="4.1 函数、类、常量"></a>4.1 函数、类、常量</h2><h3 id="输入校验原则"><a href="#输入校验原则" class="headerlink" title="输入校验原则"></a>输入校验原则</h3><p><img src="/../images/1745397201823-image.png" alt="alt text"></p>
<p>如上是两个函数单板的模型，首先熟悉一下相关的名词</p>
<ul>
<li>单板：一个函数或者一个类</li>
<li>.so文件：shared object file，这是Unix下的动态链接库，大概类似于windows下的dll</li>
</ul>
<p>大概意思是：</p>
<blockquote>
<p>外部数据输入（箭头①） 需要进行严格的校验，<strong>防止恶意数据注入</strong>。<br>内部数据传递（箭头②、④、⑤） 也需要进行适当的校验，确保数据的一致性和安全性。<br>应用层与内核层交互（箭头③） 更加需要严谨的校验机制，<strong>避免因数据问题导致系统崩溃或被攻击</strong>。</p>
</blockquote>
<p>c++中常见的函数输入校验：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">devide</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (b == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Divide by zero&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> a / b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="合理选择输入输出参数"><a href="#合理选择输入输出参数" class="headerlink" title="合理选择输入输出参数"></a>合理选择输入输出参数</h3><p>对于输入参数</p>
<ul>
<li>拷贝代价高，pass by reference</li>
<li>拷贝代价低，pass by value</li>
<li>要被移动的参数，作为参数的时候应该使用右值引用类型，在函数内用<code>std::move</code></li>
<li>不要用C风格的变参类型，因为没有办法验证输入</li>
</ul>
<h2 id="对于返回参数"><a href="#对于返回参数" class="headerlink" title="对于返回参数"></a>对于返回参数</h2><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>要保证类的封装性，要与外部解耦</p>
<p><img src="/../images/1745407464208-image.png" alt="alt text"></p>
<ul>
<li><strong>Rule of three</strong>: 拷贝构造函数、赋值运算符、析构函数</li>
<li><strong>Rule of five</strong>: 拷贝构造函数、赋值运算符、析构函数、移动构造函数、移动赋值运算符</li>
<li><strong>Rule of zero</strong>: 析构函数、移动构造函数、移动赋值运算符</li>
</ul>
<h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>多用常量，编译器检查友好，使得代码的可读性更高</p>
<h2 id="4-2-枚举、声明与定义"><a href="#4-2-枚举、声明与定义" class="headerlink" title="4.2 枚举、声明与定义"></a>4.2 枚举、声明与定义</h2><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>c++中优先使用枚举类，例如</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum class</span> <span class="title class_">Color</span> &#123; RED, GREEN, BLUE &#125;</span><br></pre></td></tr></table></figure>

<h3 id="声明与定义"><a href="#声明与定义" class="headerlink" title="声明与定义"></a>声明与定义</h3><p>避免定义保留标识符，如<code>void * malloc()</code>，malloc是C语言的标准库函数，在c++中应该使用<code>std::malloc</code></p>
<h3 id="作用域最小"><a href="#作用域最小" class="headerlink" title="作用域最小"></a>作用域最小</h3><p>避免使用全局变量，全局变量会污染命名空间，导致代码的可读性降低，也容易产生命名冲突</p>
<h2 id="4-3-类型转换、整数运算"><a href="#4-3-类型转换、整数运算" class="headerlink" title="4.3 类型转换、整数运算"></a>4.3 类型转换、整数运算</h2><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>用c++风格的类型转换，而不是c风格的类型转换。一般是是<code>dynamic_cast</code>，<code>static_cast</code>，<code>reinterpret_cast</code>，<code>const_cast</code>等的语法，其中<code>cast</code>有浇铸，铸造的意思</p>
<h3 id="整数运算"><a href="#整数运算" class="headerlink" title="整数运算"></a>整数运算</h3><p>注意整数的溢出和回绕的问题</p>
<h2 id="4-4-表达式、语句"><a href="#4-4-表达式、语句" class="headerlink" title="4.4 表达式、语句"></a>4.4 表达式、语句</h2><h3 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h3><ul>
<li>比较的时候，左边要放常量，右边放变量，<code>if (MAX == value)</code></li>
<li>副作用不要放到逻辑判断中，例如<code>if (a == 0 || b ++ &gt; 1)</code> 这种是不允许的</li>
<li>多使用<code>static_assert</code>在编译的时候检查，例如<code>static_assert(sizeof(int) == 4, &quot;int is not 4 bytes&quot;);</code></li>
<li><code>int</code>类似不能单独作为判断依据，例如如下是不允许的<code>int a = 0; if (a) &#123;xxx&#125;</code></li>
</ul>
<h2 id="4-5-资源管理、错误处理"><a href="#4-5-资源管理、错误处理" class="headerlink" title="4.5 资源管理、错误处理"></a>4.5 资源管理、错误处理</h2><h3 id="资源管理"><a href="#资源管理" class="headerlink" title="资源管理"></a>资源管理</h3><p>需要遵守RAII, Resource Acquisition Is Initialization,其主要的含义是</p>
<ul>
<li>初始化，初始化是资源的分配 </li>
<li>析构，析构是资源的释放<br>常见的对有<code>new/delete</code>操作的封装，<code>fopen/fclose</code>等</li>
</ul>
<h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p>有的地方是不能抛出异常的，例如：</p>
<ul>
<li>析构函数，析构函数不能抛出异常</li>
<li>要用<code>noexcept</code>修饰，例如<code>void foo() noexcept</code>表示这个函数不会抛出异常</li>
</ul>
<h2 id="4-6-模板与泛型编程、并发与并行"><a href="#4-6-模板与泛型编程、并发与并行" class="headerlink" title="4.6 模板与泛型编程、并发与并行"></a>4.6 模板与泛型编程、并发与并行</h2><h3 id="模板与泛型"><a href="#模板与泛型" class="headerlink" title="模板与泛型"></a>模板与泛型</h3><p>template并不是百利而无一害的，其可能造成<strong>代码膨胀</strong>：<br><img src="/../images/1745584892805-image.png" alt="alt text"></p>
<h2 id="4-7-预处理、头文件与源文件"><a href="#4-7-预处理、头文件与源文件" class="headerlink" title="4.7 预处理、头文件与源文件"></a>4.7 预处理、头文件与源文件</h2><h3 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h3><p><img src="/../images/1745671766322-image.png" alt="alt text"></p>
<ul>
<li>避免使用宏</li>
</ul>
<h3 id="头文件与源文件"><a href="#头文件与源文件" class="headerlink" title="头文件与源文件"></a>头文件与源文件</h3><p><img src="/../images/1745672089703-image.png" alt="alt text"></p>
<ul>
<li>自己的头文件用 “”</li>
<li>第三方库用 &lt;&gt;</li>
</ul>
<h2 id="4-8-标准库"><a href="#4-8-标准库" class="headerlink" title="4.8 标准库"></a>4.8 标准库</h2><h3 id="优先使用c-的标准库"><a href="#优先使用c-的标准库" class="headerlink" title="优先使用c++的标准库"></a>优先使用c++的标准库</h3><p>尽量不是用c的标准库</p>
<h3 id="注意线程不安全-异步不安全的函数"><a href="#注意线程不安全-异步不安全的函数" class="headerlink" title="注意线程不安全&#x2F;异步不安全的函数"></a>注意线程不安全&#x2F;异步不安全的函数</h3><h1 id="5-继承自C语言编程规范条款款"><a href="#5-继承自C语言编程规范条款款" class="headerlink" title="5. 继承自C语言编程规范条款款"></a>5. 继承自C语言编程规范条款款</h1><p><img src="/../images/1745840906133-image.png" alt="alt text"></p>
<ul>
<li>断言不能用在正式版本中，只能在调试的过程中使用，例如<code>assert(x &gt; 0)</code></li>
</ul>
]]></content>
      <categories>
        <category>软件雏鹰计划</category>
      </categories>
      <tags>
        <tag>cpp</tag>
        <tag>华为</tag>
        <tag>编程规范</tag>
      </tags>
  </entry>
</search>
